var wxtiledeckgl = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[Object.keys(cb)[0]])((mod3 = {exports: {}}).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };

  // node_modules/regenerator-runtime/runtime.js
  var require_runtime = __commonJS({
    "node_modules/regenerator-runtime/runtime.js"(exports, module2) {
      var runtime = function(exports2) {
        "use strict";
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined2;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define2(obj, key, value17) {
          Object.defineProperty(obj, key, {
            value: value17,
            enumerable: true,
            configurable: true,
            writable: true
          });
          return obj[key];
        }
        try {
          define2({}, "");
        } catch (err) {
          define2 = function(obj, key, value17) {
            return obj[key] = value17;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          generator._invoke = makeInvokeMethod(innerFn, self2, context);
          return generator;
        }
        exports2.wrap = wrap;
        function tryCatch(fn, obj, arg) {
          try {
            return {type: "normal", arg: fn.call(obj, arg)};
          } catch (err) {
            return {type: "throw", arg: err};
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        IteratorPrototype[iteratorSymbol] = function() {
          return this;
        };
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define2(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports2.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports2.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define2(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports2.awrap = function(arg) {
          return {__await: arg};
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value17 = result.value;
              if (value17 && typeof value17 === "object" && hasOwn.call(value17, "__await")) {
                return PromiseImpl.resolve(value17.__await).then(function(value18) {
                  invoke("next", value18, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value17).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error2) {
                return invoke("throw", error2, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
          this._invoke = enqueue;
        }
        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function() {
          return this;
        };
        exports2.AsyncIterator = AsyncIterator;
        exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0)
            PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];
          if (method === undefined2) {
            context.delegate = null;
            if (context.method === "throw") {
              if (delegate.iterator["return"]) {
                context.method = "return";
                context.arg = undefined2;
                maybeInvokeDelegate(delegate, context);
                if (context.method === "throw") {
                  return ContinueSentinel;
                }
              }
              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined2;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define2(Gp, toStringTagSymbol, "Generator");
        Gp[iteratorSymbol] = function() {
          return this;
        };
        Gp.toString = function() {
          return "[object Generator]";
        };
        function pushTryEntry(locs) {
          var entry = {tryLoc: locs[0]};
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{tryLoc: "root"}];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports2.keys = function(object) {
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key2 = keys.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next2.value = iterable[i];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined2;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          return {next: doneResult};
        }
        exports2.values = values;
        function doneResult() {
          return {value: undefined2, done: true};
        }
        Context.prototype = {
          constructor: Context,
          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined2;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined2;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name in this) {
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined2;
                }
              }
            }
          },
          stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined2;
              }
              return !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined2;
            }
            return ContinueSentinel;
          }
        };
        return exports2;
      }(typeof module2 === "object" ? module2.exports : {});
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  });

  // node_modules/@babel/runtime/regenerator/index.js
  var require_regenerator = __commonJS({
    "node_modules/@babel/runtime/regenerator/index.js"(exports, module2) {
      module2.exports = require_runtime();
    }
  });

  // node_modules/@babel/runtime/helpers/interopRequireDefault.js
  var require_interopRequireDefault = __commonJS({
    "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module2) {
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      module2.exports = _interopRequireDefault;
      module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          module2.exports = _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
          module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
        } else {
          module2.exports = _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
          module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
        }
        return _typeof2(obj);
      }
      module2.exports = _typeof2;
      module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
    }
  });

  // node_modules/@babel/runtime/helpers/interopRequireWildcard.js
  var require_interopRequireWildcard = __commonJS({
    "node_modules/@babel/runtime/helpers/interopRequireWildcard.js"(exports, module2) {
      var _typeof2 = require_typeof()["default"];
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = new WeakMap();
        var cacheNodeInterop = new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return {
            "default": obj
          };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      module2.exports = _interopRequireWildcard;
      module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
    }
  });

  // node_modules/probe.gl/dist/es5/env/globals.js
  var require_globals = __commonJS({
    "node_modules/probe.gl/dist/es5/env/globals.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var globals5 = {
        self: typeof self !== "undefined" && self,
        window: typeof window !== "undefined" && window,
        global: typeof global !== "undefined" && global,
        document: typeof document !== "undefined" && document,
        process: (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === "object" && process
      };
      var self_4 = globals5.self || globals5.window || globals5.global;
      exports.self = self_4;
      var window_5 = globals5.window || globals5.self || globals5.global;
      exports.window = window_5;
      var global_7 = globals5.global || globals5.self || globals5.window;
      exports.global = global_7;
      var document_4 = globals5.document || {};
      exports.document = document_4;
      var process_2 = globals5.process || {};
      exports.process = process_2;
      var console_2 = console;
      exports.console = console_2;
    }
  });

  // node_modules/probe.gl/dist/es5/env/is-electron.js
  var require_is_electron = __commonJS({
    "node_modules/probe.gl/dist/es5/env/is-electron.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = isElectron2;
      var _typeof2 = _interopRequireDefault(require_typeof());
      function isElectron2(mockUserAgent) {
        if (typeof window !== "undefined" && (0, _typeof2["default"])(window.process) === "object" && window.process.type === "renderer") {
          return true;
        }
        if (typeof process !== "undefined" && (0, _typeof2["default"])(process.versions) === "object" && Boolean(process.versions.electron)) {
          return true;
        }
        var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2["default"])(navigator)) === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
        var userAgent2 = mockUserAgent || realUserAgent;
        if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
          return true;
        }
        return false;
      }
    }
  });

  // node_modules/probe.gl/dist/es5/env/is-browser.js
  var require_is_browser = __commonJS({
    "node_modules/probe.gl/dist/es5/env/is-browser.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = isBrowser8;
      exports.isBrowserMainThread = isBrowserMainThread;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _isElectron = _interopRequireDefault(require_is_electron());
      function isBrowser8() {
        var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === "object" && String(process) === "[object process]" && !process.browser;
        return !isNode || (0, _isElectron["default"])();
      }
      function isBrowserMainThread() {
        return isBrowser8() && typeof document !== "undefined";
      }
    }
  });

  // node_modules/probe.gl/dist/es5/env/get-browser.js
  var require_get_browser = __commonJS({
    "node_modules/probe.gl/dist/es5/env/get-browser.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isMobile = isMobile2;
      exports["default"] = getBrowser3;
      var _globals = require_globals();
      var _isBrowser = _interopRequireDefault(require_is_browser());
      var _isElectron = _interopRequireDefault(require_is_electron());
      function isMobile2() {
        return typeof _globals.window.orientation !== "undefined";
      }
      function getBrowser3(mockUserAgent) {
        if (!mockUserAgent && !(0, _isBrowser["default"])()) {
          return "Node";
        }
        if ((0, _isElectron["default"])(mockUserAgent)) {
          return "Electron";
        }
        var navigator_ = typeof navigator !== "undefined" ? navigator : {};
        var userAgent2 = mockUserAgent || navigator_.userAgent || "";
        if (userAgent2.indexOf("Edge") > -1) {
          return "Edge";
        }
        var isMSIE = userAgent2.indexOf("MSIE ") !== -1;
        var isTrident = userAgent2.indexOf("Trident/") !== -1;
        if (isMSIE || isTrident) {
          return "IE";
        }
        if (_globals.window.chrome) {
          return "Chrome";
        }
        if (_globals.window.safari) {
          return "Safari";
        }
        if (_globals.window.mozInnerScreenX) {
          return "Firefox";
        }
        return "Unknown";
      }
    }
  });

  // node_modules/probe.gl/dist/es5/env/index.js
  var require_env = __commonJS({
    "node_modules/probe.gl/dist/es5/env/index.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _interopRequireWildcard = require_interopRequireWildcard();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "self", {
        enumerable: true,
        get: function get2() {
          return _globals.self;
        }
      });
      Object.defineProperty(exports, "window", {
        enumerable: true,
        get: function get2() {
          return _globals.window;
        }
      });
      Object.defineProperty(exports, "global", {
        enumerable: true,
        get: function get2() {
          return _globals.global;
        }
      });
      Object.defineProperty(exports, "document", {
        enumerable: true,
        get: function get2() {
          return _globals.document;
        }
      });
      Object.defineProperty(exports, "process", {
        enumerable: true,
        get: function get2() {
          return _globals.process;
        }
      });
      Object.defineProperty(exports, "console", {
        enumerable: true,
        get: function get2() {
          return _globals.console;
        }
      });
      Object.defineProperty(exports, "isBrowser", {
        enumerable: true,
        get: function get2() {
          return _isBrowser["default"];
        }
      });
      Object.defineProperty(exports, "isBrowserMainThread", {
        enumerable: true,
        get: function get2() {
          return _isBrowser.isBrowserMainThread;
        }
      });
      Object.defineProperty(exports, "getBrowser", {
        enumerable: true,
        get: function get2() {
          return _getBrowser["default"];
        }
      });
      Object.defineProperty(exports, "isMobile", {
        enumerable: true,
        get: function get2() {
          return _getBrowser.isMobile;
        }
      });
      Object.defineProperty(exports, "isElectron", {
        enumerable: true,
        get: function get2() {
          return _isElectron["default"];
        }
      });
      var _globals = require_globals();
      var _isBrowser = _interopRequireWildcard(require_is_browser());
      var _getBrowser = _interopRequireWildcard(require_get_browser());
      var _isElectron = _interopRequireDefault(require_is_electron());
    }
  });

  // node_modules/probe.gl/env.js
  var require_env2 = __commonJS({
    "node_modules/probe.gl/env.js"(exports, module2) {
      module2.exports = require_env();
    }
  });

  // node_modules/hammerjs/hammer.js
  var require_hammer = __commonJS({
    "node_modules/hammerjs/hammer.js"(exports, module2) {
      (function(window2, document2, exportName, undefined2) {
        "use strict";
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document2.createElement("div");
        var TYPE_FUNCTION = "function";
        var round2 = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
        }
        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        function each(obj, iterator, context) {
          var i;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined2) {
            i = 0;
            while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
            }
          } else {
            for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
          }
        }
        function deprecate(method, name, message) {
          var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
          return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log3 = window2.console && (window2.console.warn || window2.console.log);
            if (log3) {
              log3.call(window2.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
          };
        }
        var assign;
        if (typeof Object.assign !== "function") {
          assign = function assign2(target) {
            if (target === undefined2 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined2 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign = Object.assign;
        }
        var extend = deprecate(function extend2(dest, src, merge2) {
          var keys = Object.keys(src);
          var i = 0;
          while (i < keys.length) {
            if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
              dest[keys[i]] = src[keys[i]];
            }
            i++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge = deprecate(function merge2(dest, src) {
          return extend(dest, src, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign(childP, properties);
          }
        }
        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        function boolOrFn(val, args) {
          if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined2 : undefined2, args);
          }
          return val;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined2 ? val2 : val1;
        }
        function addEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node2, parent) {
          while (node2) {
            if (node2 == parent) {
              return true;
            }
            node2 = node2.parentNode;
          }
          return false;
        }
        function inStr(str, find) {
          return str.indexOf(find) > -1;
        }
        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i = 0;
            while (i < src.length) {
              if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                return i;
              }
              i++;
            }
            return -1;
          }
        }
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i = 0;
          while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
              results.push(src[i]);
            }
            values[i] = val;
            i++;
          }
          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i = 0;
          while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i++;
          }
          return undefined2;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window2;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window2;
        var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START2 = 1;
        var INPUT_MOVE2 = 2;
        var INPUT_END2 = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input(manager, callback) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input.prototype = {
          handler: function() {
          },
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
          } else {
            Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale2(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }
          input.target = target;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i = 0;
          while (i < input.pointers.length) {
            pointers[i] = {
              clientX: round2(input.pointers[i].clientX),
              clientY: round2(input.pointers[i].clientY)
            };
            i++;
          }
          return {
            timeStamp: now(),
            pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round2(pointers[0].clientX),
              y: round2(pointers[0].clientY)
            };
          }
          var x = 0, y = 0, i = 0;
          while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
          }
          return {
            x: round2(x / pointersLength),
            y: round2(y / pointersLength)
          };
        }
        function getVelocity(deltaTime, x, y) {
          return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
          };
        }
        function getDirection(x, y) {
          if (x === y) {
            return DIRECTION_NONE;
          }
          if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x * x + y * y);
        }
        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
        }
        function getRotation(start2, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start2[1], start2[0], PROPS_CLIENT_XY);
        }
        function getScale2(start2, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start2[0], start2[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP2 = {
          mousedown: INPUT_START2,
          mousemove: INPUT_MOVE2,
          mouseup: INPUT_END2
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input.apply(this, arguments);
        }
        inherit(MouseInput, Input, {
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP2[ev.type];
            if (eventType & INPUT_START2 && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE2 && ev.which !== 1) {
              eventType = INPUT_END2;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END2) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START2,
          pointermove: INPUT_MOVE2,
          pointerup: INPUT_END2,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window2.MSPointerEvent && !window2.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput, Input, {
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START2) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
          }
          return [all, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input.apply(this, arguments);
        }
        inherit(TouchInput, Input, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
          });
          if (type === INPUT_START2) {
            i = 0;
            while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
            }
          }
          i = 0;
          while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END2 | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
            }
            i++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input, {
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START2) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = {x: touch.clientX, y: touch.clientY};
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                lts.splice(i, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
          for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value17) {
          this.manager = manager;
          this.set(value17);
        }
        TouchAction.prototype = {
          set: function(value17) {
            if (value17 == TOUCH_ACTION_COMPUTE) {
              value17 = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value17]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value17;
            }
            this.actions = value17.toLowerCase().trim();
          },
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window2.CSS && window2.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
            touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          defaults: {},
          set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
              this.requireFail.splice(index, 1);
            }
            return this;
          },
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          emit: function(input) {
            var self2 = this;
            var state = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state < STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
          },
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i++;
            }
            return true;
          },
          recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          process: function(inputData) {
          },
          getTouchAction: function() {
          },
          reset: function() {
          }
        };
        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return "cancel";
          } else if (state & STATE_ENDED) {
            return "end";
          } else if (state & STATE_CHANGED) {
            return "move";
          } else if (state & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          defaults: {
            pointers: 1
          },
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END2) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance2 = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance2 = Math.abs(input.deltaX);
              } else {
                direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance2 = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance2 > options.threshold && direction & options.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START2) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END2) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END2) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START2 && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END2) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager2(element, options);
        }
        Hammer.VERSION = "2.0.7";
        Hammer.defaults = {
          domEvents: false,
          touchAction: TOUCH_ACTION_COMPUTE,
          enable: true,
          inputTarget: null,
          inputClass: null,
          preset: [
            [RotateRecognizer, {enable: false}],
            [PinchRecognizer, {enable: false}, ["rotate"]],
            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, {event: "doubletap", taps: 2}, ["tap"]],
            [PressRecognizer]
          ],
          cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager2(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager2.prototype = {
          set: function(options) {
            assign(this.options, options);
            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          },
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
              recognizer = recognizers[i];
              if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
            }
          },
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
              }
            }
            return null;
          },
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);
              if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          on: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            if (handler === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          off: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          emit: function(event, data) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function() {
              data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
              handlers[i](data);
              i++;
            }
          },
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add6) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function(value17, name) {
            prop = prefixed(element.style, name);
            if (add6) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value17;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add6) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data) {
          var gestureEvent = document2.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer, {
          INPUT_START: INPUT_START2,
          INPUT_MOVE: INPUT_MOVE2,
          INPUT_END: INPUT_END2,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager: Manager2,
          Input,
          TouchAction,
          TouchInput,
          MouseInput,
          PointerEventInput,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each,
          merge,
          extend,
          assign,
          inherit,
          bindFn,
          prefixed
        });
        var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer;
        if (typeof define === "function" && define.amd) {
          define(function() {
            return Hammer;
          });
        } else if (typeof module2 != "undefined" && module2.exports) {
          module2.exports = Hammer;
        } else {
          window2[exportName] = Hammer;
        }
      })(window, document, "Hammer");
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module2) {
      "use strict";
      module2.exports = earcut2;
      module2.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
      function linkedList(data, start2, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start2, end, dim) > 0) {
          for (i = start2; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start2; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals5(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start2, end) {
        if (!start2)
          return start2;
        if (!end)
          end = start2;
        var p = start2, again;
        do {
          again = false;
          if (!p.steiner && (equals5(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start2, triangles, dim) {
        var p = start2;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals5(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start2 = b;
          }
          p = p.next;
        } while (p !== start2);
        return filterPoints(p);
      }
      function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
        var a = start2;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize);
              earcutLinked(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start2);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len2, start2, end, list;
        for (i = 0, len2 = holeIndices.length; i < len2; i++) {
          start2 = holeIndices[i] * dim;
          end = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start2, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          var b = splitPolygon(outerNode, hole);
          filterPoints(outerNode, outerNode.next);
          filterPoints(b, b.next);
        }
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              if (x === hx) {
                if (hy === p.y)
                  return p;
                if (hy === p.next.y)
                  return p.next;
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        if (hx === qx)
          return m;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }
      function indexCurve(start2, minX, minY, invSize) {
        var p = start2;
        do {
          if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start2);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, invSize) {
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost(start2) {
        var p = start2, leftmost = start2;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start2);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals5(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals5(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len2 = holeIndices.length; i < len2; i++) {
            var start2 = holeIndices[i] * dim;
            var end = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start2, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start2, end, dim) {
        var sum = 0;
        for (var i = start2, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = {vertices: [], holes: [], dimensions: dim}, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/@mapbox/tiny-sdf/index.js
  var require_tiny_sdf = __commonJS({
    "node_modules/@mapbox/tiny-sdf/index.js"(exports, module2) {
      "use strict";
      module2.exports = TinySDF2;
      module2.exports.default = TinySDF2;
      var INF = 1e20;
      function TinySDF2(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
        this.fontSize = fontSize || 24;
        this.buffer = buffer === void 0 ? 3 : buffer;
        this.cutoff = cutoff || 0.25;
        this.fontFamily = fontFamily || "sans-serif";
        this.fontWeight = fontWeight || "normal";
        this.radius = radius || 8;
        var size = this.size = this.fontSize + this.buffer * 2;
        var gridSize = size + this.buffer * 2;
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.canvas.height = size;
        this.ctx = this.canvas.getContext("2d");
        this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily;
        this.ctx.textAlign = "left";
        this.ctx.fillStyle = "black";
        this.gridOuter = new Float64Array(gridSize * gridSize);
        this.gridInner = new Float64Array(gridSize * gridSize);
        this.f = new Float64Array(gridSize);
        this.z = new Float64Array(gridSize + 1);
        this.v = new Uint16Array(gridSize);
        this.useMetrics = this.ctx.measureText("A").actualBoundingBoxLeft !== void 0;
        this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
      }
      function prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {
        gridOuter.fill(INF, 0, width * height);
        gridInner.fill(0, 0, width * height);
        var offset = (width - glyphWidth) / 2;
        for (var y = 0; y < glyphHeight; y++) {
          for (var x = 0; x < glyphWidth; x++) {
            var j = (y + offset) * width + x + offset;
            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255;
            if (a === 1) {
              gridOuter[j] = 0;
              gridInner[j] = INF;
            } else if (a === 0) {
              gridOuter[j] = INF;
              gridInner[j] = 0;
            } else {
              var b = Math.max(0, 0.5 - a);
              var c = Math.max(0, a - 0.5);
              gridOuter[j] = b * b;
              gridInner[j] = c * c;
            }
          }
        }
      }
      function extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {
        for (var i = 0; i < width * height; i++) {
          var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
          alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));
        }
      }
      TinySDF2.prototype._draw = function(char, getMetrics) {
        var textMetrics = this.ctx.measureText(char);
        var advance = textMetrics.width;
        var doubleBuffer = 2 * this.buffer;
        var width, glyphWidth, height, glyphHeight, top;
        var imgTop, imgLeft, baselinePosition;
        if (getMetrics && this.useMetrics) {
          top = Math.floor(textMetrics.actualBoundingBoxAscent);
          baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);
          imgTop = this.buffer;
          imgLeft = this.buffer;
          glyphWidth = Math.min(this.size, Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));
          glyphHeight = Math.min(this.size - imgTop, Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));
          width = glyphWidth + doubleBuffer;
          height = glyphHeight + doubleBuffer;
          this.ctx.textBaseline = "alphabetic";
        } else {
          width = glyphWidth = this.size;
          height = glyphHeight = this.size;
          top = 19 * this.fontSize / 24;
          imgTop = imgLeft = 0;
          baselinePosition = this.middle;
          this.ctx.textBaseline = "middle";
        }
        var imgData;
        if (glyphWidth && glyphHeight) {
          this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);
          this.ctx.fillText(char, this.buffer, baselinePosition);
          imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);
        }
        var alphaChannel = new Uint8ClampedArray(width * height);
        prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);
        edt(this.gridOuter, width, height, this.f, this.v, this.z);
        edt(this.gridInner, width, height, this.f, this.v, this.z);
        extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);
        return {
          data: alphaChannel,
          metrics: {
            width: glyphWidth,
            height: glyphHeight,
            sdfWidth: width,
            sdfHeight: height,
            top,
            left: 0,
            advance
          }
        };
      };
      TinySDF2.prototype.draw = function(char) {
        return this._draw(char, false).data;
      };
      TinySDF2.prototype.drawWithMetrics = function(char) {
        return this._draw(char, true);
      };
      function edt(data, width, height, f, v, z) {
        for (var x = 0; x < width; x++)
          edt1d(data, x, width, height, f, v, z);
        for (var y = 0; y < height; y++)
          edt1d(data, y * width, 1, width, f, v, z);
      }
      function edt1d(grid, offset, stride, length4, f, v, z) {
        var q, k, s, r;
        v[0] = 0;
        z[0] = -INF;
        z[1] = INF;
        for (q = 0; q < length4; q++)
          f[q] = grid[offset + q * stride];
        for (q = 1, k = 0, s = 0; q < length4; q++) {
          do {
            r = v[k];
            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
          } while (s <= z[k] && --k > -1);
          k++;
          v[k] = q;
          z[k] = s;
          z[k + 1] = INF;
        }
        for (q = 0, k = 0; q < length4; q++) {
          while (z[k + 1] < q)
            k++;
          r = v[k];
          grid[offset + q * stride] = f[r] + (q - r) * (q - r);
        }
      }
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    getURI: () => getURI,
    start: () => start
  });

  // src/shaders/bitmap-layer-vertex.vs
  var bitmap_layer_vertex_default = "#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\n// SERG\nuniform float zoom;\nvarying vec2 vTexCoordC;\n// varying vec2 vTexCoordR;\n// varying vec2 vTexCoordD;\n// SERG\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if(coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy;\n  } else if(coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  // Tiles are 258x258. 1 pixel border is used to calc isolines and proper interpolation. It needs to be excluded from 'tile filling' process.\n  // Modifying 'vertexPosition' in order to skip borders.\n  const float tileSzExInv = 1.0 / 258.0;\n  const float tileM = 256.0 / 258.0;\n  const vec2 one = vec2(tileSzExInv, tileSzExInv);\n  vTexCoordC = texCoords * tileM + one;\n\n  // // the size of a tile in screen-pixels. It makes 'shift' better.\n  // // float shift = tileSzExInv / zoom; // current zoom let us work out the thickness of the isolines.\n  // float shift = 1.2 * tileSzExInv; // current zoom let us work out the thickness of the isolines.\n\n  // // calculating coords of R(right) and D(down) pixels, which are used to calc ISOlines.\n  // vTexCoordR = vTexCoordC + vec2(shift, 0.0);\n  // vTexCoordD = vTexCoordC + vec2(0.0, shift);\n}";

  // src/shaders/bitmap-layer-fragment.fs
  var bitmap_layer_fragment_default = "/**\n * Pack the top 12 bits of two normalized floats into 3 8-bit (rgb) values\n * This enables addressing 4096x4096 individual pixels\n *\n * returns vec3 encoded RGB colors\n *  result.r - top 8 bits of u\n *  result.g - top 8 bits of v\n *  result.b - next 4 bits of u and v: (u + v * 16)\n */\n\n #define SHADER_NAME bitmap-layer-fragment-shader\n\n #ifdef GL_ES\nprecision highp float;\n #endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n /* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n // from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(radians(x) + PI, PI + log(tan(PI * 0.25 + radians(y) * 0.5))) * WORLD_SCALE;\n}\n\n // from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(xy.x - PI, atan(exp(xy.y - PI)) * 2.0 - PI * 0.5));\n}\n /* End projection utils */\n\n // apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n // apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n // blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor, vec4(color, 1.0), alpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2((pos.x - bounds[0]) / (bounds[2] - bounds[0]), (pos.y - bounds[3]) / (bounds[1] - bounds[3]));\n}\n\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n\nuniform float dataMin;\nuniform float dataDif;\nuniform float clutMin;\nuniform float clutDif;\nvarying vec2 vTexCoordC;\n// varying vec2 vTexCoordR;\n// varying vec2 vTexCoordD;\nuniform sampler2D clutTextureUniform;\n\n// Consts\n  // Tiles are 258x258. 1 pixel border is used to calc isolines and proper interpolation. It needs to be excluded from 'tile filling' process.\n  // Modifying 'vertexPosition' in order to skip borders.\nconst float tileSzExInv = 1.0 / 258.0;\nconst float tileM = 256.0 / 258.0;\nconst vec2 one = vec2(tileSzExInv, tileSzExInv);\nconst float shift = 1.2 * tileSzExInv; // current zoom let us work out the thickness of the isolines.\n\n// Func Protos\nfloat GetRawData(vec2);\nfloat RawToPos(float);\nvec4 CLUT(float);\nint ISO(float);\n\nvoid main(void) {\n  vec2 uvC = vTexCoordC;\n  if(coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uvC = getUV(lnglat);\n  } else if(coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uvC = getUV(commonPos);\n  }\n\n  vec2 vTexCoordR = uvC + vec2(shift, 0.0);\n  vec2 vTexCoordD = uvC + vec2(0.0, shift);\n\n  float rawC = GetRawData(uvC); // central\n  float posC = RawToPos(rawC);\n  vec4 colorC = CLUT(posC);\n  int isoC = ISO(posC);\n\n  float rawR = GetRawData(vTexCoordR); // central\n  float posR = RawToPos(rawR);\n  int isoR = ISO(posR);\n\n  float rawD = GetRawData(vTexCoordD); // central\n  float posD = RawToPos(rawD);\n  int isoD = ISO(posD);\n\n  gl_FragColor = colorC;\n  if(isoC != isoD || isoC != isoR) {\n    gl_FragColor = vec4(1.0 - colorC.r, 1.0 - colorC.g, 1.0 - colorC.b, colorC.a);\n        // gl_FragColor = vec4(colorC.r, colorC.g, colorC.b, colorC.a);\n  }\n\n  geometry.uv = uvC;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if(picking_uActive) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uvC);\n  }\n}\n\nfloat GetRawData(vec2 texCoord) {\n  vec4 tex = texture2D(bitmapTexture, texCoord);\n  float texData = tex.r / 255.0 + tex.g;\n  float rawData = texData * dataDif + dataMin;\n  return rawData;\n}\n\nfloat RawToPos(float realData) {\n  float pos = (realData - clutMin) / clutDif;\n  return pos;\n}\n\nvec4 CLUT(float pos) {\n  return texture2D(clutTextureUniform, vec2(pos, 0.0));\n}\n\nint ISO(float pos) {\n  return int(texture2D(clutTextureUniform, vec2(pos, 1.0)).r * 255.0);\n}\n";

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }

  // node_modules/@babel/runtime/helpers/esm/superPropBase.js
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null)
        break;
    }
    return object;
  }

  // node_modules/@babel/runtime/helpers/esm/get.js
  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get2(target2, property2, receiver2) {
        var base = _superPropBase(target2, property2);
        if (!base)
          return;
        var desc = Object.getOwnPropertyDescriptor(base, property2);
        if (desc.get) {
          return desc.get.call(receiver2);
        }
        return desc.value;
      };
    }
    return _get(target, property, receiver || target);
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global;
  var window_ = globals.window || globals.self || globals.global;
  var global_ = globals.global || globals.self || globals.window;
  var document_ = globals.document || {};
  var isBrowser = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
  var isWorker = typeof importScripts === "function";
  var matches = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value17) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value17,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value17;
    }
    return obj;
  }

  // node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value17 = info.value;
    } catch (error2) {
      reject(error2);
      return;
    }
    if (info.done) {
      resolve(value17);
    } else {
      Promise.resolve(value17).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value17) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value17);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js
  function getTransferList(object) {
    var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var transfers = arguments.length > 2 ? arguments[2] : void 0;
    var transfersSet = transfers || new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && _typeof(object) === "object") {
      for (var key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js
  var VERSION = true ? "2.3.13" : "";
  function validateLoaderVersion(loader) {
    var coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
    assert(loader, "no loader provided");
    var loaderVersion = loader.version;
    if (!coreVersion || !loaderVersion) {
      return;
    }
    coreVersion = parseVersion(coreVersion);
    loaderVersion = parseVersion(loaderVersion);
  }
  function parseVersion(version2) {
    var parts = version2.split(".").map(Number);
    return {
      major: parts[0],
      minor: parts[1]
    };
  }

  // node_modules/@babel/runtime/helpers/esm/AwaitValue.js
  function _AwaitValue(value17) {
    this.wrapped = value17;
  }

  // node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js
  function _awaitAsyncGenerator(value17) {
    return new _AwaitValue(value17);
  }

  // node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js
  function AsyncGenerator(gen) {
    var front, back;
    function send(key, arg) {
      return new Promise(function(resolve, reject) {
        var request = {
          key,
          arg,
          resolve,
          reject,
          next: null
        };
        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }
    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value17 = result.value;
        var wrappedAwait = value17 instanceof _AwaitValue;
        Promise.resolve(wrappedAwait ? value17.wrapped : value17).then(function(arg2) {
          if (wrappedAwait) {
            resume(key === "return" ? "return" : "next", arg2);
            return;
          }
          settle(result.done ? "return" : "normal", arg2);
        }, function(err) {
          resume("throw", err);
        });
      } catch (err) {
        settle("throw", err);
      }
    }
    function settle(type, value17) {
      switch (type) {
        case "return":
          front.resolve({
            value: value17,
            done: true
          });
          break;
        case "throw":
          front.reject(value17);
          break;
        default:
          front.resolve({
            value: value17,
            done: false
          });
          break;
      }
      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }
    this._invoke = send;
    if (typeof gen["return"] !== "function") {
      this["return"] = void 0;
    }
  }
  AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function() {
    return this;
  };
  AsyncGenerator.prototype.next = function(arg) {
    return this._invoke("next", arg);
  };
  AsyncGenerator.prototype["throw"] = function(arg) {
    return this._invoke("throw", arg);
  };
  AsyncGenerator.prototype["return"] = function(arg) {
    return this._invoke("return", arg);
  };

  // node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js
  function _wrapAsyncGenerator(fn) {
    return function() {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }

  // node_modules/@babel/runtime/helpers/esm/asyncIterator.js
  function _asyncIterator(iterable) {
    var method;
    if (typeof Symbol !== "undefined") {
      if (Symbol.asyncIterator)
        method = iterable[Symbol.asyncIterator];
      if (method == null && Symbol.iterator)
        method = iterable[Symbol.iterator];
    }
    if (method == null)
      method = iterable["@@asyncIterator"];
    if (method == null)
      method = iterable["@@iterator"];
    if (method == null)
      throw new TypeError("Object is not async iterable");
    return method.call(iterable);
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js
  var import_regenerator3 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js
  var import_regenerator2 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js
  var import_regenerator = __toModule(require_regenerator());

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js
  var workerURLCache = new Map();
  function getWorkerURL(workerSource) {
    var workerName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Worker";
    assert(typeof workerSource === "string", "worker source");
    if (workerSource.startsWith("url(") && workerSource.endsWith(")")) {
      var workerUrl = workerSource.match(/^url\((.*)\)$/)[1];
      if (workerUrl && !workerUrl.startsWith("http")) {
        return workerUrl;
      }
      workerSource = buildScript(workerUrl);
    }
    var workerURL = workerURLCache.get(workerSource);
    if (!workerURL) {
      var blob = new Blob([workerSource], {
        type: "application/javascript"
      });
      workerURL = URL.createObjectURL(blob);
      workerURLCache.set(workerSource, workerURL);
    }
    return workerURL;
  }
  function buildScript(workerUrl) {
    return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n}");
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js
  var count = 0;
  function defaultOnMessage(_ref) {
    var data = _ref.data, resolve = _ref.resolve;
    resolve(data);
  }
  var WorkerThread = function() {
    function WorkerThread2(_ref2) {
      var source = _ref2.source, _ref2$name = _ref2.name, name = _ref2$name === void 0 ? "web-worker-".concat(count++) : _ref2$name, onMessage = _ref2.onMessage;
      _classCallCheck(this, WorkerThread2);
      var url = getWorkerURL(source, name);
      this.worker = new Worker(url, {
        name
      });
      this.name = name;
      this.onMessage = onMessage || defaultOnMessage;
    }
    _createClass(WorkerThread2, [{
      key: "process",
      value: function() {
        var _process = _asyncToGenerator(import_regenerator.default.mark(function _callee(data) {
          var _this = this;
          return import_regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", new Promise(function(resolve, reject) {
                    _this.worker.onmessage = function(event) {
                      _this.onMessage({
                        worker: _this.worker,
                        data: event.data,
                        resolve,
                        reject
                      });
                    };
                    _this.worker.onerror = function(error2) {
                      var message = "".concat(_this.name, ": WorkerThread.process() failed");
                      if (error2.message) {
                        message += " ".concat(error2.message, " ").concat(error2.filename, ":").concat(error2.lineno, ":").concat(error2.colno);
                      }
                      var betterError = new Error(message);
                      console.error(error2);
                      reject(betterError);
                    };
                    var transferList = getTransferList(data);
                    _this.worker.postMessage(data, transferList);
                  }));
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function process2(_x) {
          return _process.apply(this, arguments);
        }
        return process2;
      }()
    }, {
      key: "destroy",
      value: function destroy() {
        this.worker.terminate();
        this.worker = null;
      }
    }]);
    return WorkerThread2;
  }();

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js
  var WorkerPool = function() {
    function WorkerPool2(_ref) {
      var source = _ref.source, _ref$name = _ref.name, name = _ref$name === void 0 ? "unnamed" : _ref$name, _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency, onMessage = _ref.onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
      } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
      _classCallCheck(this, WorkerPool2);
      this.source = source;
      this.name = name;
      this.maxConcurrency = maxConcurrency;
      this.onMessage = onMessage;
      this.onDebug = onDebug;
      this.jobQueue = [];
      this.idleQueue = [];
      this.count = 0;
      this.isDestroyed = false;
      this.reuseWorkers = reuseWorkers;
    }
    _createClass(WorkerPool2, [{
      key: "destroy",
      value: function destroy() {
        this.idleQueue.forEach(function(worker) {
          return worker.destroy();
        });
        this.isDestroyed = true;
      }
    }, {
      key: "process",
      value: function process2(data, jobName) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this.jobQueue.push({
            data,
            jobName,
            resolve,
            reject
          });
          _this._startQueuedJob();
        });
      }
    }, {
      key: "_startQueuedJob",
      value: function() {
        var _startQueuedJob2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
          var worker, job;
          return import_regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (this.jobQueue.length) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return");
                case 2:
                  worker = this._getAvailableWorker();
                  if (worker) {
                    _context.next = 5;
                    break;
                  }
                  return _context.abrupt("return");
                case 5:
                  job = this.jobQueue.shift();
                  this.onDebug({
                    message: "processing",
                    worker: worker.name,
                    job: job.jobName,
                    backlog: this.jobQueue.length
                  });
                  _context.prev = 7;
                  _context.t0 = job;
                  _context.next = 11;
                  return worker.process(job.data);
                case 11:
                  _context.t1 = _context.sent;
                  _context.t0.resolve.call(_context.t0, _context.t1);
                  _context.next = 18;
                  break;
                case 15:
                  _context.prev = 15;
                  _context.t2 = _context["catch"](7);
                  job.reject(_context.t2);
                case 18:
                  _context.prev = 18;
                  this._onWorkerDone(worker);
                  return _context.finish(18);
                case 21:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[7, 15, 18, 21]]);
        }));
        function _startQueuedJob() {
          return _startQueuedJob2.apply(this, arguments);
        }
        return _startQueuedJob;
      }()
    }, {
      key: "_onWorkerDone",
      value: function _onWorkerDone(worker) {
        if (this.isDestroyed) {
          worker.destroy();
          return;
        }
        if (this.reuseWorkers) {
          this.idleQueue.push(worker);
        } else {
          worker.destroy();
          this.count--;
        }
        this._startQueuedJob();
      }
    }, {
      key: "_getAvailableWorker",
      value: function _getAvailableWorker() {
        if (this.idleQueue.length > 0) {
          return this.idleQueue.shift();
        }
        if (this.count < this.maxConcurrency) {
          this.count++;
          var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
          return new WorkerThread({
            source: this.source,
            onMessage: this.onMessage,
            name
          });
        }
        return null;
      }
    }]);
    return WorkerPool2;
  }();

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js
  var DEFAULT_MAX_CONCURRENCY = 5;
  var WorkerFarm = function() {
    _createClass(WorkerFarm2, null, [{
      key: "isSupported",
      value: function isSupported() {
        return typeof Worker !== "undefined";
      }
    }]);
    function WorkerFarm2(_ref) {
      var _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY : _ref$maxConcurrency, _ref$onMessage = _ref.onMessage, onMessage = _ref$onMessage === void 0 ? null : _ref$onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
      } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
      _classCallCheck(this, WorkerFarm2);
      this.maxConcurrency = maxConcurrency;
      this.onMessage = onMessage;
      this.onDebug = onDebug;
      this.workerPools = new Map();
      this.reuseWorkers = reuseWorkers;
    }
    _createClass(WorkerFarm2, [{
      key: "setProps",
      value: function setProps(props) {
        if ("maxConcurrency" in props) {
          this.maxConcurrency = props.maxConcurrency;
        }
        if ("onDebug" in props) {
          this.onDebug = props.onDebug;
        }
        if ("reuseWorkers" in props) {
          this.reuseWorkers = props.reuseWorkers;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.workerPools.forEach(function(workerPool) {
          return workerPool.destroy();
        });
      }
    }, {
      key: "process",
      value: function() {
        var _process = _asyncToGenerator(import_regenerator3.default.mark(function _callee(workerSource, workerName, data) {
          var workerPool;
          return import_regenerator3.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  workerPool = this._getWorkerPool(workerSource, workerName);
                  return _context.abrupt("return", workerPool.process(data));
                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function process2(_x, _x2, _x3) {
          return _process.apply(this, arguments);
        }
        return process2;
      }()
    }, {
      key: "_getWorkerPool",
      value: function _getWorkerPool(workerSource, workerName) {
        var workerPool = this.workerPools.get(workerName);
        if (!workerPool) {
          workerPool = new WorkerPool({
            source: workerSource,
            name: workerName,
            onMessage: onWorkerMessage.bind(null, this.onMessage),
            maxConcurrency: this.maxConcurrency,
            onDebug: this.onDebug,
            reuseWorkers: this.reuseWorkers
          });
          this.workerPools.set(workerName, workerPool);
        }
        return workerPool;
      }
    }]);
    return WorkerFarm2;
  }();
  function onWorkerMessage(onMessage, _ref2) {
    var worker = _ref2.worker, data = _ref2.data, resolve = _ref2.resolve, reject = _ref2.reject;
    if (onMessage) {
      onMessage({
        worker,
        data,
        resolve,
        reject
      });
      return;
    }
    switch (data.type) {
      case "done":
        resolve(data.result);
        break;
      case "error":
        reject(data.message);
        break;
      default:
    }
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function toArrayBuffer2(data) {
    if (node.toArrayBuffer) {
      data = node.toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return data.buffer;
    }
    if (typeof data === "string") {
      var text = data;
      var uint8Array = new TextEncoder().encode(text);
      return uint8Array.buffer;
    }
    if (data && _typeof(data) === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    return assert(false);
  }
  function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
      return false;
    }
    var array12 = new Uint8Array(arrayBuffer1);
    var array2 = new Uint8Array(arrayBuffer2);
    for (var i = 0; i < array12.length; ++i) {
      if (array12[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function concatenateArrayBuffers() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var sourceArrays = sources.map(function(source2) {
      return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
    });
    var byteLength = sourceArrays.reduce(function(length4, typedArray) {
      return length4 + typedArray.byteLength;
    }, 0);
    var result = new Uint8Array(byteLength);
    var offset = 0;
    var _iterator = _createForOfIteratorHelper(sourceArrays), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var sourceArray = _step.value;
        result.set(sourceArray, offset);
        offset += sourceArray.byteLength;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return result.buffer;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename) {
    for (var alias in fileAliases) {
      if (filename.startsWith(alias)) {
        var replacement = fileAliases[alias];
        filename = filename.replace(alias, replacement);
      }
    }
    if (!filename.startsWith("http://") && !filename.startsWith("https://")) {
      filename = "".concat(pathPrefix).concat(filename);
    }
    return filename;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js
  var import_regenerator4 = __toModule(require_regenerator());
  function concatenateChunksAsync(_x3) {
    return _concatenateChunksAsync.apply(this, arguments);
  }
  function _concatenateChunksAsync() {
    _concatenateChunksAsync = _asyncToGenerator(import_regenerator4.default.mark(function _callee2(asyncIterator) {
      var arrayBuffers, strings, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;
      return import_regenerator4.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              arrayBuffers = [];
              strings = [];
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context2.prev = 4;
              _iterator = _asyncIterator(asyncIterator);
            case 6:
              _context2.next = 8;
              return _iterator.next();
            case 8:
              _step = _context2.sent;
              _iteratorNormalCompletion = _step.done;
              _context2.next = 12;
              return _step.value;
            case 12:
              _value = _context2.sent;
              if (_iteratorNormalCompletion) {
                _context2.next = 19;
                break;
              }
              chunk = _value;
              if (typeof chunk === "string") {
                strings.push(chunk);
              } else {
                arrayBuffers.push(chunk);
              }
            case 16:
              _iteratorNormalCompletion = true;
              _context2.next = 6;
              break;
            case 19:
              _context2.next = 25;
              break;
            case 21:
              _context2.prev = 21;
              _context2.t0 = _context2["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context2.t0;
            case 25:
              _context2.prev = 25;
              _context2.prev = 26;
              if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
                _context2.next = 30;
                break;
              }
              _context2.next = 30;
              return _iterator["return"]();
            case 30:
              _context2.prev = 30;
              if (!_didIteratorError) {
                _context2.next = 33;
                break;
              }
              throw _iteratorError;
            case 33:
              return _context2.finish(30);
            case 34:
              return _context2.finish(25);
            case 35:
              if (!(strings.length > 0)) {
                _context2.next = 38;
                break;
              }
              assert(arrayBuffers.length === 0);
              return _context2.abrupt("return", strings.join(""));
            case 38:
              return _context2.abrupt("return", concatenateArrayBuffers.apply(void 0, arrayBuffers));
            case 39:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[4, 21, 25, 35], [26, , 30, 34]]);
    }));
    return _concatenateChunksAsync.apply(this, arguments);
  }

  // node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    var timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      var timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@probe.gl/stats/dist/esm/lib/stat.js
  var Stat = function() {
    function Stat2(name, type) {
      _classCallCheck(this, Stat2);
      this.name = name;
      this.type = type;
      this.sampleSize = 1;
      this.reset();
    }
    _createClass(Stat2, [{
      key: "setSampleSize",
      value: function setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
      }
    }, {
      key: "incrementCount",
      value: function incrementCount() {
        this.addCount(1);
        return this;
      }
    }, {
      key: "decrementCount",
      value: function decrementCount() {
        this.subtractCount(1);
        return this;
      }
    }, {
      key: "addCount",
      value: function addCount(value17) {
        this._count += value17;
        this._samples++;
        this._checkSampling();
        return this;
      }
    }, {
      key: "subtractCount",
      value: function subtractCount(value17) {
        this._count -= value17;
        this._samples++;
        this._checkSampling();
        return this;
      }
    }, {
      key: "addTime",
      value: function addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
      }
    }, {
      key: "timeStart",
      value: function timeStart() {
        this._startTime = getHiResTimestamp();
        this._timerPending = true;
        return this;
      }
    }, {
      key: "timeEnd",
      value: function timeEnd() {
        if (!this._timerPending) {
          return this;
        }
        this.addTime(getHiResTimestamp() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
      }
    }, {
      key: "getSampleAverageCount",
      value: function getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
      }
    }, {
      key: "getSampleAverageTime",
      value: function getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
      }
    }, {
      key: "getSampleHz",
      value: function getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
      }
    }, {
      key: "getAverageCount",
      value: function getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
      }
    }, {
      key: "getAverageTime",
      value: function getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
      }
    }, {
      key: "getHz",
      value: function getHz() {
        return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
      }
    }, {
      key: "_checkSampling",
      value: function _checkSampling() {
        if (this._samples === this.sampleSize) {
          this.lastSampleTime = this._time;
          this.lastSampleCount = this._count;
          this.count += this._count;
          this.time += this._time;
          this.samples += this._samples;
          this._time = 0;
          this._count = 0;
          this._samples = 0;
        }
      }
    }]);
    return Stat2;
  }();

  // node_modules/@probe.gl/stats/dist/esm/lib/stats.js
  var Stats = function() {
    function Stats2(_ref) {
      var id = _ref.id, stats = _ref.stats;
      _classCallCheck(this, Stats2);
      this.id = id;
      this.stats = {};
      this._initializeStats(stats);
      Object.seal(this);
    }
    _createClass(Stats2, [{
      key: "get",
      value: function get2(name) {
        var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
        return this._getOrCreate({
          name,
          type
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        for (var key in this.stats) {
          this.stats[key].reset();
        }
        return this;
      }
    }, {
      key: "forEach",
      value: function forEach5(fn) {
        for (var key in this.stats) {
          fn(this.stats[key]);
        }
      }
    }, {
      key: "getTable",
      value: function getTable() {
        var table = {};
        this.forEach(function(stat) {
          table[stat.name] = {
            time: stat.time || 0,
            count: stat.count || 0,
            average: stat.getAverageTime() || 0,
            hz: stat.getHz() || 0
          };
        });
        return table;
      }
    }, {
      key: "_initializeStats",
      value: function _initializeStats() {
        var _this = this;
        var stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        stats.forEach(function(stat) {
          return _this._getOrCreate(stat);
        });
      }
    }, {
      key: "_getOrCreate",
      value: function _getOrCreate(stat) {
        if (!stat || !stat.name) {
          return null;
        }
        var name = stat.name, type = stat.type;
        if (!this.stats[name]) {
          if (stat instanceof Stat) {
            this.stats[name] = stat;
          } else {
            this.stats[name] = new Stat(name, type);
          }
        }
        return this.stats[name];
      }
    }, {
      key: "size",
      get: function get2() {
        return Object.keys(this.stats).length;
      }
    }]);
    return Stats2;
  }();

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var STAT_QUEUED_REQUESTS = "Queued Requests";
  var STAT_ACTIVE_REQUESTS = "Active Requests";
  var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
  var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
  var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
  var DEFAULT_PROPS = {
    id: "request-scheduler",
    throttleRequests: true,
    maxRequests: 6
  };
  var RequestScheduler = function() {
    function RequestScheduler2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, RequestScheduler2);
      this.props = _objectSpread(_objectSpread({}, DEFAULT_PROPS), props);
      this.requestQueue = [];
      this.activeRequestCount = 0;
      this.requestMap = new Map();
      this.stats = new Stats({
        id: props.id
      });
      this.stats.get(STAT_QUEUED_REQUESTS);
      this.stats.get(STAT_ACTIVE_REQUESTS);
      this.stats.get(STAT_CANCELLED_REQUESTS);
      this.stats.get(STAT_QUEUED_REQUESTS_EVER);
      this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
      this._deferredUpdate = null;
    }
    _createClass(RequestScheduler2, [{
      key: "scheduleRequest",
      value: function scheduleRequest(handle) {
        var getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
          return 0;
        };
        if (!this.props.throttleRequests) {
          return Promise.resolve({
            done: function done() {
            }
          });
        }
        if (this.requestMap.has(handle)) {
          return this.requestMap.get(handle);
        }
        var request = {
          handle,
          getPriority
        };
        var promise = new Promise(function(resolve) {
          request.resolve = resolve;
          return request;
        });
        this.requestQueue.push(request);
        this.requestMap.set(handle, promise);
        this._issueNewRequests();
        return promise;
      }
    }, {
      key: "_issueRequest",
      value: function _issueRequest(request) {
        var _this = this;
        var handle = request.handle, resolve = request.resolve;
        var isDone = false;
        var done = function done2() {
          if (!isDone) {
            isDone = true;
            _this.requestMap["delete"](handle);
            _this.activeRequestCount--;
            _this._issueNewRequests();
          }
        };
        this.activeRequestCount++;
        return resolve ? resolve({
          done
        }) : Promise.resolve({
          done
        });
      }
    }, {
      key: "_issueNewRequests",
      value: function _issueNewRequests() {
        var _this2 = this;
        if (!this._deferredUpdate) {
          this._deferredUpdate = setTimeout(function() {
            return _this2._issueNewRequestsAsync();
          }, 0);
        }
      }
    }, {
      key: "_issueNewRequestsAsync",
      value: function _issueNewRequestsAsync() {
        this._deferredUpdate = null;
        var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
        if (freeSlots === 0) {
          return;
        }
        this._updateAllRequests();
        for (var i = 0; i < freeSlots; ++i) {
          if (this.requestQueue.length > 0) {
            var request = this.requestQueue.shift();
            this._issueRequest(request);
          }
        }
      }
    }, {
      key: "_updateAllRequests",
      value: function _updateAllRequests() {
        var requestQueue = this.requestQueue;
        for (var i = 0; i < requestQueue.length; ++i) {
          var request = requestQueue[i];
          if (!this._updateRequest(request)) {
            requestQueue.splice(i, 1);
            this.requestMap["delete"](request.handle);
            i--;
          }
        }
        requestQueue.sort(function(a, b) {
          return a.priority - b.priority;
        });
      }
    }, {
      key: "_updateRequest",
      value: function _updateRequest(request) {
        request.priority = request.getPriority(request.handle);
        if (request.priority < 0) {
          request.resolve(null);
          return false;
        }
        return true;
      }
    }]);
    return RequestScheduler2;
  }();

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray2(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
  var import_regenerator7 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
  var import_regenerator5 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
  var isBoolean = function isBoolean2(x) {
    return typeof x === "boolean";
  };
  var isFunction = function isFunction2(x) {
    return typeof x === "function";
  };
  var isObject = function isObject2(x) {
    return x !== null && _typeof(x) === "object";
  };
  var isPureObject = function isPureObject2(x) {
    return isObject(x) && x.constructor === {}.constructor;
  };
  var isIterable = function isIterable2(x) {
    return x && typeof x[Symbol.iterator] === "function";
  };
  var isAsyncIterable = function isAsyncIterable2(x) {
    return x && typeof x[Symbol.asyncIterator] === "function";
  };
  var isResponse = function isResponse2(x) {
    return typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
  };
  var isBlob = function isBlob2(x) {
    return typeof Blob !== "undefined" && x instanceof Blob;
  };
  var isReadableDOMStream = function isReadableDOMStream2(x) {
    return typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
  };
  var isBuffer = function isBuffer2(x) {
    return x && _typeof(x) === "object" && x.isBuffer;
  };
  var isReadableNodeStream = function isReadableNodeStream2(x) {
    return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
  };
  var isReadableStream = function isReadableStream2(x) {
    return isReadableDOMStream(x) || isReadableNodeStream(x);
  };

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
  var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  function parseMIMEType(mimeString) {
    if (typeof mimeString !== "string") {
      return "";
    }
    var matches3 = mimeString.match(MIME_TYPE_PATTERN);
    if (matches3) {
      return matches3[1];
    }
    return mimeString;
  }
  function parseMIMETypeFromURL(dataUrl) {
    if (typeof dataUrl !== "string") {
      return "";
    }
    var matches3 = dataUrl.match(DATA_URL_PATTERN);
    if (matches3) {
      return matches3[1];
    }
    return "";
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
  var QUERY_STRING_PATTERN = /\?.*/;
  function getResourceUrlAndType(resource) {
    if (isResponse(resource)) {
      var contentType = parseMIMEType(resource.headers.get("content-type"));
      var urlType2 = parseMIMETypeFromURL(resource.url);
      return {
        url: stripQueryString(resource.url || ""),
        type: contentType || urlType2 || null
      };
    }
    if (isBlob(resource)) {
      return {
        url: stripQueryString(resource.name || ""),
        type: resource.type || ""
      };
    }
    if (typeof resource === "string") {
      return {
        url: stripQueryString(resource),
        type: parseMIMETypeFromURL(resource)
      };
    }
    return {
      url: "",
      type: ""
    };
  }
  function getResourceContentLength(resource) {
    if (isResponse(resource)) {
      return resource.headers["content-length"] || -1;
    }
    if (isBlob(resource)) {
      return resource.size;
    }
    if (typeof resource === "string") {
      return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
      return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
      return resource.byteLength;
    }
    return -1;
  }
  function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, "");
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
  function makeResponse(_x) {
    return _makeResponse.apply(this, arguments);
  }
  function _makeResponse() {
    _makeResponse = _asyncToGenerator(import_regenerator5.default.mark(function _callee(resource) {
      var headers, contentLength, _getResourceUrlAndTyp, url, type, initialDataUrl, response;
      return import_regenerator5.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!isResponse(resource)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", resource);
            case 2:
              headers = {};
              contentLength = getResourceContentLength(resource);
              if (contentLength >= 0) {
                headers["content-length"] = String(contentLength);
              }
              _getResourceUrlAndTyp = getResourceUrlAndType(resource), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;
              if (type) {
                headers["content-type"] = type;
              }
              _context.next = 9;
              return getInitialDataUrl(resource);
            case 9:
              initialDataUrl = _context.sent;
              if (initialDataUrl) {
                headers["x-first-bytes"] = initialDataUrl;
              }
              if (typeof resource === "string") {
                resource = new TextEncoder().encode(resource);
              }
              response = new Response(resource, {
                headers
              });
              Object.defineProperty(response, "url", {
                value: url
              });
              return _context.abrupt("return", response);
            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _makeResponse.apply(this, arguments);
  }
  function checkResponse(_x2) {
    return _checkResponse.apply(this, arguments);
  }
  function _checkResponse() {
    _checkResponse = _asyncToGenerator(import_regenerator5.default.mark(function _callee2(response) {
      var message;
      return import_regenerator5.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (response.ok) {
                _context2.next = 5;
                break;
              }
              _context2.next = 3;
              return getResponseError(response);
            case 3:
              message = _context2.sent;
              throw new Error(message);
            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _checkResponse.apply(this, arguments);
  }
  function getResponseError(_x3) {
    return _getResponseError.apply(this, arguments);
  }
  function _getResponseError() {
    _getResponseError = _asyncToGenerator(import_regenerator5.default.mark(function _callee3(response) {
      var message, contentType, text;
      return import_regenerator5.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
              _context3.prev = 1;
              contentType = response.headers.get("Content-Type");
              text = response.statusText;
              if (!contentType.includes("application/json")) {
                _context3.next = 11;
                break;
              }
              _context3.t0 = text;
              _context3.t1 = " ";
              _context3.next = 9;
              return response.text();
            case 9:
              _context3.t2 = _context3.sent;
              text = _context3.t0 += _context3.t1.concat.call(_context3.t1, _context3.t2);
            case 11:
              message += text;
              message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
              _context3.next = 17;
              break;
            case 15:
              _context3.prev = 15;
              _context3.t3 = _context3["catch"](1);
            case 17:
              return _context3.abrupt("return", message);
            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[1, 15]]);
    }));
    return _getResponseError.apply(this, arguments);
  }
  function getInitialDataUrl(_x4) {
    return _getInitialDataUrl.apply(this, arguments);
  }
  function _getInitialDataUrl() {
    _getInitialDataUrl = _asyncToGenerator(import_regenerator5.default.mark(function _callee4(resource) {
      var INITIAL_DATA_LENGTH, blobSlice, slice, base64;
      return import_regenerator5.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              INITIAL_DATA_LENGTH = 5;
              if (!(typeof resource === "string")) {
                _context4.next = 3;
                break;
              }
              return _context4.abrupt("return", "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH)));
            case 3:
              if (!(resource instanceof Blob)) {
                _context4.next = 8;
                break;
              }
              blobSlice = resource.slice(0, 5);
              _context4.next = 7;
              return new Promise(function(resolve) {
                var reader = new FileReader();
                reader.onload = function(event) {
                  return resolve(event.target && event.target.result);
                };
                reader.readAsDataURL(blobSlice);
              });
            case 7:
              return _context4.abrupt("return", _context4.sent);
            case 8:
              if (!(resource instanceof ArrayBuffer)) {
                _context4.next = 12;
                break;
              }
              slice = resource.slice(0, INITIAL_DATA_LENGTH);
              base64 = arrayBufferToBase64(slice);
              return _context4.abrupt("return", "data:base64,".concat(base64));
            case 12:
              return _context4.abrupt("return", null);
            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _getInitialDataUrl.apply(this, arguments);
  }
  function arrayBufferToBase64(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    for (var i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-error-message.js
  var import_regenerator6 = __toModule(require_regenerator());
  function getErrorMessageFromResponse(_x) {
    return _getErrorMessageFromResponse.apply(this, arguments);
  }
  function _getErrorMessageFromResponse() {
    _getErrorMessageFromResponse = _asyncToGenerator(import_regenerator6.default.mark(function _callee(response) {
      var message, contentType;
      return import_regenerator6.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
              _context.prev = 1;
              contentType = response.headers.get("Content-Type");
              if (!contentType.includes("application/json")) {
                _context.next = 10;
                break;
              }
              _context.t0 = message;
              _context.next = 7;
              return response.text();
            case 7:
              message = _context.t0 += _context.sent;
              _context.next = 11;
              break;
            case 10:
              message += response.statusText;
            case 11:
              _context.next = 16;
              break;
            case 13:
              _context.prev = 13;
              _context.t1 = _context["catch"](1);
              return _context.abrupt("return", message);
            case 16:
              return _context.abrupt("return", message);
            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 13]]);
    }));
    return _getErrorMessageFromResponse.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
  function fetchFile(_x) {
    return _fetchFile.apply(this, arguments);
  }
  function _fetchFile() {
    _fetchFile = _asyncToGenerator(import_regenerator7.default.mark(function _callee(url) {
      var options, response, _args = arguments;
      return import_regenerator7.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
              if (!(typeof url !== "string")) {
                _context.next = 5;
                break;
              }
              _context.next = 4;
              return makeResponse(url);
            case 4:
              return _context.abrupt("return", _context.sent);
            case 5:
              url = resolvePath(url);
              _context.next = 8;
              return fetch(url, options);
            case 8:
              response = _context.sent;
              if (!(!response.ok && options["throws"])) {
                _context.next = 15;
                break;
              }
              _context.t0 = Error;
              _context.next = 13;
              return getErrorMessageFromResponse(response);
            case 13:
              _context.t1 = _context.sent;
              throw new _context.t0(_context.t1);
            case 15:
              return _context.abrupt("return", response);
            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _fetchFile.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
  var NullLog = function() {
    function NullLog2() {
      _classCallCheck(this, NullLog2);
    }
    _createClass(NullLog2, [{
      key: "log",
      value: function log3() {
        return function(_) {
        };
      }
    }, {
      key: "info",
      value: function info() {
        return function(_) {
        };
      }
    }, {
      key: "warn",
      value: function warn() {
        return function(_) {
        };
      }
    }, {
      key: "error",
      value: function error2() {
        return function(_) {
        };
      }
    }]);
    return NullLog2;
  }();
  var ConsoleLog = function() {
    function ConsoleLog2() {
      _classCallCheck(this, ConsoleLog2);
      this.console = console;
    }
    _createClass(ConsoleLog2, [{
      key: "log",
      value: function log3() {
        var _this$console$log;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_this$console$log = this.console.log).bind.apply(_this$console$log, [this.console].concat(args));
      }
    }, {
      key: "info",
      value: function info() {
        var _this$console$info;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return (_this$console$info = this.console.info).bind.apply(_this$console$info, [this.console].concat(args));
      }
    }, {
      key: "warn",
      value: function warn() {
        var _this$console$warn;
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return (_this$console$warn = this.console.warn).bind.apply(_this$console$warn, [this.console].concat(args));
      }
    }, {
      key: "error",
      value: function error2() {
        var _this$console$error;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return (_this$console$error = this.console.error).bind.apply(_this$console$error, [this.console].concat(args));
      }
    }]);
    return ConsoleLog2;
  }();

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray3(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray3(o, minLen);
  }
  function _arrayLikeToArray3(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var DEFAULT_LOADER_OPTIONS = {
    baseUri: "",
    fetch: null,
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    log: new ConsoleLog(),
    metadata: false,
    transforms: [],
    reuseWorkers: true
  };
  var DEPRECATED_LOADER_OPTIONS = {
    dataType: "(no longer used)",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };
  var getGlobalLoaderState = function getGlobalLoaderState2() {
    global_.loaders = global_.loaders || {};
    var loaders = global_.loaders;
    loaders._state = loaders._state || {};
    return loaders._state;
  };
  var getGlobalLoaderOptions = function getGlobalLoaderOptions2() {
    var state = getGlobalLoaderState();
    state.globalOptions = state.globalOptions || _objectSpread2({}, DEFAULT_LOADER_OPTIONS);
    return state.globalOptions;
  };
  function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
  }
  function getFetchFunction(options, context) {
    var globalOptions = getGlobalLoaderOptions();
    var fetch2 = options.fetch || globalOptions.fetch;
    if (typeof fetch2 === "function") {
      return fetch2;
    }
    if (isObject(fetch2)) {
      return function(url) {
        return fetchFile(url, fetch2);
      };
    }
    if (context && context.fetch) {
      return context.fetch;
    }
    return function(url) {
      return fetchFile(url, options);
    };
  }
  function validateOptions(options, loaders) {
    var log3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : console;
    validateOptionsObject(options, null, log3, DEFAULT_LOADER_OPTIONS, DEPRECATED_LOADER_OPTIONS, loaders);
    var _iterator = _createForOfIteratorHelper2(loaders), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var loader = _step.value;
        var idOptions = options && options[loader.id] || {};
        var loaderOptions = loader.options && loader.options[loader.id] || {};
        var deprecatedOptions = loader.defaultOptions && loader.defaultOptions[loader.id] || {};
        validateOptionsObject(idOptions, loader.id, log3, loaderOptions, deprecatedOptions, loaders);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function validateOptionsObject(options, id, log3, defaultOptions, deprecatedOptions, loaders) {
    var loaderName = id || "Top level";
    var prefix = id ? "".concat(id, ".") : "";
    for (var key in options) {
      var isSubOptions = !id && isObject(options[key]);
      if (!(key in defaultOptions)) {
        if (key in deprecatedOptions) {
          log3.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' deprecated, use '").concat(deprecatedOptions[key], "'"));
        } else if (!isSubOptions) {
          var suggestion = findSimilarOption(key, loaders);
          log3.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion));
        }
      }
    }
  }
  function findSimilarOption(optionKey, loaders) {
    var lowerCaseOptionKey = optionKey.toLowerCase();
    var bestSuggestion = "";
    var _iterator2 = _createForOfIteratorHelper2(loaders), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var loader = _step2.value;
        for (var key in loader.options) {
          if (optionKey === key) {
            return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
          }
          var lowerCaseKey = key.toLowerCase();
          var isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
          if (isPartialMatch) {
            bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return bestSuggestion;
  }
  function normalizeOptionsInternal(loader, options, url) {
    var loaderDefaultOptions = loader.options || {};
    var mergedOptions = _objectSpread2({}, loaderDefaultOptions);
    if (mergedOptions.log === null) {
      mergedOptions.log = new NullLog();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    addUrlOptions(mergedOptions, url);
    return mergedOptions;
  }
  function mergeNestedFields(mergedOptions, options) {
    for (var key in options) {
      if (key in options) {
        var value17 = options[key];
        if (isPureObject(value17) && isPureObject(mergedOptions[key])) {
          mergedOptions[key] = _objectSpread2(_objectSpread2({}, mergedOptions[key]), options[key]);
        } else {
          mergedOptions[key] = options[key];
        }
      }
    }
  }
  function addUrlOptions(options, url) {
    if (url && !options.baseUri) {
      options.baseUri = url;
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
  function ownKeys3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function isLoaderObject(loader) {
    if (!loader) {
      return false;
    }
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    var hasParser = loader.parseTextSync || loader.parseSync || loader.parse || loader.parseStream || loader.parseInBatches;
    var loaderOptions = loader.options && loader.options[loader.id];
    hasParser = hasParser || loaderOptions && loaderOptions.workerUrl;
    return hasParser;
  }
  function normalizeLoader(loader) {
    assert(loader, "null loader");
    assert(isLoaderObject(loader), "invalid loader");
    var options;
    if (Array.isArray(loader)) {
      options = loader[1];
      loader = loader[0];
      loader = _objectSpread3(_objectSpread3({}, loader), {}, {
        options: _objectSpread3(_objectSpread3({}, loader.options), options)
      });
    }
    if (loader.extension) {
      loader.extensions = loader.extensions || loader.extension;
      delete loader.extension;
    }
    if (!Array.isArray(loader.extensions)) {
      loader.extensions = [loader.extensions];
    }
    assert(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);
    if (loader.parseTextSync || loader.parseText) {
      loader.text = true;
    }
    if (!loader.text) {
      loader.binary = true;
    }
    return loader;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
  function _createForOfIteratorHelper3(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray4(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray4(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray4(o, minLen);
  }
  function _arrayLikeToArray4(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var getGlobalLoaderRegistry = function getGlobalLoaderRegistry2() {
    var state = getGlobalLoaderState();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
  };
  function registerLoaders(loaders) {
    var loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    var _iterator = _createForOfIteratorHelper3(loaders), _step;
    try {
      var _loop = function _loop2() {
        var loader = _step.value;
        var normalizedLoader = normalizeLoader(loader);
        if (!loaderRegistry.find(function(registeredLoader) {
          return normalizedLoader === registeredLoader;
        })) {
          loaderRegistry.unshift(normalizedLoader);
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
  var import_regenerator15 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
  var import_regenerator12 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/string-iterator.js
  var import_regenerator8 = __toModule(require_regenerator());
  var _marked = import_regenerator8.default.mark(makeStringIterator);
  function makeStringIterator(string) {
    var options, _options$chunkSize, chunkSize, offset, textEncoder, chunkLength, chunk, _args = arguments;
    return import_regenerator8.default.wrap(function makeStringIterator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
            _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;
            offset = 0;
            textEncoder = new TextEncoder();
          case 4:
            if (!(offset < string.length)) {
              _context.next = 12;
              break;
            }
            chunkLength = Math.min(string.length - offset, chunkSize);
            chunk = string.slice(offset, offset + chunkLength);
            offset += chunkLength;
            _context.next = 10;
            return textEncoder.encode(chunk);
          case 10:
            _context.next = 4;
            break;
          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }

  // node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/array-buffer-iterator.js
  var import_regenerator9 = __toModule(require_regenerator());
  var _marked2 = import_regenerator9.default.mark(makeArrayBufferIterator);
  function makeArrayBufferIterator(arrayBuffer2) {
    var options, _options$chunkSize, chunkSize, byteOffset, chunkByteLength, chunk, sourceArray, chunkArray, _args = arguments;
    return import_regenerator9.default.wrap(function makeArrayBufferIterator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
            _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;
            byteOffset = 0;
          case 3:
            if (!(byteOffset < arrayBuffer2.byteLength)) {
              _context.next = 14;
              break;
            }
            chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
            chunk = new ArrayBuffer(chunkByteLength);
            sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
            chunkArray = new Uint8Array(chunk);
            chunkArray.set(sourceArray);
            byteOffset += chunkByteLength;
            _context.next = 12;
            return chunk;
          case 12:
            _context.next = 3;
            break;
          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _marked2);
  }

  // node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/blob-iterator.js
  var import_regenerator10 = __toModule(require_regenerator());
  var DEFAULT_CHUNK_SIZE = 1024 * 1024;
  function makeBlobIterator(_x) {
    return _makeBlobIterator.apply(this, arguments);
  }
  function _makeBlobIterator() {
    _makeBlobIterator = _wrapAsyncGenerator(import_regenerator10.default.mark(function _callee(file) {
      var options, chunkSize, offset, end, chunk, _args = arguments;
      return import_regenerator10.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
              chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;
              offset = 0;
            case 3:
              if (!(offset < file.size)) {
                _context.next = 13;
                break;
              }
              end = offset + chunkSize;
              _context.next = 7;
              return _awaitAsyncGenerator(readFileSlice(file, offset, end));
            case 7:
              chunk = _context.sent;
              offset = end;
              _context.next = 11;
              return chunk;
            case 11:
              _context.next = 3;
              break;
            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _makeBlobIterator.apply(this, arguments);
  }
  function readFileSlice(_x2, _x3, _x4) {
    return _readFileSlice.apply(this, arguments);
  }
  function _readFileSlice() {
    _readFileSlice = _asyncToGenerator(import_regenerator10.default.mark(function _callee2(file, offset, end) {
      return import_regenerator10.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return new Promise(function(resolve, reject) {
                var slice = file.slice(offset, end);
                var fileReader = new FileReader();
                fileReader.onload = function(event) {
                  return resolve(event.target && event.target.result);
                };
                fileReader.onerror = function(error2) {
                  return reject(error2);
                };
                fileReader.readAsArrayBuffer(slice);
              });
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _readFileSlice.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/stream-iterator.js
  var import_regenerator11 = __toModule(require_regenerator());
  function makeStreamIterator(stream) {
    if (isBrowser || nodeVersion >= 10) {
      if (typeof stream[Symbol.asyncIterator] === "function") {
        return makeToArrayBufferIterator(stream);
      }
      if (typeof stream.getIterator === "function") {
        return stream.getIterator();
      }
    }
    return isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
  }
  function makeToArrayBufferIterator(_x) {
    return _makeToArrayBufferIterator.apply(this, arguments);
  }
  function _makeToArrayBufferIterator() {
    _makeToArrayBufferIterator = _wrapAsyncGenerator(import_regenerator11.default.mark(function _callee(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;
      return import_regenerator11.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 2;
              _iterator = _asyncIterator(asyncIterator);
            case 4:
              _context.next = 6;
              return _awaitAsyncGenerator(_iterator.next());
            case 6:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 10;
              return _awaitAsyncGenerator(_step.value);
            case 10:
              _value = _context.sent;
              if (_iteratorNormalCompletion) {
                _context.next = 18;
                break;
              }
              chunk = _value;
              _context.next = 15;
              return toArrayBuffer2(chunk);
            case 15:
              _iteratorNormalCompletion = true;
              _context.next = 4;
              break;
            case 18:
              _context.next = 24;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](2);
              _didIteratorError = true;
              _iteratorError = _context.t0;
            case 24:
              _context.prev = 24;
              _context.prev = 25;
              if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
                _context.next = 29;
                break;
              }
              _context.next = 29;
              return _awaitAsyncGenerator(_iterator["return"]());
            case 29:
              _context.prev = 29;
              if (!_didIteratorError) {
                _context.next = 32;
                break;
              }
              throw _iteratorError;
            case 32:
              return _context.finish(29);
            case 33:
              return _context.finish(24);
            case 34:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[2, 20, 24, 34], [25, , 29, 33]]);
    }));
    return _makeToArrayBufferIterator.apply(this, arguments);
  }
  function makeBrowserStreamIterator(_x2) {
    return _makeBrowserStreamIterator.apply(this, arguments);
  }
  function _makeBrowserStreamIterator() {
    _makeBrowserStreamIterator = _wrapAsyncGenerator(import_regenerator11.default.mark(function _callee2(stream) {
      var reader, _yield$_awaitAsyncGen, done, value17;
      return import_regenerator11.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reader = stream.getReader();
              _context2.prev = 1;
            case 2:
              if (false) {
                _context2.next = 14;
                break;
              }
              _context2.next = 5;
              return _awaitAsyncGenerator(reader.read());
            case 5:
              _yield$_awaitAsyncGen = _context2.sent;
              done = _yield$_awaitAsyncGen.done;
              value17 = _yield$_awaitAsyncGen.value;
              if (!done) {
                _context2.next = 10;
                break;
              }
              return _context2.abrupt("return");
            case 10:
              _context2.next = 12;
              return toArrayBuffer2(value17);
            case 12:
              _context2.next = 2;
              break;
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](1);
              reader.releaseLock();
            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 16]]);
    }));
    return _makeBrowserStreamIterator.apply(this, arguments);
  }
  function makeNodeStreamIterator(_x3) {
    return _makeNodeStreamIterator.apply(this, arguments);
  }
  function _makeNodeStreamIterator() {
    _makeNodeStreamIterator = _wrapAsyncGenerator(import_regenerator11.default.mark(function _callee3(stream) {
      var data;
      return import_regenerator11.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _awaitAsyncGenerator(stream);
            case 2:
              stream = _context3.sent;
            case 3:
              if (false) {
                _context3.next = 15;
                break;
              }
              data = stream.read();
              if (!(data !== null)) {
                _context3.next = 9;
                break;
              }
              _context3.next = 8;
              return toArrayBuffer2(data);
            case 8:
              return _context3.abrupt("continue", 3);
            case 9:
              if (!stream._readableState.ended) {
                _context3.next = 11;
                break;
              }
              return _context3.abrupt("return");
            case 11:
              _context3.next = 13;
              return _awaitAsyncGenerator(onceReadable(stream));
            case 13:
              _context3.next = 3;
              break;
            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _makeNodeStreamIterator.apply(this, arguments);
  }
  function onceReadable(_x4) {
    return _onceReadable.apply(this, arguments);
  }
  function _onceReadable() {
    _onceReadable = _asyncToGenerator(import_regenerator11.default.mark(function _callee4(stream) {
      return import_regenerator11.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", new Promise(function(resolve) {
                stream.once("readable", resolve);
              }));
            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _onceReadable.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/make-iterator.js
  function makeIterator(data) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof data === "string") {
      return makeStringIterator(data, options);
    }
    if (data instanceof ArrayBuffer) {
      return makeArrayBufferIterator(data, options);
    }
    if (isBlob(data)) {
      return makeBlobIterator(data, options);
    }
    if (isReadableStream(data)) {
      return makeStreamIterator(data);
    }
    if (isResponse(data)) {
      return makeStreamIterator(data.body);
    }
    return assert(false);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
  var ERR_DATA = "Cannot convert supplied data type";
  function getArrayBufferOrStringFromDataSync(data, loader) {
    if (loader.text && typeof data === "string") {
      return data;
    }
    if (data instanceof ArrayBuffer) {
      var arrayBuffer2 = data;
      if (loader.text && !loader.binary) {
        var textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(arrayBuffer2);
      }
      return arrayBuffer2;
    }
    if (ArrayBuffer.isView(data) || isBuffer(data)) {
      if (loader.text && !loader.binary) {
        var _textDecoder = new TextDecoder("utf8");
        return _textDecoder.decode(data);
      }
      var _arrayBuffer = data.buffer;
      var byteLength = data.byteLength || data.length;
      if (data.byteOffset !== 0 || byteLength !== _arrayBuffer.byteLength) {
        _arrayBuffer = _arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
      }
      return _arrayBuffer;
    }
    throw new Error(ERR_DATA);
  }
  function getArrayBufferOrStringFromData(_x, _x2) {
    return _getArrayBufferOrStringFromData.apply(this, arguments);
  }
  function _getArrayBufferOrStringFromData() {
    _getArrayBufferOrStringFromData = _asyncToGenerator(import_regenerator12.default.mark(function _callee(data, loader) {
      var isArrayBuffer, response;
      return import_regenerator12.default.wrap(function _callee$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
              if (!(typeof data === "string" || isArrayBuffer)) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader));
            case 3:
              if (!isBlob(data)) {
                _context3.next = 7;
                break;
              }
              _context3.next = 6;
              return makeResponse(data);
            case 6:
              data = _context3.sent;
            case 7:
              if (!isResponse(data)) {
                _context3.next = 21;
                break;
              }
              response = data;
              _context3.next = 11;
              return checkResponse(response);
            case 11:
              if (!loader.binary) {
                _context3.next = 17;
                break;
              }
              _context3.next = 14;
              return response.arrayBuffer();
            case 14:
              _context3.t0 = _context3.sent;
              _context3.next = 20;
              break;
            case 17:
              _context3.next = 19;
              return response.text();
            case 19:
              _context3.t0 = _context3.sent;
            case 20:
              return _context3.abrupt("return", _context3.t0);
            case 21:
              if (isReadableStream(data)) {
                data = makeIterator(data);
              }
              if (!(isIterable(data) || isAsyncIterable(data))) {
                _context3.next = 24;
                break;
              }
              return _context3.abrupt("return", concatenateChunksAsync(data));
            case 24:
              throw new Error(ERR_DATA);
            case 25:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee);
    }));
    return _getArrayBufferOrStringFromData.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/context-utils.js
  function ownKeys4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys4(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys4(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function getLoaderContext(context, options) {
    var previousContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (previousContext) {
      return previousContext;
    }
    context = _objectSpread4({
      fetch: getFetchFunction(options || {}, context)
    }, context);
    if (!Array.isArray(context.loaders)) {
      context.loaders = null;
    }
    return context;
  }
  function getLoaders(loaders, context) {
    if (!context && loaders && !Array.isArray(loaders)) {
      return loaders;
    }
    var candidateLoaders;
    if (loaders) {
      candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
      var contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
      candidateLoaders = candidateLoaders ? [].concat(_toConsumableArray(candidateLoaders), _toConsumableArray(contextLoaders)) : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/parse-with-worker.js
  var import_regenerator13 = __toModule(require_regenerator());
  var VERSION2 = true ? "2.3.13" : "latest";
  function canParseWithWorker(loader, data, options, context) {
    if (!WorkerFarm.isSupported()) {
      return false;
    }
    var loaderOptions = options && options[loader.id];
    if (options.worker === "local" && loaderOptions && loaderOptions.localWorkerUrl || options.worker && loaderOptions && loaderOptions.workerUrl) {
      return loader.useWorker ? loader.useWorker(options) : true;
    }
    return false;
  }
  function parseWithWorker(loader, data, options, context) {
    var _ref = options || {}, worker = _ref.worker;
    var loaderOptions = options && options[loader.id] || {};
    var workerUrl = worker === "local" ? loaderOptions.localWorkerUrl : loaderOptions.workerUrl;
    var workerSource = "url(".concat(workerUrl, ")");
    var workerName = loader.name;
    var workerFarm = getWorkerFarm(options);
    options = JSON.parse(JSON.stringify(options));
    var warning = loader.version !== VERSION2 ? "(core version ".concat(VERSION2, ")") : "";
    return workerFarm.process(workerSource, "".concat(workerName, "-worker@").concat(loader.version).concat(warning), {
      arraybuffer: toArrayBuffer2(data),
      options,
      source: "loaders.gl@".concat(VERSION2),
      type: "parse"
    });
  }
  var _workerFarm = null;
  function getWorkerFarm() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var props = {};
    if (options.maxConcurrency) {
      props.maxConcurrency = options.maxConcurrency;
    }
    if (options.onDebug) {
      props.onDebug = options.onDebug;
    }
    if ("reuseWorkers" in options) {
      props.reuseWorkers = options.reuseWorkers;
    }
    if (!_workerFarm) {
      _workerFarm = new WorkerFarm({
        onMessage: onWorkerMessage2
      });
    }
    _workerFarm.setProps(props);
    return _workerFarm;
  }
  function onWorkerMessage2(_x) {
    return _onWorkerMessage.apply(this, arguments);
  }
  function _onWorkerMessage() {
    _onWorkerMessage = _asyncToGenerator(import_regenerator13.default.mark(function _callee(_ref2) {
      var worker, data, resolve, reject, result;
      return import_regenerator13.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              worker = _ref2.worker, data = _ref2.data, resolve = _ref2.resolve, reject = _ref2.reject;
              _context.t0 = data.type;
              _context.next = _context.t0 === "done" ? 4 : _context.t0 === "parse" ? 6 : _context.t0 === "error" ? 17 : 19;
              break;
            case 4:
              resolve(data.result);
              return _context.abrupt("break", 19);
            case 6:
              _context.prev = 6;
              _context.next = 9;
              return parse(data.arraybuffer, data.options, data.url);
            case 9:
              result = _context.sent;
              worker.postMessage({
                type: "parse-done",
                id: data.id,
                result
              }, getTransferList(result));
              _context.next = 16;
              break;
            case 13:
              _context.prev = 13;
              _context.t1 = _context["catch"](6);
              worker.postMessage({
                type: "parse-error",
                id: data.id,
                message: _context.t1.message
              });
            case 16:
              return _context.abrupt("break", 19);
            case 17:
              reject(data.message);
              return _context.abrupt("break", 19);
            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 13]]);
    }));
    return _onWorkerMessage.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
  var import_regenerator14 = __toModule(require_regenerator());
  function ownKeys5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys5(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys5(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper4(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray5(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray5(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray5(o, minLen);
  }
  function _arrayLikeToArray5(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var EXT_PATTERN = /\.([^.]+)$/;
  function selectLoader(_x) {
    return _selectLoader.apply(this, arguments);
  }
  function _selectLoader() {
    _selectLoader = _asyncToGenerator(import_regenerator14.default.mark(function _callee(data) {
      var loaders, options, context, loader, _args = arguments;
      return import_regenerator14.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              loaders = _args.length > 1 && _args[1] !== void 0 ? _args[1] : [];
              options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
              context = _args.length > 3 && _args[3] !== void 0 ? _args[3] : {};
              loader = selectLoaderSync(data, loaders, _objectSpread5(_objectSpread5({}, options), {}, {
                nothrow: true
              }), context);
              if (!loader) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", loader);
            case 6:
              if (!isBlob(data)) {
                _context.next = 11;
                break;
              }
              _context.next = 9;
              return readFileSlice(data, 0, 10);
            case 9:
              data = _context.sent;
              loader = selectLoaderSync(data, loaders, options, context);
            case 11:
              if (!(!loader && !options.nothrow)) {
                _context.next = 13;
                break;
              }
              throw new Error(getNoValidLoaderMessage(data));
            case 13:
              return _context.abrupt("return", loader);
            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _selectLoader.apply(this, arguments);
  }
  function selectLoaderSync(data) {
    var loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var context = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (loaders && !Array.isArray(loaders)) {
      return normalizeLoader(loaders);
    }
    loaders = [].concat(_toConsumableArray(loaders || []), _toConsumableArray(getRegisteredLoaders()));
    normalizeLoaders(loaders);
    var _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;
    var loader = findLoaderByUrl(loaders, url || context.url);
    loader = loader || findLoaderByContentType(loaders, type);
    loader = loader || findLoaderByExamingInitialData(loaders, data);
    if (!loader && !options.nothrow) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function getNoValidLoaderMessage(data) {
    var _getResourceUrlAndTyp2 = getResourceUrlAndType(data), url = _getResourceUrlAndTyp2.url, type = _getResourceUrlAndTyp2.type;
    var message = "No valid loader found";
    if (data) {
      message += ' data: "'.concat(getFirstCharacters(data), '", contentType: "').concat(type, '"');
    }
    if (url) {
      message += " url: ".concat(url);
    }
    return message;
  }
  function normalizeLoaders(loaders) {
    var _iterator = _createForOfIteratorHelper4(loaders), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var loader = _step.value;
        normalizeLoader(loader);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function findLoaderByUrl(loaders, url) {
    var match = url && url.match(EXT_PATTERN);
    var extension = match && match[1];
    return extension && findLoaderByExtension(loaders, extension);
  }
  function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    var _iterator2 = _createForOfIteratorHelper4(loaders), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var loader = _step2.value;
        var _iterator3 = _createForOfIteratorHelper4(loader.extensions), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var loaderExtension = _step3.value;
            if (loaderExtension.toLowerCase() === extension) {
              return loader;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return null;
  }
  function findLoaderByContentType(loaders, mimeType) {
    var _iterator4 = _createForOfIteratorHelper4(loaders), _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        var loader = _step4.value;
        if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
          return loader;
        }
        if (mimeType === "application/x.".concat(loader.id)) {
          return loader;
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    return null;
  }
  function findLoaderByExamingInitialData(loaders, data) {
    if (!data) {
      return null;
    }
    var _iterator5 = _createForOfIteratorHelper4(loaders), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var loader = _step5.value;
        if (typeof data === "string") {
          if (testDataAgainstText(data, loader)) {
            return loader;
          }
        } else if (ArrayBuffer.isView(data)) {
          if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
            return loader;
          }
        } else if (data instanceof ArrayBuffer) {
          var byteOffset = 0;
          if (testDataAgainstBinary(data, byteOffset, loader)) {
            return loader;
          }
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    return null;
  }
  function testDataAgainstText(data, loader) {
    return loader.testText && loader.testText(data);
  }
  function testDataAgainstBinary(data, byteOffset, loader) {
    var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some(function(test) {
      return testBinary(data, byteOffset, loader, test);
    });
  }
  function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
      return compareArrayBuffers(test, data, test.byteLength);
    }
    switch (_typeof(test)) {
      case "function":
        return test(data, loader);
      case "string":
        var magic = getMagicString(data, byteOffset, test.length);
        return test === magic;
      default:
        return false;
    }
  }
  function getFirstCharacters(data) {
    var length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length4);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length4);
    } else if (data instanceof ArrayBuffer) {
      var byteOffset = 0;
      return getMagicString(data, byteOffset, length4);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length4) {
    if (arrayBuffer2.byteLength < byteOffset + length4) {
      return "";
    }
    var dataView = new DataView(arrayBuffer2);
    var magic = "";
    for (var i = 0; i < length4; i++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
    }
    return magic;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
  function parse(_x, _x2, _x3, _x4) {
    return _parse.apply(this, arguments);
  }
  function _parse() {
    _parse = _asyncToGenerator(import_regenerator15.default.mark(function _callee(data, loaders, options, context) {
      var _getResourceUrlAndTyp, url, candidateLoaders, loader;
      return import_regenerator15.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              assert(!context || typeof context !== "string", "parse no longer accepts final url");
              if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
                context = options;
                options = loaders;
                loaders = null;
              }
              _context.next = 4;
              return data;
            case 4:
              data = _context.sent;
              options = options || {};
              _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;
              candidateLoaders = getLoaders(loaders, context);
              _context.next = 10;
              return selectLoader(data, candidateLoaders, options);
            case 10:
              loader = _context.sent;
              if (loader) {
                _context.next = 13;
                break;
              }
              return _context.abrupt("return", null);
            case 13:
              options = normalizeOptions(options, loader, candidateLoaders, url);
              context = getLoaderContext({
                url,
                parse,
                loaders: candidateLoaders
              }, options, context);
              _context.next = 17;
              return parseWithLoader(loader, data, options, context);
            case 17:
              return _context.abrupt("return", _context.sent);
            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _parse.apply(this, arguments);
  }
  function parseWithLoader(_x5, _x6, _x7, _x8) {
    return _parseWithLoader.apply(this, arguments);
  }
  function _parseWithLoader() {
    _parseWithLoader = _asyncToGenerator(import_regenerator15.default.mark(function _callee2(loader, data, options, context) {
      return import_regenerator15.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              validateLoaderVersion(loader);
              _context2.next = 3;
              return getArrayBufferOrStringFromData(data, loader);
            case 3:
              data = _context2.sent;
              if (!(loader.parseTextSync && typeof data === "string")) {
                _context2.next = 7;
                break;
              }
              options.dataType = "text";
              return _context2.abrupt("return", loader.parseTextSync(data, options, context, loader));
            case 7:
              if (!canParseWithWorker(loader, data, options, context)) {
                _context2.next = 11;
                break;
              }
              _context2.next = 10;
              return parseWithWorker(loader, data, options, context);
            case 10:
              return _context2.abrupt("return", _context2.sent);
            case 11:
              if (!(loader.parseText && typeof data === "string")) {
                _context2.next = 15;
                break;
              }
              _context2.next = 14;
              return loader.parseText(data, options, context, loader);
            case 14:
              return _context2.abrupt("return", _context2.sent);
            case 15:
              if (!loader.parse) {
                _context2.next = 19;
                break;
              }
              _context2.next = 18;
              return loader.parse(data, options, context, loader);
            case 18:
              return _context2.abrupt("return", _context2.sent);
            case 19:
              assert(!loader.parseSync);
              return _context2.abrupt("return", assert(false));
            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _parseWithLoader.apply(this, arguments);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
  var import_regenerator16 = __toModule(require_regenerator());
  function load(_x, _x2, _x3) {
    return _load.apply(this, arguments);
  }
  function _load() {
    _load = _asyncToGenerator(import_regenerator16.default.mark(function _callee(url, loaders, options) {
      var fetch2, data;
      return import_regenerator16.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
                options = loaders;
                loaders = null;
              }
              fetch2 = getFetchFunction(options || {});
              data = url;
              if (!(typeof url === "string")) {
                _context.next = 9;
                break;
              }
              _context.next = 6;
              return fetch2(url);
            case 6:
              data = _context.sent;
              _context.next = 10;
              break;
            case 9:
              url = null;
            case 10:
              if (!isBlob(url)) {
                _context.next = 15;
                break;
              }
              _context.next = 13;
              return fetch2(url);
            case 13:
              data = _context.sent;
              url = null;
            case 15:
              _context.next = 17;
              return parse(data, loaders, options);
            case 17:
              return _context.abrupt("return", _context.sent);
            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _load.apply(this, arguments);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  var import_regenerator19 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global;
  var window_2 = globals2.window || globals2.self || globals2.global;
  var global_2 = globals2.global || globals2.self || globals2.window;
  var document_2 = globals2.document || {};
  var isBrowser2 = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
  var isWorker2 = typeof importScripts === "function";
  var matches2 = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
  var _parseImageNode = global_2._parseImageNode;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
  var DATA_SUPPORTED = isBrowser2 ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      case "html":
        return IMAGE_SUPPORTED;
      case "ndarray":
        return DATA_SUPPORTED;
      default:
        throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    var format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        if (context) {
          canvas.width = image.width;
          canvas.height = image.height;
          context.drawImage(image, 0, 0);
          return context.getImageData(0, 0, image.width, image.height);
        }
      default:
        return assert2(false);
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && _typeof(image) === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  var import_regenerator17 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      var textDecoder = new TextDecoder();
      var xmlText = textDecoder.decode(arrayBuffer2);
      var src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
      return src;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  function parseToImage(_x, _x2, _x3) {
    return _parseToImage.apply(this, arguments);
  }
  function _parseToImage() {
    _parseToImage = _asyncToGenerator(import_regenerator17.default.mark(function _callee(arrayBuffer2, options, url) {
      var blobOrDataUrl, URL2, objectUrl;
      return import_regenerator17.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
              URL2 = self.URL || self.webkitURL;
              objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
              _context.prev = 3;
              _context.next = 6;
              return loadToImage(objectUrl || blobOrDataUrl, options);
            case 6:
              return _context.abrupt("return", _context.sent);
            case 7:
              _context.prev = 7;
              if (objectUrl) {
                URL2.revokeObjectURL(objectUrl);
              }
              return _context.finish(7);
            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, , 7, 10]]);
    }));
    return _parseToImage.apply(this, arguments);
  }
  function loadToImage(_x4, _x5) {
    return _loadToImage.apply(this, arguments);
  }
  function _loadToImage() {
    _loadToImage = _asyncToGenerator(import_regenerator17.default.mark(function _callee2(url, options) {
      var image;
      return import_regenerator17.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              image = new Image();
              image.src = url;
              if (!(options.image && options.image.decode && image.decode)) {
                _context2.next = 6;
                break;
              }
              _context2.next = 5;
              return image.decode();
            case 5:
              return _context2.abrupt("return", image);
            case 6:
              _context2.next = 8;
              return new Promise(function(resolve, reject) {
                try {
                  image.onload = function() {
                    return resolve(image);
                  };
                  image.onerror = function(err) {
                    return reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
                  };
                } catch (error2) {
                  reject(error2);
                }
              });
            case 8:
              return _context2.abrupt("return", _context2.sent);
            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _loadToImage.apply(this, arguments);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
  var import_regenerator18 = __toModule(require_regenerator());
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  function parseToImageBitmap(_x, _x2, _x3) {
    return _parseToImageBitmap.apply(this, arguments);
  }
  function _parseToImageBitmap() {
    _parseToImageBitmap = _asyncToGenerator(import_regenerator18.default.mark(function _callee(arrayBuffer2, options, url) {
      var blob, image, imagebitmapOptions;
      return import_regenerator18.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!isSVG(url)) {
                _context.next = 7;
                break;
              }
              _context.next = 3;
              return parseToImage(arrayBuffer2, options, url);
            case 3:
              image = _context.sent;
              blob = image;
              _context.next = 8;
              break;
            case 7:
              blob = getBlob(arrayBuffer2, url);
            case 8:
              imagebitmapOptions = options && options.imagebitmap;
              _context.next = 11;
              return safeCreateImageBitmap(blob, imagebitmapOptions);
            case 11:
              return _context.abrupt("return", _context.sent);
            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _parseToImageBitmap.apply(this, arguments);
  }
  function safeCreateImageBitmap(_x4) {
    return _safeCreateImageBitmap.apply(this, arguments);
  }
  function _safeCreateImageBitmap() {
    _safeCreateImageBitmap = _asyncToGenerator(import_regenerator18.default.mark(function _callee2(blob) {
      var imagebitmapOptions, _args2 = arguments;
      return import_regenerator18.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              imagebitmapOptions = _args2.length > 1 && _args2[1] !== void 0 ? _args2[1] : null;
              if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
                imagebitmapOptions = null;
              }
              if (!imagebitmapOptions) {
                _context2.next = 13;
                break;
              }
              _context2.prev = 3;
              _context2.next = 6;
              return createImageBitmap(blob, imagebitmapOptions);
            case 6:
              return _context2.abrupt("return", _context2.sent);
            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](3);
              console.warn(_context2.t0);
              imagebitmapOptionsSupported = false;
            case 13:
              _context2.next = 15;
              return createImageBitmap(blob);
            case 15:
              return _context2.abrupt("return", _context2.sent);
            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[3, 9]]);
    }));
    return _safeCreateImageBitmap.apply(this, arguments);
  }
  function isEmptyObject(object) {
    for (var key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    var dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
  }
  function getPngMetadata(binaryData) {
    var dataView = toDataView(binaryData);
    var isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    var dataView = toDataView(binaryData);
    var isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    var dataView = toDataView(binaryData);
    var isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    var dataView = toDataView(binaryData);
    var isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    var _getJpegMarkers = getJpegMarkers(), tableMarkers = _getJpegMarkers.tableMarkers, sofMarkers = _getJpegMarkers.sofMarkers;
    var i = 2;
    while (i + 9 < dataView.byteLength) {
      var marker = dataView.getUint16(i, BIG_ENDIAN);
      if (sofMarkers.has(marker)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i + 5, BIG_ENDIAN),
          width: dataView.getUint16(i + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker)) {
        return null;
      }
      i += 2;
      i += dataView.getUint16(i, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    var tableMarkers = new Set([65499, 65476, 65484, 65501, 65534]);
    for (var i = 65504; i < 65520; ++i) {
      tableMarkers.add(i);
    }
    var sofMarkers = new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
  function parseToNodeImage(arrayBuffer2, options) {
    var _ref = getBinaryImageMetadata(arrayBuffer2) || {}, mimeType = _ref.mimeType;
    var _parseImageNode2 = global_2._parseImageNode;
    assert2(_parseImageNode2);
    return _parseImageNode2(arrayBuffer2, mimeType, options);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  function parseImage(_x, _x2, _x3) {
    return _parseImage.apply(this, arguments);
  }
  function _parseImage() {
    _parseImage = _asyncToGenerator(import_regenerator19.default.mark(function _callee(arrayBuffer2, options, context) {
      var imageOptions, imageType, _ref, url, loadType, image;
      return import_regenerator19.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = options || {};
              imageOptions = options.image || {};
              imageType = imageOptions.type || "auto";
              _ref = context || {}, url = _ref.url;
              loadType = getLoadableImageType(imageType);
              _context.t0 = loadType;
              _context.next = _context.t0 === "imagebitmap" ? 8 : _context.t0 === "image" ? 12 : _context.t0 === "data" ? 16 : 20;
              break;
            case 8:
              _context.next = 10;
              return parseToImageBitmap(arrayBuffer2, options, url);
            case 10:
              image = _context.sent;
              return _context.abrupt("break", 21);
            case 12:
              _context.next = 14;
              return parseToImage(arrayBuffer2, options, url);
            case 14:
              image = _context.sent;
              return _context.abrupt("break", 21);
            case 16:
              _context.next = 18;
              return parseToNodeImage(arrayBuffer2, options);
            case 18:
              image = _context.sent;
              return _context.abrupt("break", 21);
            case 20:
              assert2(false);
            case 21:
              if (imageType === "data") {
                image = getImageData(image);
              }
              return _context.abrupt("return", image);
            case 23:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _parseImage.apply(this, arguments);
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // node_modules/@loaders.gl/images/dist/esm/image-loader.js
  var VERSION3 = true ? "2.3.13" : "latest";
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var ImageLoader = {
    id: "image",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [function(arrayBuffer2) {
      return Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)));
    }],
    options: {
      image: {
        type: "auto",
        decode: true
      }
    }
  };
  var image_loader_default = ImageLoader;

  // node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js
  var import_regenerator22 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js
  function ownKeys6(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys6(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys6(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function generateUrl(getUrl, options, urlOptions) {
    var url = getUrl;
    if (typeof getUrl === "function") {
      url = getUrl(_objectSpread6(_objectSpread6({}, options), urlOptions));
    }
    assert2(typeof url === "string");
    var baseUrl = options.baseUrl;
    if (baseUrl) {
      url = baseUrl[baseUrl.length - 1] === "/" ? "".concat(baseUrl).concat(url) : "".concat(baseUrl, "/").concat(url);
    }
    return resolvePath(url);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js
  var import_regenerator21 = __toModule(require_regenerator());

  // node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js
  var import_regenerator20 = __toModule(require_regenerator());
  var isObject3 = function isObject4(value17) {
    return value17 && _typeof(value17) === "object";
  };
  function asyncDeepMap(_x, _x2) {
    return _asyncDeepMap.apply(this, arguments);
  }
  function _asyncDeepMap() {
    _asyncDeepMap = _asyncToGenerator(import_regenerator20.default.mark(function _callee(tree, func) {
      var options, _args = arguments;
      return import_regenerator20.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
              _context.next = 3;
              return mapSubtree(tree, func, options);
            case 3:
              return _context.abrupt("return", _context.sent);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _asyncDeepMap.apply(this, arguments);
  }
  function mapSubtree(_x3, _x4, _x5) {
    return _mapSubtree.apply(this, arguments);
  }
  function _mapSubtree() {
    _mapSubtree = _asyncToGenerator(import_regenerator20.default.mark(function _callee2(object, func, options) {
      var url;
      return import_regenerator20.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!Array.isArray(object)) {
                _context2.next = 4;
                break;
              }
              _context2.next = 3;
              return mapArray(object, func, options);
            case 3:
              return _context2.abrupt("return", _context2.sent);
            case 4:
              if (!isObject3(object)) {
                _context2.next = 8;
                break;
              }
              _context2.next = 7;
              return mapObject(object, func, options);
            case 7:
              return _context2.abrupt("return", _context2.sent);
            case 8:
              url = object;
              _context2.next = 11;
              return func(url, options);
            case 11:
              return _context2.abrupt("return", _context2.sent);
            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _mapSubtree.apply(this, arguments);
  }
  function mapObject(_x6, _x7, _x8) {
    return _mapObject.apply(this, arguments);
  }
  function _mapObject() {
    _mapObject = _asyncToGenerator(import_regenerator20.default.mark(function _callee3(object, func, options) {
      var promises, values, _loop, key;
      return import_regenerator20.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              promises = [];
              values = {};
              _loop = function _loop2(key2) {
                var url = object[key2];
                var promise = mapSubtree(url, func, options).then(function(value17) {
                  values[key2] = value17;
                });
                promises.push(promise);
              };
              for (key in object) {
                _loop(key);
              }
              _context3.next = 6;
              return Promise.all(promises);
            case 6:
              return _context3.abrupt("return", values);
            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _mapObject.apply(this, arguments);
  }
  function mapArray(_x9, _x10) {
    return _mapArray.apply(this, arguments);
  }
  function _mapArray() {
    _mapArray = _asyncToGenerator(import_regenerator20.default.mark(function _callee4(urlArray, func) {
      var options, promises, _args4 = arguments;
      return import_regenerator20.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              options = _args4.length > 2 && _args4[2] !== void 0 ? _args4[2] : {};
              promises = urlArray.map(function(url) {
                return mapSubtree(url, func, options);
              });
              _context4.next = 4;
              return Promise.all(promises);
            case 4:
              return _context4.abrupt("return", _context4.sent);
            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _mapArray.apply(this, arguments);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js
  function deepLoad(_x, _x2, _x3) {
    return _deepLoad.apply(this, arguments);
  }
  function _deepLoad() {
    _deepLoad = _asyncToGenerator(import_regenerator21.default.mark(function _callee(urlTree, load2, options) {
      return import_regenerator21.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return asyncDeepMap(urlTree, function(url) {
                return shallowLoad(url, load2, options);
              });
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _deepLoad.apply(this, arguments);
  }
  function shallowLoad(_x4, _x5, _x6) {
    return _shallowLoad.apply(this, arguments);
  }
  function _shallowLoad() {
    _shallowLoad = _asyncToGenerator(import_regenerator21.default.mark(function _callee2(url, load2, options) {
      var response, arrayBuffer2;
      return import_regenerator21.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return fetch(url, options.fetch);
            case 2:
              response = _context2.sent;
              _context2.next = 5;
              return response.arrayBuffer();
            case 5:
              arrayBuffer2 = _context2.sent;
              _context2.next = 8;
              return load2(arrayBuffer2, options);
            case 8:
              return _context2.abrupt("return", _context2.sent);
            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _shallowLoad.apply(this, arguments);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js
  function ownKeys7(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys7(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys7(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function loadImage(_x) {
    return _loadImage.apply(this, arguments);
  }
  function _loadImage() {
    _loadImage = _asyncToGenerator(import_regenerator22.default.mark(function _callee(getUrl) {
      var options, imageUrls, _args = arguments;
      return import_regenerator22.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
              _context.next = 3;
              return getImageUrls(getUrl, options);
            case 3:
              imageUrls = _context.sent;
              _context.next = 6;
              return deepLoad(imageUrls, parseImage, options);
            case 6:
              return _context.abrupt("return", _context.sent);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _loadImage.apply(this, arguments);
  }
  function getImageUrls(_x2, _x3) {
    return _getImageUrls.apply(this, arguments);
  }
  function _getImageUrls() {
    _getImageUrls = _asyncToGenerator(import_regenerator22.default.mark(function _callee2(getUrl, options) {
      var urlOptions, mipLevels, _args2 = arguments;
      return import_regenerator22.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              urlOptions = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : {};
              mipLevels = options && options.image && options.image.mipLevels || 0;
              if (!(mipLevels !== 0)) {
                _context2.next = 8;
                break;
              }
              _context2.next = 5;
              return getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions);
            case 5:
              _context2.t0 = _context2.sent;
              _context2.next = 9;
              break;
            case 8:
              _context2.t0 = generateUrl(getUrl, options, urlOptions);
            case 9:
              return _context2.abrupt("return", _context2.t0);
            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _getImageUrls.apply(this, arguments);
  }
  function getMipmappedImageUrls(_x4, _x5, _x6, _x7) {
    return _getMipmappedImageUrls.apply(this, arguments);
  }
  function _getMipmappedImageUrls() {
    _getMipmappedImageUrls = _asyncToGenerator(import_regenerator22.default.mark(function _callee3(getUrl, mipLevels, options, urlOptions) {
      var urls, url, image, _getImageSize, width, height, mipLevel, _url;
      return import_regenerator22.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              urls = [];
              if (!(mipLevels === "auto")) {
                _context3.next = 9;
                break;
              }
              url = generateUrl(getUrl, options, _objectSpread7(_objectSpread7({}, urlOptions), {}, {
                lod: 0
              }));
              _context3.next = 5;
              return shallowLoad(url, parseImage, options);
            case 5:
              image = _context3.sent;
              _getImageSize = getImageData(image), width = _getImageSize.width, height = _getImageSize.height;
              mipLevels = getMipLevels({
                width,
                height
              });
              urls.push(url);
            case 9:
              assert2(mipLevels > 0);
              for (mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
                _url = generateUrl(getUrl, options, _objectSpread7(_objectSpread7({}, urlOptions), {}, {
                  lod: mipLevel
                }));
                urls.push(_url);
              }
              return _context3.abrupt("return", urls);
            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _getMipmappedImageUrls.apply(this, arguments);
  }
  function getMipLevels(_ref) {
    var width = _ref.width, height = _ref.height;
    return 1 + Math.floor(Math.log2(Math.max(width, height)));
  }

  // node_modules/@deck.gl/core/dist/esm/lib/init.js
  var import_env = __toModule(require_env2());

  // node_modules/probe.gl/dist/esm/env/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && _typeof(window.process) === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && _typeof(process.versions) === "object" && Boolean(process.versions.electron)) {
      return true;
    }
    var realUserAgent = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    var userAgent2 = mockUserAgent || realUserAgent;
    if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // node_modules/probe.gl/dist/esm/env/is-browser.js
  function isBrowser3() {
    var isNode = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // node_modules/probe.gl/dist/esm/env/globals.js
  var globals3 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document,
    process: (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process
  };
  var self_3 = globals3.self || globals3.window || globals3.global;
  var window_3 = globals3.window || globals3.self || globals3.global;
  var global_3 = globals3.global || globals3.self || globals3.window;
  var document_3 = globals3.document || {};
  var process_ = globals3.process || {};

  // node_modules/probe.gl/dist/esm/utils/globals.js
  var VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser4 = isBrowser3();

  // node_modules/probe.gl/dist/esm/utils/local-storage.js
  function getStorage(type) {
    try {
      var storage = window[type];
      var x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = function() {
    function LocalStorage2(id, defaultSettings) {
      var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _classCallCheck(this, LocalStorage2);
      this.storage = getStorage(type);
      this.id = id;
      this.config = {};
      Object.assign(this.config, defaultSettings);
      this._loadConfiguration();
    }
    _createClass(LocalStorage2, [{
      key: "getConfiguration",
      value: function getConfiguration() {
        return this.config;
      }
    }, {
      key: "setConfiguration",
      value: function setConfiguration(configuration) {
        this.config = {};
        return this.updateConfiguration(configuration);
      }
    }, {
      key: "updateConfiguration",
      value: function updateConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
          var serialized = JSON.stringify(this.config);
          this.storage.setItem(this.id, serialized);
        }
        return this;
      }
    }, {
      key: "_loadConfiguration",
      value: function _loadConfiguration() {
        var configuration = {};
        if (this.storage) {
          var serializedConfiguration = this.storage.getItem(this.id);
          configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
      }
    }]);
    return LocalStorage2;
  }();

  // node_modules/probe.gl/dist/esm/utils/formatters.js
  function formatTime(ms) {
    var formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    var length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    var padLength = Math.max(length4 - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message, scale5) {
    var maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    var imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale5 = Math.min(scale5, maxWidth / image.width);
    }
    var width = image.width * scale5;
    var height = image.height * scale5;
    var style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // node_modules/probe.gl/dist/esm/utils/color.js
  var COLOR = {
    BLACK: 30,
    RED: 31,
    GREEN: 32,
    YELLOW: 33,
    BLUE: 34,
    MAGENTA: 35,
    CYAN: 36,
    WHITE: 37,
    BRIGHT_BLACK: 90,
    BRIGHT_RED: 91,
    BRIGHT_GREEN: 92,
    BRIGHT_YELLOW: 93,
    BRIGHT_BLUE: 94,
    BRIGHT_MAGENTA: 95,
    BRIGHT_CYAN: 96,
    BRIGHT_WHITE: 97
  };
  function getColor(color) {
    return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
  }
  function addColor(string, color, background) {
    if (!isBrowser4 && typeof string === "string") {
      if (color) {
        color = getColor(color);
        string = "[".concat(color, "m").concat(string, "[39m");
      }
      if (background) {
        color = getColor(background);
        string = "[".concat(background + 10, "m").concat(string, "[49m");
      }
    }
    return string;
  }

  // node_modules/probe.gl/dist/esm/utils/autobind.js
  function _createForOfIteratorHelper5(o) {
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (o = _unsupportedIterableToArray6(o))) {
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var it, normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray6(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray6(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray6(o, minLen);
  }
  function _arrayLikeToArray6(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function autobind(obj) {
    var predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    var proto = Object.getPrototypeOf(obj);
    var propNames = Object.getOwnPropertyNames(proto);
    var _iterator = _createForOfIteratorHelper5(propNames), _step;
    try {
      var _loop = function _loop2() {
        var key = _step.value;
        if (typeof obj[key] === "function") {
          if (!predefined.find(function(name) {
            return key === name;
          })) {
            obj[key] = obj[key].bind(obj);
          }
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  // node_modules/probe.gl/dist/esm/utils/assert.js
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    var timestamp;
    if (isBrowser4 && window_3.performance) {
      timestamp = window_3.performance.now();
    } else if (process_.hrtime) {
      var timeParts = process_.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/probe.gl/dist/esm/lib/log.js
  var originalConsole = {
    debug: isBrowser4 ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  function getTableHeader(table) {
    for (var key in table) {
      for (var title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }
  var Log = function() {
    function Log2() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, id = _ref.id;
      _classCallCheck(this, Log2);
      this.id = id;
      this.VERSION = VERSION4;
      this._startTs = getHiResTimestamp2();
      this._deltaTs = getHiResTimestamp2();
      this.LOG_THROTTLE_TIMEOUT = 0;
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
      this.userData = {};
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    _createClass(Log2, [{
      key: "isEnabled",
      value: function isEnabled3() {
        return this._storage.config.enabled;
      }
    }, {
      key: "getLevel",
      value: function getLevel() {
        return this._storage.config.level;
      }
    }, {
      key: "getTotal",
      value: function getTotal() {
        return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
      }
    }, {
      key: "getDelta",
      value: function getDelta() {
        return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
      }
    }, {
      key: "getPriority",
      value: function getPriority() {
        return this.level;
      }
    }, {
      key: "enable",
      value: function enable4() {
        var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this._storage.updateConfiguration({
          enabled
        });
        return this;
      }
    }, {
      key: "setLevel",
      value: function setLevel(level) {
        this._storage.updateConfiguration({
          level
        });
        return this;
      }
    }, {
      key: "assert",
      value: function assert10(condition, message) {
        assert3(condition, message);
      }
    }, {
      key: "warn",
      value: function warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
      }
    }, {
      key: "error",
      value: function error2(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
      }
    }, {
      key: "deprecated",
      value: function deprecated2(oldUsage, newUsage) {
        return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
      }
    }, {
      key: "removed",
      value: function removed(oldUsage, newUsage) {
        return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
      }
    }, {
      key: "probe",
      value: function probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
          time: true,
          once: true
        });
      }
    }, {
      key: "log",
      value: function log3(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
      }
    }, {
      key: "info",
      value: function info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
      }
    }, {
      key: "once",
      value: function once(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
      }
    }, {
      key: "table",
      value: function table(logLevel, _table, columns) {
        if (_table) {
          return this._getLogFunction(logLevel, _table, console.table || noop, columns && [columns], {
            tag: getTableHeader(_table)
          });
        }
        return noop;
      }
    }, {
      key: "image",
      value: function image(_ref2) {
        var logLevel = _ref2.logLevel, priority = _ref2.priority, _image = _ref2.image, _ref2$message = _ref2.message, message = _ref2$message === void 0 ? "" : _ref2$message, _ref2$scale = _ref2.scale, scale5 = _ref2$scale === void 0 ? 1 : _ref2$scale;
        if (!this._shouldLog(logLevel || priority)) {
          return noop;
        }
        return isBrowser4 ? logImageInBrowser({
          image: _image,
          message,
          scale: scale5
        }) : logImageInNode({
          image: _image,
          message,
          scale: scale5
        });
      }
    }, {
      key: "settings",
      value: function settings() {
        if (console.table) {
          console.table(this._storage.config);
        } else {
          console.log(this._storage.config);
        }
      }
    }, {
      key: "get",
      value: function get2(setting) {
        return this._storage.config[setting];
      }
    }, {
      key: "set",
      value: function set2(setting, value17) {
        this._storage.updateConfiguration(_defineProperty({}, setting, value17));
      }
    }, {
      key: "time",
      value: function time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
      }
    }, {
      key: "timeEnd",
      value: function timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
      }
    }, {
      key: "timeStamp",
      value: function timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
      }
    }, {
      key: "group",
      value: function group(logLevel, message) {
        var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          collapsed: false
        };
        opts = normalizeArguments({
          logLevel,
          message,
          opts
        });
        var _opts = opts, collapsed = _opts.collapsed;
        opts.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(opts);
      }
    }, {
      key: "groupCollapsed",
      value: function groupCollapsed(logLevel, message) {
        var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.group(logLevel, message, Object.assign({}, opts, {
          collapsed: true
        }));
      }
    }, {
      key: "groupEnd",
      value: function groupEnd(logLevel) {
        return this._getLogFunction(logLevel, "", console.groupEnd || noop);
      }
    }, {
      key: "withGroup",
      value: function withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
          func();
        } finally {
          this.groupEnd(logLevel)();
        }
      }
    }, {
      key: "trace",
      value: function trace() {
        if (console.trace) {
          console.trace();
        }
      }
    }, {
      key: "_shouldLog",
      value: function _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
      }
    }, {
      key: "_getLogFunction",
      value: function _getLogFunction(logLevel, message, method) {
        var args = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
        var opts = arguments.length > 4 ? arguments[4] : void 0;
        if (this._shouldLog(logLevel)) {
          var _method;
          opts = normalizeArguments({
            logLevel,
            message,
            args,
            opts
          });
          method = method || opts.method;
          assert3(method);
          opts.total = this.getTotal();
          opts.delta = this.getDelta();
          this._deltaTs = getHiResTimestamp2();
          var tag = opts.tag || opts.message;
          if (opts.once) {
            if (!cache[tag]) {
              cache[tag] = getHiResTimestamp2();
            } else {
              return noop;
            }
          }
          message = decorateMessage(this.id, opts.message, opts);
          return (_method = method).bind.apply(_method, [console, message].concat(_toConsumableArray(opts.args)));
        }
        return noop;
      }
    }, {
      key: "level",
      set: function set2(newLevel) {
        this.setLevel(newLevel);
      },
      get: function get2() {
        return this.getLevel();
      }
    }, {
      key: "priority",
      set: function set2(newPriority) {
        this.level = newPriority;
      },
      get: function get2() {
        return this.level;
      }
    }]);
    return Log2;
  }();
  Log.VERSION = VERSION4;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    var resolvedLevel;
    switch (_typeof(logLevel)) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert3(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    var logLevel = opts.logLevel, message = opts.message;
    opts.logLevel = normalizeLogLevel(logLevel);
    var args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    opts.args = args;
    switch (_typeof(logLevel)) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    var messageType = _typeof(opts.message);
    assert3(messageType === "string" || messageType === "object");
    return Object.assign(opts, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      var time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref3) {
    var image = _ref3.image, _ref3$message = _ref3.message, message = _ref3$message === void 0 ? "" : _ref3$message, _ref3$scale = _ref3.scale, scale5 = _ref3$scale === void 0 ? 1 : _ref3$scale;
    var asciify = null;
    try {
      asciify = module.require("asciify-image");
    } catch (error2) {
    }
    if (asciify) {
      return function() {
        return asciify(image, {
          fit: "box",
          width: "".concat(Math.round(80 * scale5), "%")
        }).then(function(data) {
          return console.log(data);
        });
      };
    }
    return noop;
  }
  function logImageInBrowser(_ref4) {
    var image = _ref4.image, _ref4$message = _ref4.message, message = _ref4$message === void 0 ? "" : _ref4$message, _ref4$scale = _ref4.scale, scale5 = _ref4$scale === void 0 ? 1 : _ref4$scale;
    if (typeof image === "string") {
      var img = new Image();
      img.onload = function() {
        var _console;
        var args = formatImage(img, message, scale5);
        (_console = console).log.apply(_console, _toConsumableArray(args));
      };
      img.src = image;
      return noop;
    }
    var element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      var _console2;
      (_console2 = console).log.apply(_console2, _toConsumableArray(formatImage(image, message, scale5)));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      var _img = new Image();
      _img.onload = function() {
        var _console3;
        return (_console3 = console).log.apply(_console3, _toConsumableArray(formatImage(_img, message, scale5)));
      };
      _img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }

  // node_modules/probe.gl/dist/esm/env/get-browser.js
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser3()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    var navigator_ = typeof navigator !== "undefined" ? navigator : {};
    var userAgent2 = mockUserAgent || navigator_.userAgent || "";
    if (userAgent2.indexOf("Edge") > -1) {
      return "Edge";
    }
    var isMSIE = userAgent2.indexOf("MSIE ") !== -1;
    var isTrident = userAgent2.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) {
      return "IE";
    }
    if (window_3.chrome) {
      return "Chrome";
    }
    if (window_3.safari) {
      return "Safari";
    }
    if (window_3.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // node_modules/probe.gl/dist/esm/index.js
  var esm_default = new Log({
    id: "probe.gl"
  });

  // node_modules/@deck.gl/core/dist/esm/utils/log.js
  var log_default = new Log({
    id: "deck"
  });

  // node_modules/@deck.gl/core/dist/esm/debug/loggers.js
  function _createForOfIteratorHelper6(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray7(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray7(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray7(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray7(o, minLen);
  }
  function _arrayLikeToArray7(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var logState = {
    attributeUpdateMessages: []
  };
  var LOG_LEVEL_MAJOR_UPDATE = 1;
  var LOG_LEVEL_MINOR_UPDATE = 2;
  var LOG_LEVEL_UPDATE_DETAIL = 3;
  var LOG_LEVEL_INFO = 4;
  var LOG_LEVEL_DRAW = 2;
  var getLoggers = function getLoggers2(log3) {
    return {
      "layer.changeFlag": function layerChangeFlag(layer, key, flags) {
        log3.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
      },
      "layer.initialize": function layerInitialize(layer) {
        log3.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
      },
      "layer.update": function layerUpdate(layer, needsUpdate) {
        if (needsUpdate) {
          var flags = layer.getChangeFlags();
          log3.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter(function(key) {
            return flags[key];
          }).join(", ")))();
        } else {
          log3.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
        }
      },
      "layer.matched": function layerMatched(layer, changed) {
        if (changed) {
          log3.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
        }
      },
      "layer.finalize": function layerFinalize(layer) {
        log3.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
      },
      "compositeLayer.renderLayers": function compositeLayerRenderLayers(layer, updated, subLayers) {
        if (updated) {
          log3.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
        } else {
          log3.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
        }
      },
      "layerManager.setLayers": function layerManagerSetLayers(layerManager, updated, layers) {
        if (updated) {
          log3.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
        }
      },
      "layerManager.activateViewport": function layerManagerActivateViewport(layerManager, viewport3) {
        log3.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport3)();
      },
      "attributeManager.invalidate": function attributeManagerInvalidate(attributeManager, trigger, attributeNames) {
        log3.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
      },
      "attributeManager.updateStart": function attributeManagerUpdateStart(attributeManager) {
        logState.attributeUpdateMessages.length = 0;
        logState.attributeManagerUpdateStart = Date.now();
      },
      "attributeManager.updateEnd": function attributeManagerUpdateEnd(attributeManager, numInstances) {
        var timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
        log3.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
        var _iterator = _createForOfIteratorHelper6(logState.attributeUpdateMessages), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var updateMessage = _step.value;
            log3.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        log3.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
      },
      "attribute.updateStart": function attributeUpdateStart(attribute) {
        logState.attributeUpdateStart = Date.now();
      },
      "attribute.allocate": function attributeAllocate(attribute, numInstances) {
        var message = "".concat(attribute.id, " allocated ").concat(numInstances);
        logState.attributeUpdateMessages.push(message);
      },
      "attribute.updateEnd": function attributeUpdateEnd(attribute, numInstances) {
        var timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
        var message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
        logState.attributeUpdateMessages.push(message);
      },
      "deckRenderer.renderLayers": function deckRendererRenderLayers(deckRenderer, renderStats, opts) {
        var pass = opts.pass, redrawReason = opts.redrawReason, stats = opts.stats;
        var _iterator2 = _createForOfIteratorHelper6(renderStats), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var status = _step2.value;
            var totalCount = status.totalCount, visibleCount = status.visibleCount, compositeCount = status.compositeCount, pickableCount = status.pickableCount;
            var primitiveCount = totalCount - compositeCount;
            var hiddenCount = primitiveCount - visibleCount;
            log3.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
            if (stats) {
              stats.get("Redraw Layers").add(visibleCount);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    };
  };

  // node_modules/@deck.gl/core/dist/esm/debug/index.js
  var loggers = {};
  if (true) {
    loggers = getLoggers(log_default);
  }
  function register(handlers) {
    loggers = handlers;
  }
  function debug(eventType) {
    if (log_default.level > 0 && loggers[eventType]) {
      var _loggers$eventType;
      (_loggers$eventType = loggers[eventType]).call.apply(_loggers$eventType, arguments);
    }
  }

  // node_modules/@deck.gl/core/dist/esm/utils/json-loader.js
  function isJSON(text) {
    var firstChar = text[0];
    var lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
  }
  var json_loader_default = {
    name: "JSON",
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json", "application/geo+json"],
    testText: isJSON,
    parseTextSync: JSON.parse
  };

  // node_modules/@deck.gl/core/dist/esm/lib/init.js
  var version = true ? "8.4.17" : import_env.global.DECK_VERSION || "untranspiled source";
  var existingVersion = import_env.global.deck && import_env.global.deck.VERSION;
  if (existingVersion && existingVersion !== version) {
    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
  }
  if (!existingVersion) {
    if (true) {
      log_default.log(0, "deck.gl ".concat(version, " - set deck.log.level=1 (or higher) to trace attribute updates"))();
    }
    import_env.global.deck = Object.assign(import_env.global.deck || {}, {
      VERSION: version,
      version,
      log: log_default,
      _registerLoggers: register
    });
    registerLoaders([json_loader_default, [image_loader_default, {
      imagebitmap: {
        premultiplyAlpha: "none"
      }
    }]]);
  }
  var init_default = import_env.global.deck;

  // node_modules/@luma.gl/gltools/dist/esm/utils/log.js
  var log = new Log({
    id: "luma.gl"
  });

  // node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
  function assert4(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert4(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert4(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
  var import_env2 = __toModule(require_env2());
  var glErrorShadow = {};
  function error(msg) {
    if (import_env2.global.console && import_env2.global.console.error) {
      import_env2.global.console.error(msg);
    }
  }
  function log2(msg) {
    if (import_env2.global.console && import_env2.global.console.log) {
      import_env2.global.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    var f = gl.getError;
    gl.getError = function getError() {
      var err;
      do {
        err = f.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    var gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (var n = 0; n < this.attribs.length; n++) {
      var attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    var self2 = this;
    this.gl = gl;
    wrapGLError(gl);
    var original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
        if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
          return null;
        }
        return self2.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
      var vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      var attrib = vao.attribs[index];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
      var vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      var attrib = vao.attribs[index];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
      switch (target) {
        case 34962:
          self2.currentArrayBuffer = buffer;
          break;
        case 34963:
          self2.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib2(index, pname) {
      var vao = self2.currentVertexArrayObject;
      var attrib = vao.attribs[index];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
      var vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      var attrib = vao.attribs[indx];
      attrib.buffer = self2.currentArrayBuffer;
      attrib.size = size;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", function() {
        log2("OESVertexArrayObject emulation library context restored");
        self2.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    var contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    var gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    var arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    var gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    var original = this.original;
    var oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    var newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    var currentBinding = this.currentArrayBuffer;
    var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (var n = 0; n <= maxAttrib; n++) {
      var attrib = newVAO.attribs[n];
      var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n);
        } else {
          original.disableVertexAttribArray.call(gl, n);
        }
      }
      if (attrib.enabled) {
        var bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    var original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      var list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    var original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name) {
      var ext = original_getExtension.call(this, name);
      if (ext) {
        return ext;
      }
      if (name !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
  var _WEBGL_PARAMETERS;
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = function getWebGL2ValueOrZero2(gl) {
    return !isWebGL2(gl) ? 0 : void 0;
  };
  var WEBGL_PARAMETERS = (_WEBGL_PARAMETERS = {}, _defineProperty(_WEBGL_PARAMETERS, 3074, function(gl) {
    return !isWebGL2(gl) ? 36064 : void 0;
  }), _defineProperty(_WEBGL_PARAMETERS, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, function(gl) {
    return !isWebGL2(gl) ? GL_DONT_CARE : void 0;
  }), _defineProperty(_WEBGL_PARAMETERS, 35977, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 32937, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, GL_GPU_DISJOINT_EXT, function(gl, getParameter) {
    var ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  }), _defineProperty(_WEBGL_PARAMETERS, GL_UNMASKED_VENDOR_WEBGL, function(gl, getParameter) {
    var ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
  }), _defineProperty(_WEBGL_PARAMETERS, GL_UNMASKED_RENDERER_WEBGL, function(gl, getParameter) {
    var ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
  }), _defineProperty(_WEBGL_PARAMETERS, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, function(gl, getParameter) {
    var ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  }), _defineProperty(_WEBGL_PARAMETERS, 32883, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35071, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 37447, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 36063, function(gl, getParameter) {
    if (!isWebGL2(gl)) {
      var ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return void 0;
  }), _defineProperty(_WEBGL_PARAMETERS, 35379, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35374, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35377, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 34852, function(gl) {
    if (!isWebGL2(gl)) {
      var ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return void 0;
  }), _defineProperty(_WEBGL_PARAMETERS, 36203, function(gl) {
    return gl.getExtension(OES_element_index) ? 2147483647 : 65535;
  }), _defineProperty(_WEBGL_PARAMETERS, 33001, function(gl) {
    return gl.getExtension(OES_element_index) ? 16777216 : 65535;
  }), _defineProperty(_WEBGL_PARAMETERS, 33e3, function(gl) {
    return 16777216;
  }), _defineProperty(_WEBGL_PARAMETERS, 37157, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35373, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35657, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 36183, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 37137, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 34045, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35978, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35979, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35968, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35376, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35375, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35659, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 37154, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35371, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35658, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35076, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35077, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, 35380, getWebGL2ValueOrZero), _WEBGL_PARAMETERS);
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    var limit = WEBGL_PARAMETERS[pname];
    var value17 = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    var result = value17 !== void 0 ? value17 : originalGetParameter(pname);
    return result;
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
  var _WEBGL2_CONTEXT_POLYF;
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = (_WEBGL2_CONTEXT_POLYF = {}, _defineProperty(_WEBGL2_CONTEXT_POLYF, OES_vertex_array_object, {
    meta: {
      suffix: "OES"
    },
    createVertexArray: function createVertexArray() {
      assert4(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: function deleteVertexArray() {
    },
    bindVertexArray: function bindVertexArray() {
    },
    isVertexArray: function isVertexArray() {
      return false;
    }
  }), _defineProperty(_WEBGL2_CONTEXT_POLYF, ANGLE_instanced_arrays, {
    meta: {
      suffix: "ANGLE"
    },
    vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
      assert4(divisor === 0, "WebGL instanced rendering not supported");
    },
    drawElementsInstanced: function drawElementsInstanced() {
    },
    drawArraysInstanced: function drawArraysInstanced() {
    }
  }), _defineProperty(_WEBGL2_CONTEXT_POLYF, WEBGL_draw_buffers2, {
    meta: {
      suffix: "WEBGL"
    },
    drawBuffers: function drawBuffers() {
      assert4(false);
    }
  }), _defineProperty(_WEBGL2_CONTEXT_POLYF, EXT_disjoint_timer_query2, {
    meta: {
      suffix: "EXT"
    },
    createQuery: function createQuery() {
      assert4(false);
    },
    deleteQuery: function deleteQuery() {
      assert4(false);
    },
    beginQuery: function beginQuery() {
      assert4(false);
    },
    endQuery: function endQuery() {
    },
    getQuery: function getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryParameter: function getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: function getQueryObject() {
    }
  }), _WEBGL2_CONTEXT_POLYF);
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: function readBuffer(gl, originalFunc, attachment) {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: function getVertexAttrib(gl, originalFunc, location, pname) {
      var _getExtensionData = getExtensionData(gl, ANGLE_instanced_arrays), webgl2 = _getExtensionData.webgl2, ext = _getExtensionData.ext;
      var result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location, pname);
    },
    getProgramParameter: function getProgramParameter(gl, originalFunc, program, pname) {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: function getInternalformatParameter(gl, originalFunc, target, format, pname) {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter: function getTexParameter(gl, originalFunc, target, pname) {
      switch (pname) {
        case 34046:
          var extensions = gl.luma.extensions;
          var ext = extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target, pname);
    },
    getParameter: getParameterPolyfill,
    hint: function hint(gl, originalFunc, pname, value17) {
      return originalFunc(pname, value17);
    }
  };

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
  function _createForOfIteratorHelper7(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray8(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray8(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray8(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray8(o, minLen);
  }
  function _arrayLikeToArray8(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function polyfillContext(gl) {
    gl.luma = gl.luma || {};
    var luma = gl.luma;
    if (!luma.polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: luma,
        target2: gl
      });
      luma.polyfilled = true;
    }
    return gl;
  }
  var global_4 = typeof global !== "undefined" ? global : window;
  global_4.polyfillContext = polyfillContext;
  function initializeExtensions(gl) {
    gl.luma.extensions = {};
    var EXTENSIONS2 = gl.getSupportedExtensions() || [];
    var _iterator = _createForOfIteratorHelper7(EXTENSIONS2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var extension = _step.value;
        gl.luma[extension] = gl.getExtension(extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function installOverrides(gl, _ref) {
    var target = _ref.target, target2 = _ref.target2;
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach(function(key) {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        var originalFunc = gl[key] ? gl[key].bind(gl) : function() {
        };
        var polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    });
  }
  function installPolyfills(gl, polyfills) {
    var _iterator2 = _createForOfIteratorHelper7(Object.getOwnPropertyNames(polyfills)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var extension = _step2.value;
        if (extension !== "overrides") {
          polyfillExtension(gl, {
            extension,
            target: gl.luma,
            target2: gl
          });
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  function polyfillExtension(gl, _ref2) {
    var extension = _ref2.extension, target = _ref2.target, target2 = _ref2.target2;
    var defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert4(defaults);
    var _defaults$meta = defaults.meta, meta = _defaults$meta === void 0 ? {} : _defaults$meta;
    var _meta$suffix = meta.suffix, suffix = _meta$suffix === void 0 ? "" : _meta$suffix;
    var ext = gl.getExtension(extension);
    var _loop = function _loop2() {
      var key = _Object$keys[_i];
      var extKey = "".concat(key).concat(suffix);
      var polyfill = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill = function polyfill2() {
          return ext[extKey].apply(ext, arguments);
        };
      } else if (typeof defaults[key] === "function") {
        polyfill = defaults[key].bind(target);
      }
      if (polyfill) {
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    };
    for (var _i = 0, _Object$keys = Object.keys(defaults); _i < _Object$keys.length; _i++) {
      _loop();
    }
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
  var _GL_PARAMETER_DEFAULT;
  var _GL_PARAMETER_SETTERS;
  var _GL_PARAMETER_GETTERS;
  var GL_PARAMETER_DEFAULTS = (_GL_PARAMETER_DEFAULT = {}, _defineProperty(_GL_PARAMETER_DEFAULT, 3042, false), _defineProperty(_GL_PARAMETER_DEFAULT, 32773, new Float32Array([0, 0, 0, 0])), _defineProperty(_GL_PARAMETER_DEFAULT, 32777, 32774), _defineProperty(_GL_PARAMETER_DEFAULT, 34877, 32774), _defineProperty(_GL_PARAMETER_DEFAULT, 32969, 1), _defineProperty(_GL_PARAMETER_DEFAULT, 32968, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 32971, 1), _defineProperty(_GL_PARAMETER_DEFAULT, 32970, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 3106, new Float32Array([0, 0, 0, 0])), _defineProperty(_GL_PARAMETER_DEFAULT, 3107, [true, true, true, true]), _defineProperty(_GL_PARAMETER_DEFAULT, 2884, false), _defineProperty(_GL_PARAMETER_DEFAULT, 2885, 1029), _defineProperty(_GL_PARAMETER_DEFAULT, 2929, false), _defineProperty(_GL_PARAMETER_DEFAULT, 2931, 1), _defineProperty(_GL_PARAMETER_DEFAULT, 2932, 513), _defineProperty(_GL_PARAMETER_DEFAULT, 2928, new Float32Array([0, 1])), _defineProperty(_GL_PARAMETER_DEFAULT, 2930, true), _defineProperty(_GL_PARAMETER_DEFAULT, 3024, true), _defineProperty(_GL_PARAMETER_DEFAULT, 36006, null), _defineProperty(_GL_PARAMETER_DEFAULT, 2886, 2305), _defineProperty(_GL_PARAMETER_DEFAULT, 33170, 4352), _defineProperty(_GL_PARAMETER_DEFAULT, 2849, 1), _defineProperty(_GL_PARAMETER_DEFAULT, 32823, false), _defineProperty(_GL_PARAMETER_DEFAULT, 32824, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 10752, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 32938, 1), _defineProperty(_GL_PARAMETER_DEFAULT, 32939, false), _defineProperty(_GL_PARAMETER_DEFAULT, 3089, false), _defineProperty(_GL_PARAMETER_DEFAULT, 3088, new Int32Array([0, 0, 1024, 1024])), _defineProperty(_GL_PARAMETER_DEFAULT, 2960, false), _defineProperty(_GL_PARAMETER_DEFAULT, 2961, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 2968, 4294967295), _defineProperty(_GL_PARAMETER_DEFAULT, 36005, 4294967295), _defineProperty(_GL_PARAMETER_DEFAULT, 2962, 519), _defineProperty(_GL_PARAMETER_DEFAULT, 2967, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 2963, 4294967295), _defineProperty(_GL_PARAMETER_DEFAULT, 34816, 519), _defineProperty(_GL_PARAMETER_DEFAULT, 36003, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 36004, 4294967295), _defineProperty(_GL_PARAMETER_DEFAULT, 2964, 7680), _defineProperty(_GL_PARAMETER_DEFAULT, 2965, 7680), _defineProperty(_GL_PARAMETER_DEFAULT, 2966, 7680), _defineProperty(_GL_PARAMETER_DEFAULT, 34817, 7680), _defineProperty(_GL_PARAMETER_DEFAULT, 34818, 7680), _defineProperty(_GL_PARAMETER_DEFAULT, 34819, 7680), _defineProperty(_GL_PARAMETER_DEFAULT, 2978, [0, 0, 1024, 1024]), _defineProperty(_GL_PARAMETER_DEFAULT, 3333, 4), _defineProperty(_GL_PARAMETER_DEFAULT, 3317, 4), _defineProperty(_GL_PARAMETER_DEFAULT, 37440, false), _defineProperty(_GL_PARAMETER_DEFAULT, 37441, false), _defineProperty(_GL_PARAMETER_DEFAULT, 37443, 37444), _defineProperty(_GL_PARAMETER_DEFAULT, 35723, 4352), _defineProperty(_GL_PARAMETER_DEFAULT, 36010, null), _defineProperty(_GL_PARAMETER_DEFAULT, 35977, false), _defineProperty(_GL_PARAMETER_DEFAULT, 3330, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 3332, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 3331, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 3314, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 32878, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 3316, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 3315, 0), _defineProperty(_GL_PARAMETER_DEFAULT, 32877, 0), _GL_PARAMETER_DEFAULT);
  var enable = function enable2(gl, value17, key) {
    return value17 ? gl.enable(key) : gl.disable(key);
  };
  var hint2 = function hint3(gl, value17, key) {
    return gl.hint(key, value17);
  };
  var pixelStorei = function pixelStorei2(gl, value17, key) {
    return gl.pixelStorei(key, value17);
  };
  var drawFramebuffer = function drawFramebuffer2(gl, value17) {
    var target = isWebGL2(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value17);
  };
  var readFramebuffer = function readFramebuffer2(gl, value17) {
    return gl.bindFramebuffer(36008, value17);
  };
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
  }
  var GL_PARAMETER_SETTERS = (_GL_PARAMETER_SETTERS = {}, _defineProperty(_GL_PARAMETER_SETTERS, 3042, enable), _defineProperty(_GL_PARAMETER_SETTERS, 32773, function(gl, value17) {
    return gl.blendColor.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, 32777, "blendEquation"), _defineProperty(_GL_PARAMETER_SETTERS, 34877, "blendEquation"), _defineProperty(_GL_PARAMETER_SETTERS, 32969, "blendFunc"), _defineProperty(_GL_PARAMETER_SETTERS, 32968, "blendFunc"), _defineProperty(_GL_PARAMETER_SETTERS, 32971, "blendFunc"), _defineProperty(_GL_PARAMETER_SETTERS, 32970, "blendFunc"), _defineProperty(_GL_PARAMETER_SETTERS, 3106, function(gl, value17) {
    return gl.clearColor.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, 3107, function(gl, value17) {
    return gl.colorMask.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2884, enable), _defineProperty(_GL_PARAMETER_SETTERS, 2885, function(gl, value17) {
    return gl.cullFace(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2929, enable), _defineProperty(_GL_PARAMETER_SETTERS, 2931, function(gl, value17) {
    return gl.clearDepth(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2932, function(gl, value17) {
    return gl.depthFunc(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2928, function(gl, value17) {
    return gl.depthRange.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2930, function(gl, value17) {
    return gl.depthMask(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 3024, enable), _defineProperty(_GL_PARAMETER_SETTERS, 35723, hint2), _defineProperty(_GL_PARAMETER_SETTERS, 36006, drawFramebuffer), _defineProperty(_GL_PARAMETER_SETTERS, 2886, function(gl, value17) {
    return gl.frontFace(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 33170, hint2), _defineProperty(_GL_PARAMETER_SETTERS, 2849, function(gl, value17) {
    return gl.lineWidth(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 32823, enable), _defineProperty(_GL_PARAMETER_SETTERS, 32824, "polygonOffset"), _defineProperty(_GL_PARAMETER_SETTERS, 10752, "polygonOffset"), _defineProperty(_GL_PARAMETER_SETTERS, 35977, enable), _defineProperty(_GL_PARAMETER_SETTERS, 32938, "sampleCoverage"), _defineProperty(_GL_PARAMETER_SETTERS, 32939, "sampleCoverage"), _defineProperty(_GL_PARAMETER_SETTERS, 3089, enable), _defineProperty(_GL_PARAMETER_SETTERS, 3088, function(gl, value17) {
    return gl.scissor.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2960, enable), _defineProperty(_GL_PARAMETER_SETTERS, 2961, function(gl, value17) {
    return gl.clearStencil(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2968, function(gl, value17) {
    return gl.stencilMaskSeparate(1028, value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 36005, function(gl, value17) {
    return gl.stencilMaskSeparate(1029, value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, 2962, "stencilFuncFront"), _defineProperty(_GL_PARAMETER_SETTERS, 2967, "stencilFuncFront"), _defineProperty(_GL_PARAMETER_SETTERS, 2963, "stencilFuncFront"), _defineProperty(_GL_PARAMETER_SETTERS, 34816, "stencilFuncBack"), _defineProperty(_GL_PARAMETER_SETTERS, 36003, "stencilFuncBack"), _defineProperty(_GL_PARAMETER_SETTERS, 36004, "stencilFuncBack"), _defineProperty(_GL_PARAMETER_SETTERS, 2964, "stencilOpFront"), _defineProperty(_GL_PARAMETER_SETTERS, 2965, "stencilOpFront"), _defineProperty(_GL_PARAMETER_SETTERS, 2966, "stencilOpFront"), _defineProperty(_GL_PARAMETER_SETTERS, 34817, "stencilOpBack"), _defineProperty(_GL_PARAMETER_SETTERS, 34818, "stencilOpBack"), _defineProperty(_GL_PARAMETER_SETTERS, 34819, "stencilOpBack"), _defineProperty(_GL_PARAMETER_SETTERS, 2978, function(gl, value17) {
    return gl.viewport.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, 3333, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 3317, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 37440, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 37441, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 37443, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 3330, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 3332, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 3331, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 36010, readFramebuffer), _defineProperty(_GL_PARAMETER_SETTERS, 3314, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 32878, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 3316, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 3315, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, 32877, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, "framebuffer", function framebuffer(gl, _framebuffer) {
    var handle = _framebuffer && "handle" in _framebuffer ? _framebuffer.handle : _framebuffer;
    return gl.bindFramebuffer(36160, handle);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "blend", function blend(gl, value17) {
    return value17 ? gl.enable(3042) : gl.disable(3042);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "blendColor", function blendColor(gl, value17) {
    return gl.blendColor.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "blendEquation", function blendEquation(gl, args) {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate.apply(gl, _toConsumableArray(args));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "blendFunc", function blendFunc(gl, args) {
    args = isArray(args) && args.length === 2 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;
    gl.blendFuncSeparate.apply(gl, _toConsumableArray(args));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "clearColor", function clearColor(gl, value17) {
    return gl.clearColor.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "clearDepth", function clearDepth(gl, value17) {
    return gl.clearDepth(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "clearStencil", function clearStencil(gl, value17) {
    return gl.clearStencil(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "colorMask", function colorMask(gl, value17) {
    return gl.colorMask.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "cull", function cull(gl, value17) {
    return value17 ? gl.enable(2884) : gl.disable(2884);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "cullFace", function cullFace(gl, value17) {
    return gl.cullFace(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "depthTest", function depthTest(gl, value17) {
    return value17 ? gl.enable(2929) : gl.disable(2929);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "depthFunc", function depthFunc(gl, value17) {
    return gl.depthFunc(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "depthMask", function depthMask(gl, value17) {
    return gl.depthMask(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "depthRange", function depthRange(gl, value17) {
    return gl.depthRange.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "dither", function dither(gl, value17) {
    return value17 ? gl.enable(3024) : gl.disable(3024);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "derivativeHint", function derivativeHint(gl, value17) {
    gl.hint(35723, value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "frontFace", function frontFace(gl, value17) {
    return gl.frontFace(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "mipmapHint", function mipmapHint(gl, value17) {
    return gl.hint(33170, value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "lineWidth", function lineWidth(gl, value17) {
    return gl.lineWidth(value17);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "polygonOffsetFill", function polygonOffsetFill(gl, value17) {
    return value17 ? gl.enable(32823) : gl.disable(32823);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "polygonOffset", function polygonOffset(gl, value17) {
    return gl.polygonOffset.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "sampleCoverage", function sampleCoverage(gl, value17) {
    return gl.sampleCoverage.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "scissorTest", function scissorTest(gl, value17) {
    return value17 ? gl.enable(3089) : gl.disable(3089);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "scissor", function scissor(gl, value17) {
    return gl.scissor.apply(gl, _toConsumableArray(value17));
  }), _defineProperty(_GL_PARAMETER_SETTERS, "stencilTest", function stencilTest(gl, value17) {
    return value17 ? gl.enable(2960) : gl.disable(2960);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "stencilMask", function stencilMask(gl, value17) {
    value17 = isArray(value17) ? value17 : [value17, value17];
    var _value = value17, _value2 = _slicedToArray(_value, 2), mask = _value2[0], backMask = _value2[1];
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "stencilFunc", function stencilFunc(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;
    var _args = args, _args2 = _slicedToArray(_args, 6), func = _args2[0], ref = _args2[1], mask = _args2[2], backFunc = _args2[3], backRef = _args2[4], backMask = _args2[5];
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "stencilOp", function stencilOp(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;
    var _args3 = args, _args4 = _slicedToArray(_args3, 6), sfail = _args4[0], dpfail = _args4[1], dppass = _args4[2], backSfail = _args4[3], backDpfail = _args4[4], backDppass = _args4[5];
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  }), _defineProperty(_GL_PARAMETER_SETTERS, "viewport", function viewport(gl, value17) {
    return gl.viewport.apply(gl, _toConsumableArray(value17));
  }), _GL_PARAMETER_SETTERS);
  function getValue(glEnum, values, cache3) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache3[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: function blendEquation2(gl, values, cache3) {
      return gl.blendEquationSeparate(getValue(32777, values, cache3), getValue(34877, values, cache3));
    },
    blendFunc: function blendFunc2(gl, values, cache3) {
      return gl.blendFuncSeparate(getValue(32969, values, cache3), getValue(32968, values, cache3), getValue(32971, values, cache3), getValue(32970, values, cache3));
    },
    polygonOffset: function polygonOffset2(gl, values, cache3) {
      return gl.polygonOffset(getValue(32824, values, cache3), getValue(10752, values, cache3));
    },
    sampleCoverage: function sampleCoverage2(gl, values, cache3) {
      return gl.sampleCoverage(getValue(32938, values, cache3), getValue(32939, values, cache3));
    },
    stencilFuncFront: function stencilFuncFront(gl, values, cache3) {
      return gl.stencilFuncSeparate(1028, getValue(2962, values, cache3), getValue(2967, values, cache3), getValue(2963, values, cache3));
    },
    stencilFuncBack: function stencilFuncBack(gl, values, cache3) {
      return gl.stencilFuncSeparate(1029, getValue(34816, values, cache3), getValue(36003, values, cache3), getValue(36004, values, cache3));
    },
    stencilOpFront: function stencilOpFront(gl, values, cache3) {
      return gl.stencilOpSeparate(1028, getValue(2964, values, cache3), getValue(2965, values, cache3), getValue(2966, values, cache3));
    },
    stencilOpBack: function stencilOpBack(gl, values, cache3) {
      return gl.stencilOpSeparate(1029, getValue(34817, values, cache3), getValue(34818, values, cache3), getValue(34819, values, cache3));
    }
  };
  var GL_HOOKED_SETTERS = {
    enable: function enable3(update3, capability) {
      return update3(_defineProperty({}, capability, true));
    },
    disable: function disable(update3, capability) {
      return update3(_defineProperty({}, capability, false));
    },
    pixelStorei: function pixelStorei3(update3, pname, value17) {
      return update3(_defineProperty({}, pname, value17));
    },
    hint: function hint4(update3, pname, _hint) {
      return update3(_defineProperty({}, pname, _hint));
    },
    bindFramebuffer: function bindFramebuffer(update3, target, framebuffer2) {
      var _update5;
      switch (target) {
        case 36160:
          return update3((_update5 = {}, _defineProperty(_update5, 36006, framebuffer2), _defineProperty(_update5, 36010, framebuffer2), _update5));
        case 36009:
          return update3(_defineProperty({}, 36006, framebuffer2));
        case 36008:
          return update3(_defineProperty({}, 36010, framebuffer2));
        default:
          return null;
      }
    },
    blendColor: function blendColor2(update3, r, g, b, a) {
      return update3(_defineProperty({}, 32773, new Float32Array([r, g, b, a])));
    },
    blendEquation: function blendEquation3(update3, mode) {
      var _update9;
      return update3((_update9 = {}, _defineProperty(_update9, 32777, mode), _defineProperty(_update9, 34877, mode), _update9));
    },
    blendEquationSeparate: function blendEquationSeparate(update3, modeRGB, modeAlpha) {
      var _update10;
      return update3((_update10 = {}, _defineProperty(_update10, 32777, modeRGB), _defineProperty(_update10, 34877, modeAlpha), _update10));
    },
    blendFunc: function blendFunc3(update3, src, dst) {
      var _update11;
      return update3((_update11 = {}, _defineProperty(_update11, 32969, src), _defineProperty(_update11, 32968, dst), _defineProperty(_update11, 32971, src), _defineProperty(_update11, 32970, dst), _update11));
    },
    blendFuncSeparate: function blendFuncSeparate(update3, srcRGB, dstRGB, srcAlpha, dstAlpha) {
      var _update12;
      return update3((_update12 = {}, _defineProperty(_update12, 32969, srcRGB), _defineProperty(_update12, 32968, dstRGB), _defineProperty(_update12, 32971, srcAlpha), _defineProperty(_update12, 32970, dstAlpha), _update12));
    },
    clearColor: function clearColor2(update3, r, g, b, a) {
      return update3(_defineProperty({}, 3106, new Float32Array([r, g, b, a])));
    },
    clearDepth: function clearDepth2(update3, depth) {
      return update3(_defineProperty({}, 2931, depth));
    },
    clearStencil: function clearStencil2(update3, s) {
      return update3(_defineProperty({}, 2961, s));
    },
    colorMask: function colorMask2(update3, r, g, b, a) {
      return update3(_defineProperty({}, 3107, [r, g, b, a]));
    },
    cullFace: function cullFace2(update3, mode) {
      return update3(_defineProperty({}, 2885, mode));
    },
    depthFunc: function depthFunc2(update3, func) {
      return update3(_defineProperty({}, 2932, func));
    },
    depthRange: function depthRange2(update3, zNear, zFar) {
      return update3(_defineProperty({}, 2928, new Float32Array([zNear, zFar])));
    },
    depthMask: function depthMask2(update3, mask) {
      return update3(_defineProperty({}, 2930, mask));
    },
    frontFace: function frontFace2(update3, face) {
      return update3(_defineProperty({}, 2886, face));
    },
    lineWidth: function lineWidth2(update3, width) {
      return update3(_defineProperty({}, 2849, width));
    },
    polygonOffset: function polygonOffset3(update3, factor, units) {
      var _update23;
      return update3((_update23 = {}, _defineProperty(_update23, 32824, factor), _defineProperty(_update23, 10752, units), _update23));
    },
    sampleCoverage: function sampleCoverage3(update3, value17, invert4) {
      var _update24;
      return update3((_update24 = {}, _defineProperty(_update24, 32938, value17), _defineProperty(_update24, 32939, invert4), _update24));
    },
    scissor: function scissor2(update3, x, y, width, height) {
      return update3(_defineProperty({}, 3088, new Int32Array([x, y, width, height])));
    },
    stencilMask: function stencilMask2(update3, mask) {
      var _update26;
      return update3((_update26 = {}, _defineProperty(_update26, 2968, mask), _defineProperty(_update26, 36005, mask), _update26));
    },
    stencilMaskSeparate: function stencilMaskSeparate(update3, face, mask) {
      return update3(_defineProperty({}, face === 1028 ? 2968 : 36005, mask));
    },
    stencilFunc: function stencilFunc2(update3, func, ref, mask) {
      var _update28;
      return update3((_update28 = {}, _defineProperty(_update28, 2962, func), _defineProperty(_update28, 2967, ref), _defineProperty(_update28, 2963, mask), _defineProperty(_update28, 34816, func), _defineProperty(_update28, 36003, ref), _defineProperty(_update28, 36004, mask), _update28));
    },
    stencilFuncSeparate: function stencilFuncSeparate(update3, face, func, ref, mask) {
      var _update29;
      return update3((_update29 = {}, _defineProperty(_update29, face === 1028 ? 2962 : 34816, func), _defineProperty(_update29, face === 1028 ? 2967 : 36003, ref), _defineProperty(_update29, face === 1028 ? 2963 : 36004, mask), _update29));
    },
    stencilOp: function stencilOp2(update3, fail, zfail, zpass) {
      var _update30;
      return update3((_update30 = {}, _defineProperty(_update30, 2964, fail), _defineProperty(_update30, 2965, zfail), _defineProperty(_update30, 2966, zpass), _defineProperty(_update30, 34817, fail), _defineProperty(_update30, 34818, zfail), _defineProperty(_update30, 34819, zpass), _update30));
    },
    stencilOpSeparate: function stencilOpSeparate(update3, face, fail, zfail, zpass) {
      var _update31;
      return update3((_update31 = {}, _defineProperty(_update31, face === 1028 ? 2964 : 34817, fail), _defineProperty(_update31, face === 1028 ? 2965 : 34818, zfail), _defineProperty(_update31, face === 1028 ? 2966 : 34819, zpass), _update31));
    },
    viewport: function viewport2(update3, x, y, width, height) {
      return update3(_defineProperty({}, 2978, [x, y, width, height]));
    }
  };
  var isEnabled = function isEnabled2(gl, key) {
    return gl.isEnabled(key);
  };
  var GL_PARAMETER_GETTERS = (_GL_PARAMETER_GETTERS = {}, _defineProperty(_GL_PARAMETER_GETTERS, 3042, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 2884, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 2929, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 3024, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 32823, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 32926, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 32928, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 3089, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 2960, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, 35977, isEnabled), _GL_PARAMETER_GETTERS);

  // node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
  function isObjectEmpty(object) {
    for (var key in object) {
      return false;
    }
    return true;
  }
  function deepArrayEqual(x, y) {
    if (x === y) {
      return true;
    }
    var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
      for (var i = 0; i < x.length; ++i) {
        if (x[i] !== y[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
  function installGetterOverride(gl, functionName) {
    var originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get2() {
      var pname = arguments.length <= 0 ? void 0 : arguments[0];
      if (!(pname in gl.state.cache)) {
        gl.state.cache[pname] = originalGetterFunc.apply(void 0, arguments);
      }
      return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc.apply(void 0, arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-from-cache"),
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    var originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set2() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      var _setter = setter.apply(void 0, [gl.state._updateCache].concat(params)), valueChanged = _setter.valueChanged, oldValue = _setter.oldValue;
      if (valueChanged) {
        originalSetterFunc.apply(void 0, params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-to-cache"),
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    var originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      if (gl.state.program !== handle) {
        originalUseProgram(handle);
        gl.state.program = handle;
      }
    };
  }
  var GLState = function() {
    function GLState2(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$copyState = _ref.copyState, copyState = _ref$copyState === void 0 ? false : _ref$copyState, _ref$log = _ref.log, log3 = _ref$log === void 0 ? function() {
      } : _ref$log;
      _classCallCheck(this, GLState2);
      this.gl = gl;
      this.program = null;
      this.stateStack = [];
      this.enable = true;
      this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log3;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    _createClass(GLState2, [{
      key: "push",
      value: function push2() {
        var values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.stateStack.push({});
      }
    }, {
      key: "pop",
      value: function pop() {
        assert4(this.stateStack.length > 0);
        var oldValues = this.stateStack[this.stateStack.length - 1];
        setParameters(this.gl, oldValues);
        this.stateStack.pop();
      }
    }, {
      key: "_updateCache",
      value: function _updateCache(values) {
        var valueChanged = false;
        var oldValue;
        var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
        for (var key in values) {
          assert4(key !== void 0);
          var value17 = values[key];
          var cached = this.cache[key];
          if (!deepArrayEqual(value17, cached)) {
            valueChanged = true;
            oldValue = cached;
            if (oldValues && !(key in oldValues)) {
              oldValues[key] = cached;
            }
            this.cache[key] = value17;
          }
        }
        return {
          valueChanged,
          oldValue
        };
      }
    }]);
    return GLState2;
  }();
  function trackContextState(gl) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _options$enable = options.enable, enable4 = _options$enable === void 0 ? true : _options$enable, copyState = options.copyState;
    assert4(copyState !== void 0);
    if (!gl.state) {
      var global_7 = typeof global !== "undefined" ? global : window;
      var polyfillContext2 = global_7.polyfillContext;
      if (polyfillContext2) {
        polyfillContext2(gl);
      }
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (var key in GL_HOOKED_SETTERS) {
        var setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable4;
    return gl;
  }
  function pushContextState(gl) {
    if (!gl.state) {
      trackContextState(gl, {
        copyState: false
      });
    }
    gl.state.push();
  }
  function popContextState(gl) {
    assert4(gl.state);
    gl.state.pop();
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
  function _createForOfIteratorHelper8(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray9(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray9(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray9(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray9(o, minLen);
  }
  function _arrayLikeToArray9(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function setParameters(gl, values) {
    assert4(isWebGL(gl), "setParameters requires a WebGL context");
    if (isObjectEmpty(values)) {
      return;
    }
    var compositeSetters = {};
    for (var key in values) {
      var glConstant = Number(key);
      var setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, values[key], glConstant);
        }
      }
    }
    var cache3 = gl.state && gl.state.cache;
    if (cache3) {
      for (var _key in compositeSetters) {
        var compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[_key];
        compositeSetter(gl, values, cache3);
      }
    }
  }
  function getParameters(gl, parameters) {
    parameters = parameters || GL_PARAMETER_DEFAULTS;
    if (typeof parameters === "number") {
      var key = parameters;
      var getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    var parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    var state = {};
    var _iterator = _createForOfIteratorHelper8(parameterKeys), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _key2 = _step.value;
        var _getter = GL_PARAMETER_GETTERS[_key2];
        state[_key2] = _getter ? _getter(gl, Number(_key2)) : gl.getParameter(Number(_key2));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return state;
  }
  function resetParameters(gl) {
    setParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function withParameters(gl, parameters, func) {
    if (isObjectEmpty(parameters)) {
      return func(gl);
    }
    var _parameters$nocatch = parameters.nocatch, nocatch = _parameters$nocatch === void 0 ? true : _parameters$nocatch;
    pushContextState(gl);
    setParameters(gl, parameters);
    var value17;
    if (nocatch) {
      value17 = func(gl);
      popContextState(gl);
    } else {
      try {
        value17 = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value17;
  }

  // node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var import_env3 = __toModule(require_env2());

  // node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
  function cssToDeviceRatio(gl) {
    var luma = gl.luma;
    if (gl.canvas && luma) {
      var clientWidth = luma.canvasSizeInfo.clientWidth;
      return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
    }
    return 1;
  }
  function cssToDevicePixels(gl, cssPixel) {
    var yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var ratio = cssToDeviceRatio(gl);
    var width = gl.drawingBufferWidth;
    var height = gl.drawingBufferHeight;
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  function getDevicePixelRatio(useDevicePixels) {
    var windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
    if (Number.isFinite(useDevicePixels)) {
      return useDevicePixels <= 0 ? 1 : useDevicePixels;
    }
    return useDevicePixels ? windowRatio : 1;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    var x = scaleX(pixel[0], ratio, width);
    var y = scaleY(pixel[1], ratio, height, yInvert);
    var t = scaleX(pixel[0] + 1, ratio, width);
    var xHigh = t === width - 1 ? t : t - 1;
    t = scaleY(pixel[1] + 1, ratio, height, yInvert);
    var yHigh;
    if (yInvert) {
      t = t === 0 ? t : t + 1;
      yHigh = y;
      y = t;
    } else {
      yHigh = t === height - 1 ? t : t - 1;
    }
    return {
      x,
      y,
      width: Math.max(xHigh - x + 1, 1),
      height: Math.max(yHigh - y + 1, 1)
    };
  }
  function scaleX(x, ratio, width) {
    var r = Math.min(Math.round(x * ratio), width - 1);
    return r;
  }
  function scaleY(y, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
  }

  // node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var isBrowser5 = (0, import_env3.isBrowser)();
  var isPage = isBrowser5 && typeof document !== "undefined";
  var CONTEXT_DEFAULTS = {
    webgl2: true,
    webgl1: true,
    throwOnError: true,
    manageState: true,
    canvas: null,
    debug: false,
    width: 800,
    height: 600
  };
  function createGLContext() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    assert4(isBrowser5, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
    options = Object.assign({}, CONTEXT_DEFAULTS, options);
    var _options = options, width = _options.width, height = _options.height;
    function onError(message) {
      if (options.throwOnError) {
        throw new Error(message);
      }
      console.error(message);
      return null;
    }
    options.onError = onError;
    var gl;
    var _options2 = options, canvas = _options2.canvas;
    var targetCanvas = getCanvas({
      canvas,
      width,
      height,
      onError
    });
    gl = createBrowserContext(targetCanvas, options);
    if (!gl) {
      return null;
    }
    gl = instrumentGLContext(gl, options);
    logInfo(gl);
    return gl;
  }
  function instrumentGLContext(gl) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!gl || gl._instrumented) {
      return gl;
    }
    gl._version = gl._version || getVersion(gl);
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    options = Object.assign({}, CONTEXT_DEFAULTS, options);
    var _options3 = options, manageState = _options3.manageState, debug2 = _options3.debug;
    if (manageState) {
      trackContextState(gl, {
        copyState: false,
        log: function log3() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return log.log.apply(log, [1].concat(args))();
        }
      });
    }
    if (isBrowser5 && debug2) {
      if (!import_env3.global.makeDebugContext) {
        log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
      } else {
        gl = import_env3.global.makeDebugContext(gl, options);
        log.level = Math.max(log.level, 1);
      }
    }
    gl._instrumented = true;
    return gl;
  }
  function getContextDebugInfo(gl) {
    var vendorMasked = gl.getParameter(7936);
    var rendererMasked = gl.getParameter(7937);
    var ext = gl.getExtension("WEBGL_debug_renderer_info");
    var vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
    var rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
    return {
      vendor: vendorUnmasked || vendorMasked,
      renderer: rendererUnmasked || rendererMasked,
      vendorMasked,
      rendererMasked,
      version: gl.getParameter(7938),
      shadingLanguageVersion: gl.getParameter(35724)
    };
  }
  function resizeGLContext(gl) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (gl.canvas) {
      var devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
      setDevicePixelRatio(gl, devicePixelRatio, options);
      return;
    }
    var ext = gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && "width" in options && "height" in options) {
      ext.resize(options.width, options.height);
    }
  }
  function createBrowserContext(canvas, options) {
    var onError = options.onError;
    var errorMessage = null;
    var onCreateError = function onCreateError2(error2) {
      return errorMessage = error2.statusMessage || errorMessage;
    };
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    var _options$webgl = options.webgl1, webgl1 = _options$webgl === void 0 ? true : _options$webgl, _options$webgl2 = options.webgl2, webgl2 = _options$webgl2 === void 0 ? true : _options$webgl2;
    var gl = null;
    if (webgl2) {
      gl = gl || canvas.getContext("webgl2", options);
      gl = gl || canvas.getContext("experimental-webgl2", options);
    }
    if (webgl1) {
      gl = gl || canvas.getContext("webgl", options);
      gl = gl || canvas.getContext("experimental-webgl", options);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
    }
    if (options.onContextLost) {
      canvas.addEventListener("webglcontextlost", options.onContextLost, false);
    }
    if (options.onContextRestored) {
      canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
    }
    return gl;
  }
  function getCanvas(_ref) {
    var canvas = _ref.canvas, _ref$width = _ref.width, width = _ref$width === void 0 ? 800 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 600 : _ref$height, onError = _ref.onError;
    var targetCanvas;
    if (typeof canvas === "string") {
      var isPageLoaded = isPage && document.readyState === "complete";
      if (!isPageLoaded) {
        onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
      }
      targetCanvas = document.getElementById(canvas);
    } else if (canvas) {
      targetCanvas = canvas;
    } else {
      targetCanvas = document.createElement("canvas");
      targetCanvas.id = "lumagl-canvas";
      targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
      targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
      document.body.insertBefore(targetCanvas, document.body.firstChild);
    }
    return targetCanvas;
  }
  function logInfo(gl) {
    var webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
    var info = getContextDebugInfo(gl);
    var driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
    var debug2 = gl.debug ? " debug" : "";
    log.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver))();
  }
  function getVersion(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return 2;
    }
    return 1;
  }
  function setDevicePixelRatio(gl, devicePixelRatio, options) {
    var clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
    var clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log.log(1, "Canvas clientWidth/clientHeight is 0")();
      devicePixelRatio = 1;
      clientWidth = gl.canvas.width || 1;
      clientHeight = gl.canvas.height || 1;
    }
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    var cachedSize = gl.luma.canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      var clampedPixelRatio = devicePixelRatio;
      var canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      var canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      gl.canvas.width = canvasWidth;
      gl.canvas.height = canvasHeight;
      if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
        log.warn("Device pixel ratio clamped")();
        clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
        gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
        gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
      }
      Object.assign(gl.luma.canvasSizeInfo, {
        clientWidth,
        clientHeight,
        devicePixelRatio
      });
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/init.js
  var import_env4 = __toModule(require_env2());
  var VERSION5 = true ? "8.4.5" : "untranspiled source";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var StatsManager = function() {
    function StatsManager2() {
      _classCallCheck(this, StatsManager2);
      this.stats = new Map();
    }
    _createClass(StatsManager2, [{
      key: "get",
      value: function get2(name) {
        if (!this.stats.has(name)) {
          this.stats.set(name, new Stats({
            id: name
          }));
        }
        return this.stats.get(name);
      }
    }]);
    return StatsManager2;
  }();
  var lumaStats = new StatsManager();
  if (import_env4.global.luma && import_env4.global.luma.VERSION !== VERSION5) {
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(import_env4.global.luma.VERSION, " vs ").concat(VERSION5));
  }
  if (!import_env4.global.luma) {
    if ((0, import_env4.isBrowser)()) {
      log.log(1, "luma.gl ".concat(VERSION5, " - ").concat(STARTUP_MESSAGE))();
    }
    import_env4.global.luma = import_env4.global.luma || {
      VERSION: VERSION5,
      version: VERSION5,
      log,
      stats: lumaStats,
      globals: {
        modules: {},
        nodeIO: {}
      }
    };
  }
  var init_default2 = import_env4.global.luma;

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
  function requestAnimationFrame2(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  var import_env5 = __toModule(require_env2());

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$clamped = _ref.clamped, clamped = _ref$clamped === void 0 ? true : _ref$clamped;
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function flipRows(_ref2) {
    var data = _ref2.data, width = _ref2.width, height = _ref2.height, _ref2$bytesPerPixel = _ref2.bytesPerPixel, bytesPerPixel = _ref2$bytesPerPixel === void 0 ? 4 : _ref2$bytesPerPixel, temp = _ref2.temp;
    var bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for (var y = 0; y < height / 2; ++y) {
      var topOffset = y * bytesPerRow;
      var bottomOffset = (height - y - 1) * bytesPerRow;
      temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
      data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      data.set(temp, bottomOffset);
    }
  }
  function scalePixels2(_ref3) {
    var data = _ref3.data, width = _ref3.width, height = _ref3.height;
    var newWidth = Math.round(width / 2);
    var newHeight = Math.round(height / 2);
    var newData = new Uint8Array(newWidth * newHeight * 4);
    for (var y = 0; y < newHeight; y++) {
      for (var x = 0; x < newWidth; x++) {
        for (var c = 0; c < 4; c++) {
          newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
        }
      }
    }
    return {
      data: newData,
      width: newWidth,
      height: newHeight
    };
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
  function assert5(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
  var uidCounters = {};
  function uid() {
    var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
    uidCounters[id] = uidCounters[id] || 1;
    var count3 = uidCounters[id]++;
    return "".concat(id, "-").concat(count3);
  }
  function isPowerOfTwo(n) {
    assert5(typeof n === "number", "Input must be a number");
    return n && (n & n - 1) === 0;
  }
  function isObjectEmpty2(obj) {
    var isEmpty = true;
    for (var key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
  function formatArrayValue(v, opts) {
    var _opts$maxElts = opts.maxElts, maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts, _opts$size = opts.size, size = _opts$size === void 0 ? 1 : _opts$size;
    var string = "[";
    for (var i = 0; i < v.length && i < maxElts; ++i) {
      if (i > 0) {
        string += ",".concat(i % size === 0 ? " " : "");
      }
      string += formatValue(v[i], opts);
    }
    var terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
  }
  function formatValue(v) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var EPSILON3 = 1e-16;
    var _opts$isInteger = opts.isInteger, isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
      return formatArrayValue(v, opts);
    }
    if (!Number.isFinite(v)) {
      return String(v);
    }
    if (Math.abs(v) < EPSILON3) {
      return isInteger ? "0" : "0.";
    }
    if (isInteger) {
      return v.toFixed(0);
    }
    if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
      return v.toFixed(0);
    }
    var string = v.toPrecision(2);
    var decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
  function stubRemovedMethods(instance, className, version2, methodNames) {
    var upgradeMessage = "See luma.gl ".concat(version2, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    var prototype = Object.getPrototypeOf(instance);
    methodNames.forEach(function(methodName) {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = function() {
        log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
  function checkProps(className, props, propChecks) {
    var _propChecks$removedPr = propChecks.removedProps, removedProps = _propChecks$removedPr === void 0 ? {} : _propChecks$removedPr, _propChecks$deprecate = propChecks.deprecatedProps, deprecatedProps = _propChecks$deprecate === void 0 ? {} : _propChecks$deprecate, _propChecks$replacedP = propChecks.replacedProps, replacedProps = _propChecks$replacedP === void 0 ? {} : _propChecks$replacedP;
    for (var propName in removedProps) {
      if (propName in props) {
        var replacementProp = removedProps[propName];
        var replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        log.removed("".concat(className, ".").concat(propName), replacement)();
      }
    }
    for (var _propName in deprecatedProps) {
      if (_propName in props) {
        var _replacementProp = deprecatedProps[_propName];
        log.deprecated("".concat(className, ".").concat(_propName), "".concat(className, ".").concat(_replacementProp))();
      }
    }
    var newProps = null;
    for (var _propName2 in replacedProps) {
      if (_propName2 in props) {
        var _replacementProp2 = replacedProps[_propName2];
        log.deprecated("".concat(className, ".").concat(_propName2), "".concat(className, ".").concat(_replacementProp2))();
        newProps = newProps || Object.assign({}, props);
        newProps[_replacementProp2] = props[_propName2];
        delete newProps[_propName2];
      }
    }
    return newProps || props;
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
  function getKeyValue(gl, name) {
    if (typeof name !== "string") {
      return name;
    }
    var number = Number(name);
    if (!isNaN(number)) {
      return number;
    }
    name = name.replace(/^.*\./, "");
    var value17 = gl[name];
    assert5(value17 !== void 0, "Accessing undefined constant GL.".concat(name));
    return value17;
  }
  function getKey(gl, value17) {
    value17 = Number(value17);
    for (var key in gl) {
      if (gl[key] === value17) {
        return "GL.".concat(key);
      }
    }
    return String(value17);
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
  function _createForOfIteratorHelper9(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray10(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray10(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray10(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray10(o, minLen);
  }
  function _arrayLikeToArray10(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var Resource = function() {
    function Resource3(gl) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Resource3);
      assertWebGLContext(gl);
      var id = opts.id, _opts$userData = opts.userData, userData = _opts$userData === void 0 ? {} : _opts$userData;
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || uid(this.constructor.name);
      this.userData = userData;
      this._bound = false;
      this._handle = opts.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
      this._addStats();
    }
    _createClass(Resource3, [{
      key: "toString",
      value: function toString() {
        return "".concat(this.constructor.name, "(").concat(this.id, ")");
      }
    }, {
      key: "delete",
      value: function _delete() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$deleteChildren = _ref.deleteChildren, deleteChildren = _ref$deleteChildren === void 0 ? false : _ref$deleteChildren;
        var children = this._handle && this._deleteHandle(this._handle);
        if (this._handle) {
          this._removeStats();
        }
        this._handle = null;
        if (children && deleteChildren) {
          children.filter(Boolean).forEach(function(child) {
            return child["delete"]();
          });
        }
        return this;
      }
    }, {
      key: "bind",
      value: function bind() {
        var funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
        if (typeof funcOrHandle !== "function") {
          this._bindHandle(funcOrHandle);
          return this;
        }
        var value17;
        if (!this._bound) {
          this._bindHandle(this.handle);
          this._bound = true;
          value17 = funcOrHandle();
          this._bound = false;
          this._bindHandle(null);
        } else {
          value17 = funcOrHandle();
        }
        return value17;
      }
    }, {
      key: "unbind",
      value: function unbind() {
        this.bind(null);
      }
    }, {
      key: "getParameter",
      value: function getParameter(pname) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        pname = getKeyValue(this.gl, pname);
        assert5(pname);
        var parameters = this.constructor.PARAMETERS || {};
        var parameter = parameters[pname];
        if (parameter) {
          var isWebgl2 = isWebGL2(this.gl);
          var parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (!parameterAvailable) {
            var webgl1Default = parameter.webgl1;
            var webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
            var defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
            return defaultValue;
          }
        }
        return this._getParameter(pname, opts);
      }
    }, {
      key: "getParameters",
      value: function getParameters2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var parameters = options.parameters, keys = options.keys;
        var PARAMETERS = this.constructor.PARAMETERS || {};
        var isWebgl2 = isWebGL2(this.gl);
        var values = {};
        var parameterKeys = parameters || Object.keys(PARAMETERS);
        var _iterator = _createForOfIteratorHelper9(parameterKeys), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var pname = _step.value;
            var parameter = PARAMETERS[pname];
            var parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (parameterAvailable) {
              var key = keys ? getKey(this.gl, pname) : pname;
              values[key] = this.getParameter(pname, options);
              if (keys && parameter.type === "GLenum") {
                values[key] = getKey(this.gl, values[key]);
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return values;
      }
    }, {
      key: "setParameter",
      value: function setParameter(pname, value17) {
        pname = getKeyValue(this.gl, pname);
        assert5(pname);
        var parameters = this.constructor.PARAMETERS || {};
        var parameter = parameters[pname];
        if (parameter) {
          var isWebgl2 = isWebGL2(this.gl);
          var parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (!parameterAvailable) {
            throw new Error("Parameter not available on this platform");
          }
          if (parameter.type === "GLenum") {
            value17 = getKeyValue(value17);
          }
        }
        this._setParameter(pname, value17);
        return this;
      }
    }, {
      key: "setParameters",
      value: function setParameters2(parameters) {
        for (var pname in parameters) {
          this.setParameter(pname, parameters[pname]);
        }
        return this;
      }
    }, {
      key: "stubRemovedMethods",
      value: function stubRemovedMethods2(className, version2, methodNames) {
        return stubRemovedMethods(this, className, version2, methodNames);
      }
    }, {
      key: "initialize",
      value: function initialize(opts) {
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
    }, {
      key: "_bindHandle",
      value: function _bindHandle(handle) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
    }, {
      key: "_getOptsFromHandle",
      value: function _getOptsFromHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
    }, {
      key: "_getParameter",
      value: function _getParameter(pname, opts) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
    }, {
      key: "_setParameter",
      value: function _setParameter(pname, value17) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
    }, {
      key: "_context",
      value: function _context() {
        this.gl.luma = this.gl.luma || {};
        return this.gl.luma;
      }
    }, {
      key: "_addStats",
      value: function _addStats() {
        var name = this.constructor.name;
        var stats = lumaStats.get("Resource Counts");
        stats.get("Resources Created").incrementCount();
        stats.get("".concat(name, "s Created")).incrementCount();
        stats.get("".concat(name, "s Active")).incrementCount();
      }
    }, {
      key: "_removeStats",
      value: function _removeStats() {
        var name = this.constructor.name;
        var stats = lumaStats.get("Resource Counts");
        stats.get("".concat(name, "s Active")).decrementCount();
      }
    }, {
      key: "_trackAllocatedMemory",
      value: function _trackAllocatedMemory(bytes) {
        var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.constructor.name;
        var stats = lumaStats.get("Memory Usage");
        stats.get("GPU Memory").addCount(bytes);
        stats.get("".concat(name, " Memory")).addCount(bytes);
        this.byteLength = bytes;
      }
    }, {
      key: "_trackDeallocatedMemory",
      value: function _trackDeallocatedMemory() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.constructor.name;
        var stats = lumaStats.get("Memory Usage");
        stats.get("GPU Memory").subtractCount(this.byteLength);
        stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
        this.byteLength = 0;
      }
    }, {
      key: "handle",
      get: function get2() {
        return this._handle;
      }
    }]);
    return Resource3;
  }();

  // node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/construct.js
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = function() {
    _createClass(Accessor2, null, [{
      key: "getBytesPerElement",
      value: function getBytesPerElement(accessor) {
        var ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT;
      }
    }, {
      key: "getBytesPerVertex",
      value: function getBytesPerVertex(accessor) {
        assert5(accessor.size);
        var ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT * accessor.size;
      }
    }, {
      key: "resolve",
      value: function resolve() {
        for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
          accessors[_key] = arguments[_key];
        }
        return _construct(Accessor2, [DEFAULT_ACCESSOR_VALUES].concat(accessors));
      }
    }]);
    function Accessor2() {
      var _this = this;
      _classCallCheck(this, Accessor2);
      for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        accessors[_key2] = arguments[_key2];
      }
      accessors.forEach(function(accessor) {
        return _this._assign(accessor);
      });
      Object.freeze(this);
    }
    _createClass(Accessor2, [{
      key: "toString",
      value: function toString() {
        return JSON.stringify(this);
      }
    }, {
      key: "_assign",
      value: function _assign() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        props = checkProps("Accessor", props, PROP_CHECKS);
        if (props.type !== void 0) {
          this.type = props.type;
          if (props.type === 5124 || props.type === 5125) {
            this.integer = true;
          }
        }
        if (props.size !== void 0) {
          this.size = props.size;
        }
        if (props.offset !== void 0) {
          this.offset = props.offset;
        }
        if (props.stride !== void 0) {
          this.stride = props.stride;
        }
        if (props.normalized !== void 0) {
          this.normalized = props.normalized;
        }
        if (props.integer !== void 0) {
          this.integer = props.integer;
        }
        if (props.divisor !== void 0) {
          this.divisor = props.divisor;
        }
        if (props.buffer !== void 0) {
          this.buffer = props.buffer;
        }
        if (props.index !== void 0) {
          if (typeof props.index === "boolean") {
            this.index = props.index ? 1 : 0;
          } else {
            this.index = props.index;
          }
        }
        if (props.instanced !== void 0) {
          this.divisor = props.instanced ? 1 : 0;
        }
        if (props.isInstanced !== void 0) {
          this.divisor = props.isInstanced ? 1 : 0;
        }
        return this;
      }
    }, {
      key: "BYTES_PER_ELEMENT",
      get: function get2() {
        return Accessor2.getBytesPerElement(this);
      }
    }, {
      key: "BYTES_PER_VERTEX",
      get: function get2() {
        return Accessor2.getBytesPerVertex(this);
      }
    }]);
    return Accessor2;
  }();

  // node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEBUG_DATA_LENGTH = 10;
  var DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
  };
  var PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
      bytes: "byteLength"
    },
    deprecatedProps: DEPRECATED_PROPS
  };
  var PROP_CHECKS_SET_PROPS = {
    removedProps: DEPRECATED_PROPS
  };
  var Buffer2 = function(_Resource) {
    _inherits(Buffer3, _Resource);
    var _super = _createSuper(Buffer3);
    function Buffer3(gl) {
      var _this;
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Buffer3);
      _this = _super.call(this, gl, props);
      _this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
      _this.target = props.target || (_this.gl.webgl2 ? 36662 : 34962);
      _this.initialize(props);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(Buffer3, [{
      key: "getElementCount",
      value: function getElementCount() {
        var accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
      }
    }, {
      key: "getVertexCount",
      value: function getVertexCount() {
        var accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (ArrayBuffer.isView(props)) {
          props = {
            data: props
          };
        }
        if (Number.isFinite(props)) {
          props = {
            byteLength: props
          };
        }
        props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
        this.usage = props.usage || 35044;
        this.debugData = null;
        this.setAccessor(Object.assign({}, props, props.accessor));
        if (props.data) {
          this._setData(props.data, props.offset, props.byteLength);
        } else {
          this._setByteLength(props.byteLength || 0);
        }
        return this;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
        if ("accessor" in props) {
          this.setAccessor(props.accessor);
        }
        return this;
      }
    }, {
      key: "setAccessor",
      value: function setAccessor(accessor) {
        accessor = Object.assign({}, accessor);
        delete accessor.buffer;
        this.accessor = new Accessor(accessor);
        return this;
      }
    }, {
      key: "reallocate",
      value: function reallocate(byteLength) {
        if (byteLength > this.byteLength) {
          this._setByteLength(byteLength);
          return true;
        }
        this.bytesUsed = byteLength;
        return false;
      }
    }, {
      key: "setData",
      value: function setData(props) {
        return this.initialize(props);
      }
    }, {
      key: "subData",
      value: function subData(props) {
        if (ArrayBuffer.isView(props)) {
          props = {
            data: props
          };
        }
        var _props = props, data = _props.data, _props$offset = _props.offset, offset = _props$offset === void 0 ? 0 : _props$offset, _props$srcOffset = _props.srcOffset, srcOffset = _props$srcOffset === void 0 ? 0 : _props$srcOffset;
        var byteLength = props.byteLength || props.length;
        assert5(data);
        var target = this.gl.webgl2 ? 36663 : this.target;
        this.gl.bindBuffer(target, this.handle);
        if (srcOffset !== 0 || byteLength !== void 0) {
          assertWebGL2Context(this.gl);
          this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
        } else {
          this.gl.bufferSubData(target, offset, data);
        }
        this.gl.bindBuffer(target, null);
        this.debugData = null;
        this._inferType(data);
        return this;
      }
    }, {
      key: "copyData",
      value: function copyData(_ref) {
        var sourceBuffer = _ref.sourceBuffer, _ref$readOffset = _ref.readOffset, readOffset = _ref$readOffset === void 0 ? 0 : _ref$readOffset, _ref$writeOffset = _ref.writeOffset, writeOffset = _ref$writeOffset === void 0 ? 0 : _ref$writeOffset, size = _ref.size;
        var gl = this.gl;
        assertWebGL2Context(gl);
        gl.bindBuffer(36662, sourceBuffer.handle);
        gl.bindBuffer(36663, this.handle);
        gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
        gl.bindBuffer(36662, null);
        gl.bindBuffer(36663, null);
        this.debugData = null;
        return this;
      }
    }, {
      key: "getData",
      value: function getData() {
        var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$dstData = _ref2.dstData, dstData = _ref2$dstData === void 0 ? null : _ref2$dstData, _ref2$srcByteOffset = _ref2.srcByteOffset, srcByteOffset = _ref2$srcByteOffset === void 0 ? 0 : _ref2$srcByteOffset, _ref2$dstOffset = _ref2.dstOffset, dstOffset = _ref2$dstOffset === void 0 ? 0 : _ref2$dstOffset, _ref2$length = _ref2.length, length4 = _ref2$length === void 0 ? 0 : _ref2$length;
        assertWebGL2Context(this.gl);
        var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
          clamped: false
        });
        var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
        var dstElementOffset = dstOffset;
        var dstAvailableElementCount;
        var dstElementCount;
        if (dstData) {
          dstElementCount = dstData.length;
          dstAvailableElementCount = dstElementCount - dstElementOffset;
        } else {
          dstAvailableElementCount = Math.min(sourceAvailableElementCount, length4 || sourceAvailableElementCount);
          dstElementCount = dstElementOffset + dstAvailableElementCount;
        }
        var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
        length4 = length4 || copyElementCount;
        assert5(length4 <= copyElementCount);
        dstData = dstData || new ArrayType(dstElementCount);
        this.gl.bindBuffer(36662, this.handle);
        this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length4);
        this.gl.bindBuffer(36662, null);
        return dstData;
      }
    }, {
      key: "bind",
      value: function bind() {
        var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$target = _ref3.target, target = _ref3$target === void 0 ? this.target : _ref3$target, _ref3$index = _ref3.index, index = _ref3$index === void 0 ? this.accessor && this.accessor.index : _ref3$index, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, size = _ref3.size;
        if (target === 35345 || target === 35982) {
          if (size !== void 0) {
            this.gl.bindBufferRange(target, index, this.handle, offset, size);
          } else {
            assert5(offset === 0);
            this.gl.bindBufferBase(target, index, this.handle);
          }
        } else {
          this.gl.bindBuffer(target, this.handle);
        }
        return this;
      }
    }, {
      key: "unbind",
      value: function unbind() {
        var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$target = _ref4.target, target = _ref4$target === void 0 ? this.target : _ref4$target, _ref4$index = _ref4.index, index = _ref4$index === void 0 ? this.accessor && this.accessor.index : _ref4$index;
        var isIndexedBuffer = target === 35345 || target === 35982;
        if (isIndexedBuffer) {
          this.gl.bindBufferBase(target, index, null);
        } else {
          this.gl.bindBuffer(target, null);
        }
        return this;
      }
    }, {
      key: "getDebugData",
      value: function getDebugData() {
        if (!this.debugData) {
          this.debugData = this.getData({
            length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
          });
          return {
            data: this.debugData,
            changed: true
          };
        }
        return {
          data: this.debugData,
          changed: false
        };
      }
    }, {
      key: "invalidateDebugData",
      value: function invalidateDebugData() {
        this.debugData = null;
      }
    }, {
      key: "_setData",
      value: function _setData(data) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
        assert5(ArrayBuffer.isView(data));
        this._trackDeallocatedMemory();
        var target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, byteLength, this.usage);
        this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        var type = getGLTypeFromTypedArray(data);
        assert5(type);
        this.setAccessor(new Accessor(this.accessor, {
          type
        }));
        return this;
      }
    }, {
      key: "_setByteLength",
      value: function _setByteLength(byteLength) {
        var usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
        assert5(byteLength >= 0);
        this._trackDeallocatedMemory();
        var data = byteLength;
        if (byteLength === 0) {
          data = new Float32Array(0);
        }
        var target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, data, usage);
        this.gl.bindBuffer(target, null);
        this.usage = usage;
        this.debugData = null;
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        return this;
      }
    }, {
      key: "_getTarget",
      value: function _getTarget() {
        return this.gl.webgl2 ? 36663 : this.target;
      }
    }, {
      key: "_getAvailableElementCount",
      value: function _getAvailableElementCount(srcByteOffset) {
        var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
          clamped: false
        });
        var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
        return this.getElementCount() - sourceElementOffset;
      }
    }, {
      key: "_inferType",
      value: function _inferType(data) {
        if (!this.accessor.type) {
          this.setAccessor(new Accessor(this.accessor, {
            type: getGLTypeFromTypedArray(data)
          }));
        }
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createBuffer();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteBuffer(this.handle);
        this._trackDeallocatedMemory();
      }
    }, {
      key: "_getParameter",
      value: function _getParameter(pname) {
        this.gl.bindBuffer(this.target, this.handle);
        var value17 = this.gl.getBufferParameter(this.target, pname);
        this.gl.bindBuffer(this.target, null);
        return value17;
      }
    }, {
      key: "setByteLength",
      value: function setByteLength(byteLength) {
        log.deprecated("setByteLength", "reallocate")();
        return this.reallocate(byteLength);
      }
    }, {
      key: "updateAccessor",
      value: function updateAccessor(opts) {
        log.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
        this.accessor = new Accessor(this.accessor, opts);
        return this;
      }
    }, {
      key: "type",
      get: function get2() {
        log.deprecated("Buffer.type", "Buffer.accessor.type")();
        return this.accessor.type;
      }
    }, {
      key: "bytes",
      get: function get2() {
        log.deprecated("Buffer.bytes", "Buffer.byteLength")();
        return this.byteLength;
      }
    }]);
    return Buffer3;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
  var _TEXTURE_FORMATS;
  var _DATA_FORMAT_CHANNELS;
  var _TYPE_SIZES;
  var TEXTURE_FORMATS = (_TEXTURE_FORMATS = {}, _defineProperty(_TEXTURE_FORMATS, 6407, {
    dataFormat: 6407,
    types: [5121, 33635]
  }), _defineProperty(_TEXTURE_FORMATS, 6408, {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  }), _defineProperty(_TEXTURE_FORMATS, 6406, {
    dataFormat: 6406,
    types: [5121]
  }), _defineProperty(_TEXTURE_FORMATS, 6409, {
    dataFormat: 6409,
    types: [5121]
  }), _defineProperty(_TEXTURE_FORMATS, 6410, {
    dataFormat: 6410,
    types: [5121]
  }), _defineProperty(_TEXTURE_FORMATS, 33326, {
    dataFormat: 6403,
    types: [5126],
    gl2: true
  }), _defineProperty(_TEXTURE_FORMATS, 33328, {
    dataFormat: 33319,
    types: [5126],
    gl2: true
  }), _defineProperty(_TEXTURE_FORMATS, 34837, {
    dataFormat: 6407,
    types: [5126],
    gl2: true
  }), _defineProperty(_TEXTURE_FORMATS, 34836, {
    dataFormat: 6408,
    types: [5126],
    gl2: true
  }), _TEXTURE_FORMATS);
  var DATA_FORMAT_CHANNELS = (_DATA_FORMAT_CHANNELS = {}, _defineProperty(_DATA_FORMAT_CHANNELS, 6403, 1), _defineProperty(_DATA_FORMAT_CHANNELS, 36244, 1), _defineProperty(_DATA_FORMAT_CHANNELS, 33319, 2), _defineProperty(_DATA_FORMAT_CHANNELS, 33320, 2), _defineProperty(_DATA_FORMAT_CHANNELS, 6407, 3), _defineProperty(_DATA_FORMAT_CHANNELS, 36248, 3), _defineProperty(_DATA_FORMAT_CHANNELS, 6408, 4), _defineProperty(_DATA_FORMAT_CHANNELS, 36249, 4), _defineProperty(_DATA_FORMAT_CHANNELS, 6402, 1), _defineProperty(_DATA_FORMAT_CHANNELS, 34041, 1), _defineProperty(_DATA_FORMAT_CHANNELS, 6406, 1), _defineProperty(_DATA_FORMAT_CHANNELS, 6409, 1), _defineProperty(_DATA_FORMAT_CHANNELS, 6410, 2), _DATA_FORMAT_CHANNELS);
  var TYPE_SIZES = (_TYPE_SIZES = {}, _defineProperty(_TYPE_SIZES, 5126, 4), _defineProperty(_TYPE_SIZES, 5125, 4), _defineProperty(_TYPE_SIZES, 5124, 4), _defineProperty(_TYPE_SIZES, 5123, 2), _defineProperty(_TYPE_SIZES, 5122, 2), _defineProperty(_TYPE_SIZES, 5131, 2), _defineProperty(_TYPE_SIZES, 5120, 1), _defineProperty(_TYPE_SIZES, 5121, 1), _TYPE_SIZES);
  function isFormatSupported(gl, format) {
    var info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl1 === void 0 && info.gl2 === void 0) {
      return true;
    }
    var value17 = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value17 === "string" ? gl.getExtension(value17) : value17;
  }
  function isLinearFilteringSupported(gl, format) {
    var info = TEXTURE_FORMATS[format];
    switch (info && info.types[0]) {
      case 5126:
        return gl.getExtension("OES_texture_float_linear");
      case 5131:
        return gl.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  function _createForOfIteratorHelper10(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray11(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray11(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray11(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray11(o, minLen);
  }
  function _arrayLikeToArray11(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct3();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct3() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var NPOT_MIN_FILTERS = [9729, 9728];
  var WebGLBuffer = import_env5.global.WebGLBuffer || function WebGLBuffer2() {
  };
  var Texture = function(_Resource) {
    _inherits(Texture2, _Resource);
    var _super = _createSuper2(Texture2);
    _createClass(Texture2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var format = opts.format, linearFiltering = opts.linearFiltering;
        var supported = true;
        if (format) {
          supported = supported && isFormatSupported(gl, format);
          supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
        }
        return supported;
      }
    }]);
    function Texture2(gl, props) {
      var _this;
      _classCallCheck(this, Texture2);
      var _props$id = props.id, id = _props$id === void 0 ? uid("texture") : _props$id, handle = props.handle, target = props.target;
      _this = _super.call(this, gl, {
        id,
        handle
      });
      _this.target = target;
      _this.textureUnit = void 0;
      _this.loaded = false;
      _this.width = void 0;
      _this.height = void 0;
      _this.depth = void 0;
      _this.format = void 0;
      _this.type = void 0;
      _this.dataFormat = void 0;
      _this.border = void 0;
      _this.textureUnit = void 0;
      _this.mipmaps = void 0;
      return _this;
    }
    _createClass(Texture2, [{
      key: "toString",
      value: function toString() {
        return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var _this2 = this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var data = props.data;
        if (data instanceof Promise) {
          data.then(function(resolvedImageData) {
            return _this2.initialize(Object.assign({}, props, {
              pixels: resolvedImageData,
              data: resolvedImageData
            }));
          });
          return this;
        }
        var isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
        if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
          this._video = null;
          data.addEventListener("loadeddata", function() {
            return _this2.initialize(props);
          });
          return this;
        }
        var _props$pixels = props.pixels, pixels = _props$pixels === void 0 ? null : _props$pixels, _props$format = props.format, format = _props$format === void 0 ? 6408 : _props$format, _props$border = props.border, border = _props$border === void 0 ? 0 : _props$border, _props$recreate = props.recreate, recreate = _props$recreate === void 0 ? false : _props$recreate, _props$parameters = props.parameters, parameters = _props$parameters === void 0 ? {} : _props$parameters, _props$pixelStore = props.pixelStore, pixelStore = _props$pixelStore === void 0 ? {} : _props$pixelStore, _props$textureUnit = props.textureUnit, textureUnit = _props$textureUnit === void 0 ? void 0 : _props$textureUnit;
        if (!data) {
          data = pixels;
        }
        var width = props.width, height = props.height, dataFormat = props.dataFormat, type = props.type, _props$compressed = props.compressed, compressed = _props$compressed === void 0 ? false : _props$compressed, _props$mipmaps = props.mipmaps, mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps;
        var _props$depth = props.depth, depth = _props$depth === void 0 ? 0 : _props$depth;
        var _this$_deduceParamete = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        });
        width = _this$_deduceParamete.width;
        height = _this$_deduceParamete.height;
        compressed = _this$_deduceParamete.compressed;
        dataFormat = _this$_deduceParamete.dataFormat;
        type = _this$_deduceParamete.type;
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.format = format;
        this.type = type;
        this.dataFormat = dataFormat;
        this.border = border;
        this.textureUnit = textureUnit;
        if (Number.isFinite(this.textureUnit)) {
          this.gl.activeTexture(33984 + this.textureUnit);
          this.gl.bindTexture(this.target, this.handle);
        }
        if (mipmaps && this._isNPOT()) {
          log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
          mipmaps = false;
          this._updateForNPOT(parameters);
        }
        this.mipmaps = mipmaps;
        this.setImageData({
          data,
          width,
          height,
          depth,
          format,
          type,
          dataFormat,
          border,
          mipmaps,
          parameters: pixelStore,
          compressed
        });
        if (mipmaps) {
          this.generateMipmap();
        }
        this.setParameters(parameters);
        if (recreate) {
          this.data = data;
        }
        if (isVideo) {
          this._video = {
            video: data,
            parameters,
            lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
          };
        }
        return this;
      }
    }, {
      key: "update",
      value: function update3() {
        if (this._video) {
          var _this$_video = this._video, video = _this$_video.video, parameters = _this$_video.parameters, lastTime = _this$_video.lastTime;
          if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
            return;
          }
          this.setSubImageData({
            data: video,
            parameters
          });
          if (this.mipmaps) {
            this.generateMipmap();
          }
          this._video.lastTime = video.currentTime;
        }
      }
    }, {
      key: "resize",
      value: function resize(_ref) {
        var height = _ref.height, width = _ref.width, _ref$mipmaps = _ref.mipmaps, mipmaps = _ref$mipmaps === void 0 ? false : _ref$mipmaps;
        if (width !== this.width || height !== this.height) {
          return this.initialize({
            width,
            height,
            format: this.format,
            type: this.type,
            dataFormat: this.dataFormat,
            border: this.border,
            mipmaps
          });
        }
        return this;
      }
    }, {
      key: "generateMipmap",
      value: function generateMipmap() {
        var _this3 = this;
        var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._isNPOT()) {
          log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
          return this;
        }
        this.mipmaps = true;
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, params, function() {
          _this3.gl.generateMipmap(_this3.target);
        });
        this.gl.bindTexture(this.target, null);
        return this;
      }
    }, {
      key: "setImageData",
      value: function setImageData(options) {
        this._trackDeallocatedMemory("Texture");
        var _options$target = options.target, target = _options$target === void 0 ? this.target : _options$target, _options$pixels = options.pixels, pixels = _options$pixels === void 0 ? null : _options$pixels, _options$level = options.level, level = _options$level === void 0 ? 0 : _options$level, _options$format = options.format, format = _options$format === void 0 ? this.format : _options$format, _options$border = options.border, border = _options$border === void 0 ? this.border : _options$border, _options$offset = options.offset, offset = _options$offset === void 0 ? 0 : _options$offset, _options$parameters = options.parameters, parameters = _options$parameters === void 0 ? {} : _options$parameters;
        var _options$data = options.data, data = _options$data === void 0 ? null : _options$data, _options$type = options.type, type = _options$type === void 0 ? this.type : _options$type, _options$width = options.width, width = _options$width === void 0 ? this.width : _options$width, _options$height = options.height, height = _options$height === void 0 ? this.height : _options$height, _options$dataFormat = options.dataFormat, dataFormat = _options$dataFormat === void 0 ? this.dataFormat : _options$dataFormat, _options$compressed = options.compressed, compressed = _options$compressed === void 0 ? false : _options$compressed;
        if (!data) {
          data = pixels;
        }
        var _this$_deduceParamete2 = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        });
        type = _this$_deduceParamete2.type;
        dataFormat = _this$_deduceParamete2.dataFormat;
        compressed = _this$_deduceParamete2.compressed;
        width = _this$_deduceParamete2.width;
        height = _this$_deduceParamete2.height;
        var gl = this.gl;
        gl.bindTexture(this.target, this.handle);
        var dataType = null;
        var _this$_getDataType = this._getDataType({
          data,
          compressed
        });
        data = _this$_getDataType.data;
        dataType = _this$_getDataType.dataType;
        var gl2;
        withParameters(this.gl, parameters, function() {
          switch (dataType) {
            case "null":
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
              break;
            case "typed-array":
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
              break;
            case "buffer":
              gl2 = assertWebGL2Context(gl);
              gl2.bindBuffer(35052, data.handle || data);
              gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
              gl2.bindBuffer(35052, null);
              break;
            case "browser-object":
              if (isWebGL2(gl)) {
                gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
              } else {
                gl.texImage2D(target, level, format, dataFormat, type, data);
              }
              break;
            case "compressed":
              var _iterator = _createForOfIteratorHelper10(data.entries()), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var _step$value = _slicedToArray(_step.value, 2), levelIndex = _step$value[0], levelData = _step$value[1];
                  gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              break;
            default:
              assert5(false, "Unknown image data type");
          }
        });
        if (data && data.byteLength) {
          this._trackAllocatedMemory(data.byteLength, "Texture");
        } else {
          var channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
          var channelSize = TYPE_SIZES[this.type] || 1;
          this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
      }
    }, {
      key: "setSubImageData",
      value: function setSubImageData(_ref2) {
        var _this4 = this;
        var _ref2$target = _ref2.target, target = _ref2$target === void 0 ? this.target : _ref2$target, _ref2$pixels = _ref2.pixels, pixels = _ref2$pixels === void 0 ? null : _ref2$pixels, _ref2$data = _ref2.data, data = _ref2$data === void 0 ? null : _ref2$data, _ref2$x = _ref2.x, x = _ref2$x === void 0 ? 0 : _ref2$x, _ref2$y = _ref2.y, y = _ref2$y === void 0 ? 0 : _ref2$y, _ref2$width = _ref2.width, width = _ref2$width === void 0 ? this.width : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? this.height : _ref2$height, _ref2$level = _ref2.level, level = _ref2$level === void 0 ? 0 : _ref2$level, _ref2$format = _ref2.format, format = _ref2$format === void 0 ? this.format : _ref2$format, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? this.type : _ref2$type, _ref2$dataFormat = _ref2.dataFormat, dataFormat = _ref2$dataFormat === void 0 ? this.dataFormat : _ref2$dataFormat, _ref2$compressed = _ref2.compressed, compressed = _ref2$compressed === void 0 ? false : _ref2$compressed, _ref2$offset = _ref2.offset, offset = _ref2$offset === void 0 ? 0 : _ref2$offset, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? this.border : _ref2$border, _ref2$parameters = _ref2.parameters, parameters = _ref2$parameters === void 0 ? {} : _ref2$parameters;
        var _this$_deduceParamete3 = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        });
        type = _this$_deduceParamete3.type;
        dataFormat = _this$_deduceParamete3.dataFormat;
        compressed = _this$_deduceParamete3.compressed;
        width = _this$_deduceParamete3.width;
        height = _this$_deduceParamete3.height;
        assert5(this.depth === 0, "texSubImage not supported for 3D textures");
        if (!data) {
          data = pixels;
        }
        if (data && data.data) {
          var ndarray = data;
          data = ndarray.data;
          width = ndarray.shape[0];
          height = ndarray.shape[1];
        }
        if (data instanceof Buffer2) {
          data = data.handle;
        }
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, parameters, function() {
          if (compressed) {
            _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
          } else if (data === null) {
            _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
          } else if (ArrayBuffer.isView(data)) {
            _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
          } else if (data instanceof WebGLBuffer) {
            var gl2 = assertWebGL2Context(_this4.gl);
            gl2.bindBuffer(35052, data);
            gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
          } else if (isWebGL2(_this4.gl)) {
            var _gl = assertWebGL2Context(_this4.gl);
            _gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
          } else {
            _this4.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
          }
        });
        this.gl.bindTexture(this.target, null);
      }
    }, {
      key: "copyFramebuffer",
      value: function copyFramebuffer() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
      }
    }, {
      key: "getActiveUnit",
      value: function getActiveUnit() {
        return this.gl.getParameter(34016) - 33984;
      }
    }, {
      key: "bind",
      value: function bind() {
        var textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
        var gl = this.gl;
        if (textureUnit !== void 0) {
          this.textureUnit = textureUnit;
          gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, this.handle);
        return textureUnit;
      }
    }, {
      key: "unbind",
      value: function unbind() {
        var textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
        var gl = this.gl;
        if (textureUnit !== void 0) {
          this.textureUnit = textureUnit;
          gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, null);
        return textureUnit;
      }
    }, {
      key: "_getDataType",
      value: function _getDataType(_ref3) {
        var data = _ref3.data, _ref3$compressed = _ref3.compressed, compressed = _ref3$compressed === void 0 ? false : _ref3$compressed;
        if (compressed) {
          return {
            data,
            dataType: "compressed"
          };
        }
        if (data === null) {
          return {
            data,
            dataType: "null"
          };
        }
        if (ArrayBuffer.isView(data)) {
          return {
            data,
            dataType: "typed-array"
          };
        }
        if (data instanceof Buffer2) {
          return {
            data: data.handle,
            dataType: "buffer"
          };
        }
        if (data instanceof WebGLBuffer) {
          return {
            data,
            dataType: "buffer"
          };
        }
        return {
          data,
          dataType: "browser-object"
        };
      }
    }, {
      key: "_deduceParameters",
      value: function _deduceParameters(opts) {
        var format = opts.format, data = opts.data;
        var width = opts.width, height = opts.height, dataFormat = opts.dataFormat, type = opts.type, compressed = opts.compressed;
        var textureFormat = TEXTURE_FORMATS[format];
        dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
        type = type || textureFormat && textureFormat.types[0];
        compressed = compressed || textureFormat && textureFormat.compressed;
        var _this$_deduceImageSiz = this._deduceImageSize(data, width, height);
        width = _this$_deduceImageSiz.width;
        height = _this$_deduceImageSiz.height;
        return {
          dataFormat,
          type,
          compressed,
          width,
          height,
          format,
          data
        };
      }
    }, {
      key: "_deduceImageSize",
      value: function _deduceImageSize(data, width, height) {
        var size;
        if (typeof ImageData !== "undefined" && data instanceof ImageData) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
          size = {
            width: data.naturalWidth,
            height: data.naturalHeight
          };
        } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
          size = {
            width: data.videoWidth,
            height: data.videoHeight
          };
        } else if (!data) {
          size = {
            width: width >= 0 ? width : 1,
            height: height >= 0 ? height : 1
          };
        } else {
          size = {
            width,
            height
          };
        }
        assert5(size, "Could not deduced texture size");
        assert5(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
        assert5(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
        return size;
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createTexture();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteTexture(this.handle);
        this._trackDeallocatedMemory("Texture");
      }
    }, {
      key: "_getParameter",
      value: function _getParameter(pname) {
        switch (pname) {
          case 4096:
            return this.width;
          case 4097:
            return this.height;
          default:
            this.gl.bindTexture(this.target, this.handle);
            var value17 = this.gl.getTexParameter(this.target, pname);
            this.gl.bindTexture(this.target, null);
            return value17;
        }
      }
    }, {
      key: "_setParameter",
      value: function _setParameter(pname, param2) {
        this.gl.bindTexture(this.target, this.handle);
        param2 = this._getNPOTParam(pname, param2);
        switch (pname) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.handle, pname, param2);
            break;
          case 4096:
          case 4097:
            assert5(false);
            break;
          default:
            this.gl.texParameteri(this.target, pname, param2);
            break;
        }
        this.gl.bindTexture(this.target, null);
        return this;
      }
    }, {
      key: "_isNPOT",
      value: function _isNPOT() {
        if (isWebGL2(this.gl)) {
          return false;
        }
        if (!this.width || !this.height) {
          return false;
        }
        return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
      }
    }, {
      key: "_updateForNPOT",
      value: function _updateForNPOT(parameters) {
        if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
          parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
        }
        if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
          parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
        }
        if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
          parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
        }
      }
    }, {
      key: "_getNPOTParam",
      value: function _getNPOTParam(pname, param2) {
        if (this._isNPOT()) {
          switch (pname) {
            case 10241:
              if (NPOT_MIN_FILTERS.indexOf(param2) === -1) {
                param2 = 9729;
              }
              break;
            case 10242:
            case 10243:
              if (param2 !== 33071) {
                param2 = 33071;
              }
              break;
            default:
              break;
          }
        }
        return param2;
      }
    }]);
    return Texture2;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
  var pathPrefix2 = "";
  function loadImage2(url, opts) {
    assert5(typeof url === "string");
    url = pathPrefix2 + url;
    return new Promise(function(resolve, reject) {
      try {
        var image = new Image();
        image.onload = function() {
          return resolve(image);
        };
        image.onerror = function() {
          return reject(new Error("Could not load image ".concat(url, ".")));
        };
        image.crossOrigin = opts && opts.crossOrigin || "anonymous";
        image.src = url;
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
  function _createSuper3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct4();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct4() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Texture2D = function(_Texture) {
    _inherits(Texture2D2, _Texture);
    var _super = _createSuper3(Texture2D2);
    _createClass(Texture2D2, null, [{
      key: "isSupported",
      value: function isSupported(gl, opts) {
        return Texture.isSupported(gl, opts);
      }
    }]);
    function Texture2D2(gl) {
      var _this;
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Texture2D2);
      assertWebGLContext(gl);
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      if (typeof props.data === "string") {
        props = Object.assign({}, props, {
          data: loadImage2(props.data)
        });
      }
      _this = _super.call(this, gl, Object.assign({}, props, {
        target: 3553
      }));
      _this.initialize(props);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    return Texture2D2;
  }(Texture);

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
  var import_regenerator23 = __toModule(require_regenerator());
  function _createSuper4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct5();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct5() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var FACES = [34069, 34070, 34071, 34072, 34073, 34074];
  var TextureCube = function(_Texture) {
    _inherits(TextureCube2, _Texture);
    var _super = _createSuper4(TextureCube2);
    function TextureCube2(gl) {
      var _this;
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, TextureCube2);
      assertWebGLContext(gl);
      _this = _super.call(this, gl, Object.assign({}, props, {
        target: 34067
      }));
      _this.initialize(props);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(TextureCube2, [{
      key: "initialize",
      value: function initialize() {
        var _this2 = this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _props$mipmaps = props.mipmaps, mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps, _props$parameters = props.parameters, parameters = _props$parameters === void 0 ? {} : _props$parameters;
        this.opts = props;
        this.setCubeMapImageData(props).then(function() {
          _this2.loaded = true;
          if (mipmaps) {
            _this2.generateMipmap(props);
          }
          _this2.setParameters(parameters);
        });
        return this;
      }
    }, {
      key: "subImage",
      value: function subImage(_ref) {
        var face = _ref.face, data = _ref.data, _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y, _ref$mipmapLevel = _ref.mipmapLevel, mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;
        return this._subImage({
          target: face,
          data,
          x,
          y,
          mipmapLevel
        });
      }
    }, {
      key: "setCubeMapImageData",
      value: function() {
        var _setCubeMapImageData = _asyncToGenerator(import_regenerator23.default.mark(function _callee(_ref2) {
          var _this3 = this;
          var width, height, pixels, data, _ref2$border, border, _ref2$format, format, _ref2$type, type, gl, imageDataMap, resolvedFaces;
          return import_regenerator23.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  width = _ref2.width, height = _ref2.height, pixels = _ref2.pixels, data = _ref2.data, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? 0 : _ref2$border, _ref2$format = _ref2.format, format = _ref2$format === void 0 ? 6408 : _ref2$format, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 5121 : _ref2$type;
                  gl = this.gl;
                  imageDataMap = pixels || data;
                  _context.next = 5;
                  return Promise.all(FACES.map(function(face) {
                    var facePixels = imageDataMap[face];
                    return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
                  }));
                case 5:
                  resolvedFaces = _context.sent;
                  this.bind();
                  FACES.forEach(function(face, index) {
                    if (resolvedFaces[index].length > 1 && _this3.opts.mipmaps !== false) {
                      log.warn("".concat(_this3.id, " has mipmap and multiple LODs."))();
                    }
                    resolvedFaces[index].forEach(function(image, lodLevel) {
                      if (width && height) {
                        gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
                      } else {
                        gl.texImage2D(face, lodLevel, format, format, type, image);
                      }
                    });
                  });
                  this.unbind();
                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function setCubeMapImageData(_x) {
          return _setCubeMapImageData.apply(this, arguments);
        }
        return setCubeMapImageData;
      }()
    }, {
      key: "setImageDataForFace",
      value: function setImageDataForFace(options) {
        var _this4 = this;
        var face = options.face, width = options.width, height = options.height, pixels = options.pixels, data = options.data, _options$border = options.border, border = _options$border === void 0 ? 0 : _options$border, _options$format = options.format, format = _options$format === void 0 ? 6408 : _options$format, _options$type = options.type, type = _options$type === void 0 ? 5121 : _options$type;
        var gl = this.gl;
        var imageData = pixels || data;
        this.bind();
        if (imageData instanceof Promise) {
          imageData.then(function(resolvedImageData) {
            return _this4.setImageDataForFace(Object.assign({}, options, {
              face,
              data: resolvedImageData,
              pixels: resolvedImageData
            }));
          });
        } else if (this.width || this.height) {
          gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
        } else {
          gl.texImage2D(face, 0, format, format, type, imageData);
        }
        return this;
      }
    }]);
    return TextureCube2;
  }(Texture);
  TextureCube.FACES = FACES;

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
  function _createSuper5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct6();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct6() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Texture3D = function(_Texture) {
    _inherits(Texture3D2, _Texture);
    var _super = _createSuper5(Texture3D2);
    _createClass(Texture3D2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        return isWebGL2(gl);
      }
    }]);
    function Texture3D2(gl) {
      var _this;
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Texture3D2);
      assertWebGL2Context(gl);
      props = Object.assign({
        depth: 1
      }, props, {
        target: 32879,
        unpackFlipY: false
      });
      _this = _super.call(this, gl, props);
      _this.initialize(props);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(Texture3D2, [{
      key: "setImageData",
      value: function setImageData(_ref) {
        var _this2 = this;
        var _ref$level = _ref.level, level = _ref$level === void 0 ? 0 : _ref$level, _ref$dataFormat = _ref.dataFormat, dataFormat = _ref$dataFormat === void 0 ? 6408 : _ref$dataFormat, width = _ref.width, height = _ref.height, _ref$depth = _ref.depth, depth = _ref$depth === void 0 ? 1 : _ref$depth, _ref$border = _ref.border, border = _ref$border === void 0 ? 0 : _ref$border, format = _ref.format, _ref$type = _ref.type, type = _ref$type === void 0 ? 5121 : _ref$type, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset, data = _ref.data, _ref$parameters = _ref.parameters, parameters = _ref$parameters === void 0 ? {} : _ref$parameters;
        this._trackDeallocatedMemory("Texture");
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, parameters, function() {
          if (ArrayBuffer.isView(data)) {
            _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, data);
          }
          if (data instanceof Buffer2) {
            _this2.gl.bindBuffer(35052, data.handle);
            _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, offset);
          }
        });
        if (data && data.byteLength) {
          this._trackAllocatedMemory(data.byteLength, "Texture");
        } else {
          var channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
          var channelSize = TYPE_SIZES[this.type] || 1;
          this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
      }
    }]);
    return Texture3D2;
  }(Texture);

  // node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
  var _$33190$36012$;
  var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
  var renderbuffer_formats_default = (_$33190$36012$ = {}, _defineProperty(_$33190$36012$, 33189, {
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33190, {
    gl2: true,
    bpp: 3
  }), _defineProperty(_$33190$36012$, 36012, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 36168, {
    bpp: 1
  }), _defineProperty(_$33190$36012$, 34041, {
    bpp: 4
  }), _defineProperty(_$33190$36012$, 35056, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 36013, {
    gl2: true,
    bpp: 5
  }), _defineProperty(_$33190$36012$, 32854, {
    bpp: 2
  }), _defineProperty(_$33190$36012$, 36194, {
    bpp: 2
  }), _defineProperty(_$33190$36012$, 32855, {
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33321, {
    gl2: true,
    bpp: 1
  }), _defineProperty(_$33190$36012$, 33330, {
    gl2: true,
    bpp: 1
  }), _defineProperty(_$33190$36012$, 33329, {
    gl2: true,
    bpp: 1
  }), _defineProperty(_$33190$36012$, 33332, {
    gl2: true,
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33331, {
    gl2: true,
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33334, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 33333, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 33323, {
    gl2: true,
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33336, {
    gl2: true,
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33335, {
    gl2: true,
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33338, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 33337, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 33340, {
    gl2: true,
    bpp: 8
  }), _defineProperty(_$33190$36012$, 33339, {
    gl2: true,
    bpp: 8
  }), _defineProperty(_$33190$36012$, 32849, {
    gl2: true,
    bpp: 3
  }), _defineProperty(_$33190$36012$, 32856, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 32857, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 36220, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 36238, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 36975, {
    gl2: true,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 36214, {
    gl2: true,
    bpp: 8
  }), _defineProperty(_$33190$36012$, 36232, {
    gl2: true,
    bpp: 8
  }), _defineProperty(_$33190$36012$, 36226, {
    gl2: true,
    bpp: 16
  }), _defineProperty(_$33190$36012$, 36208, {
    gl2: true,
    bpp: 16
  }), _defineProperty(_$33190$36012$, 33325, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 2
  }), _defineProperty(_$33190$36012$, 33327, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 34842, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  }), _defineProperty(_$33190$36012$, 33326, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }), _defineProperty(_$33190$36012$, 33328, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  }), _defineProperty(_$33190$36012$, 34836, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 16
  }), _defineProperty(_$33190$36012$, 35898, {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }), _$33190$36012$);

  // node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
  function _createSuper6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct7();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct7() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function isFormatSupported2(gl, format, formats) {
    var info = formats[format];
    if (!info) {
      return false;
    }
    var value17 = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value17 === "string") {
      return gl.getExtension(value17);
    }
    return value17;
  }
  var Renderbuffer = function(_Resource) {
    _inherits(Renderbuffer2, _Resource);
    var _super = _createSuper6(Renderbuffer2);
    _createClass(Renderbuffer2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          format: null
        }, format = _ref.format;
        return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
      }
    }, {
      key: "getSamplesForFormat",
      value: function getSamplesForFormat(gl, _ref2) {
        var format = _ref2.format;
        return gl.getInternalformatParameter(36161, format, 32937);
      }
    }]);
    function Renderbuffer2(gl) {
      var _this;
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Renderbuffer2);
      _this = _super.call(this, gl, opts);
      _this.initialize(opts);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(Renderbuffer2, [{
      key: "initialize",
      value: function initialize(_ref3) {
        var format = _ref3.format, _ref3$width = _ref3.width, width = _ref3$width === void 0 ? 1 : _ref3$width, _ref3$height = _ref3.height, height = _ref3$height === void 0 ? 1 : _ref3$height, _ref3$samples = _ref3.samples, samples = _ref3$samples === void 0 ? 0 : _ref3$samples;
        assert5(format, "Needs format");
        this._trackDeallocatedMemory();
        this.gl.bindRenderbuffer(36161, this.handle);
        if (samples !== 0 && isWebGL2(this.gl)) {
          this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
        } else {
          this.gl.renderbufferStorage(36161, format, width, height);
        }
        this.format = format;
        this.width = width;
        this.height = height;
        this.samples = samples;
        this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
        return this;
      }
    }, {
      key: "resize",
      value: function resize(_ref4) {
        var width = _ref4.width, height = _ref4.height;
        if (width !== this.width || height !== this.height) {
          return this.initialize({
            width,
            height,
            format: this.format,
            samples: this.samples
          });
        }
        return this;
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createRenderbuffer();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteRenderbuffer(this.handle);
        this._trackDeallocatedMemory();
      }
    }, {
      key: "_bindHandle",
      value: function _bindHandle(handle) {
        this.gl.bindRenderbuffer(36161, handle);
      }
    }, {
      key: "_syncHandle",
      value: function _syncHandle(handle) {
        this.format = this.getParameter(36164);
        this.width = this.getParameter(36162);
        this.height = this.getParameter(36163);
        this.samples = this.getParameter(36011);
      }
    }, {
      key: "_getParameter",
      value: function _getParameter(pname) {
        this.gl.bindRenderbuffer(36161, this.handle);
        var value17 = this.gl.getRenderbufferParameter(36161, pname);
        return value17;
      }
    }]);
    return Renderbuffer2;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var GL_DEPTH = 6145;
  var GL_STENCIL = 6146;
  var GL_DEPTH_STENCIL = 34041;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$framebuffer = _ref.framebuffer, framebuffer2 = _ref$framebuffer === void 0 ? null : _ref$framebuffer, _ref$color = _ref.color, color = _ref$color === void 0 ? null : _ref$color, _ref$depth = _ref.depth, depth = _ref$depth === void 0 ? null : _ref$depth, _ref$stencil = _ref.stencil, stencil = _ref$stencil === void 0 ? null : _ref$stencil;
    var parameters = {};
    if (framebuffer2) {
      parameters.framebuffer = framebuffer2;
    }
    var clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    assert5(clearFlags !== 0, ERR_ARGUMENTS);
    withParameters(gl, parameters, function() {
      gl.clear(clearFlags);
    });
  }
  function clearBuffer(gl) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$framebuffer = _ref2.framebuffer, framebuffer2 = _ref2$framebuffer === void 0 ? null : _ref2$framebuffer, _ref2$buffer = _ref2.buffer, buffer = _ref2$buffer === void 0 ? GL_COLOR : _ref2$buffer, _ref2$drawBuffer = _ref2.drawBuffer, drawBuffer = _ref2$drawBuffer === void 0 ? 0 : _ref2$drawBuffer, _ref2$value = _ref2.value, value17 = _ref2$value === void 0 ? [0, 0, 0, 0] : _ref2$value;
    assertWebGL2Context(gl);
    withParameters(gl, {
      framebuffer: framebuffer2
    }, function() {
      switch (buffer) {
        case GL_COLOR:
          switch (value17.constructor) {
            case Int32Array:
              gl.clearBufferiv(buffer, drawBuffer, value17);
              break;
            case Uint32Array:
              gl.clearBufferuiv(buffer, drawBuffer, value17);
              break;
            case Float32Array:
            default:
              gl.clearBufferfv(buffer, drawBuffer, value17);
          }
          break;
        case GL_DEPTH:
          gl.clearBufferfv(GL_DEPTH, 0, [value17]);
          break;
        case GL_STENCIL:
          gl.clearBufferiv(GL_STENCIL, 0, [value17]);
          break;
        case GL_DEPTH_STENCIL:
          var _value = _slicedToArray(value17, 2), depth = _value[0], stencil = _value[1];
          gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
          break;
        default:
          assert5(false, ERR_ARGUMENTS);
      }
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert5(false);
        return 0;
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
  function readPixelsToArray(source) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _options$sourceX = options.sourceX, sourceX = _options$sourceX === void 0 ? 0 : _options$sourceX, _options$sourceY = options.sourceY, sourceY = _options$sourceY === void 0 ? 0 : _options$sourceY, _options$sourceFormat = options.sourceFormat, sourceFormat = _options$sourceFormat === void 0 ? 6408 : _options$sourceFormat;
    var _options$sourceAttach = options.sourceAttachment, sourceAttachment = _options$sourceAttach === void 0 ? 36064 : _options$sourceAttach, _options$target = options.target, target = _options$target === void 0 ? null : _options$target, sourceWidth = options.sourceWidth, sourceHeight = options.sourceHeight, sourceType = options.sourceType;
    var _getFramebuffer = getFramebuffer(source), framebuffer2 = _getFramebuffer.framebuffer, deleteFramebuffer = _getFramebuffer.deleteFramebuffer;
    assert5(framebuffer2);
    var gl = framebuffer2.gl, handle = framebuffer2.handle, attachments = framebuffer2.attachments;
    sourceWidth = sourceWidth || framebuffer2.width;
    sourceHeight = sourceHeight || framebuffer2.height;
    if (sourceAttachment === 36064 && handle === null) {
      sourceAttachment = 1028;
    }
    assert5(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    var prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer2["delete"]();
    }
    return target;
  }
  function copyToDataUrl(source) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$sourceAttachmen = _ref2.sourceAttachment, sourceAttachment = _ref2$sourceAttachmen === void 0 ? 36064 : _ref2$sourceAttachmen, _ref2$targetMaxHeight = _ref2.targetMaxHeight, targetMaxHeight = _ref2$targetMaxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref2$targetMaxHeight;
    var data = readPixelsToArray(source, {
      sourceAttachment
    });
    var width = source.width, height = source.height;
    while (height > targetMaxHeight) {
      var _scalePixels = scalePixels2({
        data,
        width,
        height
      });
      data = _scalePixels.data;
      width = _scalePixels.width;
      height = _scalePixels.height;
    }
    flipRows({
      data,
      width,
      height
    });
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext("2d");
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  function copyToTexture(source, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _options$sourceX2 = options.sourceX, sourceX = _options$sourceX2 === void 0 ? 0 : _options$sourceX2, _options$sourceY2 = options.sourceY, sourceY = _options$sourceY2 === void 0 ? 0 : _options$sourceY2, _options$targetMipmap = options.targetMipmaplevel, targetMipmaplevel = _options$targetMipmap === void 0 ? 0 : _options$targetMipmap, _options$targetIntern = options.targetInternalFormat, targetInternalFormat = _options$targetIntern === void 0 ? 6408 : _options$targetIntern;
    var targetX = options.targetX, targetY = options.targetY, targetZ = options.targetZ, width = options.width, height = options.height;
    var _getFramebuffer3 = getFramebuffer(source), framebuffer2 = _getFramebuffer3.framebuffer, deleteFramebuffer = _getFramebuffer3.deleteFramebuffer;
    assert5(framebuffer2);
    var gl = framebuffer2.gl, handle = framebuffer2.handle;
    var isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
    targetX = targetX || 0;
    targetY = targetY || 0;
    targetZ = targetZ || 0;
    var prevHandle = gl.bindFramebuffer(36160, handle);
    assert5(target);
    var texture = null;
    if (target instanceof Texture) {
      texture = target;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture.bind(0);
      target = texture.target;
    }
    if (!isSubCopy) {
      gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
    } else {
      switch (target) {
        case 3553:
        case 34067:
          gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
          break;
        case 35866:
        case 32879:
          var gl2 = assertWebGL2Context(gl);
          gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
          break;
        default:
      }
    }
    if (texture) {
      texture.unbind();
    }
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer2["delete"]();
    }
    return texture;
  }
  function getFramebuffer(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    var ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    var components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
  var _FEATURES$WEBGL2$FEAT;
  var FEATURES = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
  };
  function checkFloat32ColorAttachment(gl) {
    var testTexture = new Texture2D(gl, {
      format: 6408,
      type: 5126,
      dataFormat: 6408
    });
    var testFb = new Framebuffer(gl, {
      id: "test-framebuffer",
      check: false,
      attachments: _defineProperty({}, 36064, testTexture)
    });
    var status = testFb.getStatus();
    testTexture["delete"]();
    testFb["delete"]();
    return status === 36053;
  }
  var webgl_features_table_default = (_FEATURES$WEBGL2$FEAT = {}, _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.WEBGL2, [false, true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.VERTEX_ARRAY_OBJECT, ["OES_vertex_array_object", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TIMER_QUERY, ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.INSTANCED_RENDERING, ["ANGLE_instanced_arrays", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.MULTIPLE_RENDER_TARGETS, ["WEBGL_draw_buffers", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.ELEMENT_INDEX_UINT32, ["OES_element_index_uint", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.BLEND_EQUATION_MINMAX, ["EXT_blend_minmax", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.FLOAT_BLEND, ["EXT_float_blend"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ENCODING_SRGB, ["EXT_sRGB", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_DEPTH, ["WEBGL_depth_texture", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FLOAT, ["OES_texture_float", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_HALF_FLOAT, ["OES_texture_half_float", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_LINEAR_FLOAT, ["OES_texture_float_linear"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT, ["OES_texture_half_float_linear"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_ANISOTROPIC, ["EXT_texture_filter_anisotropic"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_RGBA32F, [checkFloat32ColorAttachment, "EXT_color_buffer_float"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_FLOAT, [false, "EXT_color_buffer_float"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_HALF_FLOAT, ["EXT_color_buffer_half_float"]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_FRAG_DATA, ["WEBGL_draw_buffers", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_FRAG_DEPTH, ["EXT_frag_depth", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_DERIVATIVES, ["OES_standard_derivatives", true]), _defineProperty(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_TEXTURE_LOD, ["EXT_shader_texture_lod", true]), _FEATURES$WEBGL2$FEAT);

  // node_modules/@luma.gl/webgl/dist/esm/features/features.js
  function _createForOfIteratorHelper11(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray12(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray12(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray12(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray12(o, minLen);
  }
  function _arrayLikeToArray12(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var LOG_UNSUPPORTED_FEATURE = 2;
  function hasFeature(gl, feature) {
    return hasFeatures(gl, feature);
  }
  function hasFeatures(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every(function(feature) {
      return isFeatureSupported(gl, feature);
    });
  }
  function getFeatures(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for (var cap in webgl_features_table_default) {
      if (gl.luma.caps[cap] === void 0) {
        gl.luma.caps[cap] = isFeatureSupported(gl, cap);
      }
    }
    return gl.luma.caps;
  }
  function isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = queryFeature(gl, cap);
    }
    if (!gl.luma.caps[cap]) {
      log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    }
    return gl.luma.caps[cap];
  }
  function queryFeature(gl, cap) {
    var feature = webgl_features_table_default[cap];
    assert5(feature, cap);
    var isSupported;
    var featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") {
      isSupported = featureDefinition(gl);
    } else if (Array.isArray(featureDefinition)) {
      isSupported = true;
      var _iterator = _createForOfIteratorHelper11(featureDefinition), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var extension = _step.value;
          isSupported = isSupported && Boolean(gl.getExtension(extension));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (typeof featureDefinition === "string") {
      isSupported = Boolean(gl.getExtension(featureDefinition));
    } else if (typeof featureDefinition === "boolean") {
      isSupported = featureDefinition;
    } else {
      assert5(false);
    }
    return isSupported;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
  function _createForOfIteratorHelper12(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray13(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray13(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray13(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray13(o, minLen);
  }
  function _arrayLikeToArray13(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct8();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct8() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
  var Framebuffer = function(_Resource) {
    _inherits(Framebuffer2, _Resource);
    var _super = _createSuper7(Framebuffer2);
    _createClass(Framebuffer2, [{
      key: "MAX_COLOR_ATTACHMENTS",
      get: function get2() {
        var gl2 = assertWebGL2Context(this.gl);
        return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
      }
    }, {
      key: "MAX_DRAW_BUFFERS",
      get: function get2() {
        var gl2 = assertWebGL2Context(this.gl);
        return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
      }
    }], [{
      key: "isSupported",
      value: function isSupported(gl) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var colorBufferFloat = options.colorBufferFloat, colorBufferHalfFloat = options.colorBufferHalfFloat;
        var supported = true;
        if (colorBufferFloat) {
          supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
        }
        if (colorBufferHalfFloat) {
          supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
        }
        return supported;
      }
    }, {
      key: "getDefaultFramebuffer",
      value: function getDefaultFramebuffer(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer2(gl, {
          id: "default-framebuffer",
          handle: null,
          attachments: {}
        });
        return gl.luma.defaultFramebuffer;
      }
    }]);
    function Framebuffer2(gl) {
      var _this;
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Framebuffer2);
      _this = _super.call(this, gl, opts);
      _this.width = null;
      _this.height = null;
      _this.attachments = {};
      _this.readBuffer = 36064;
      _this.drawBuffers = [36064];
      _this.ownResources = [];
      _this.initialize(opts);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(Framebuffer2, [{
      key: "initialize",
      value: function initialize(_ref) {
        var _ref$width = _ref.width, width = _ref$width === void 0 ? 1 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 1 : _ref$height, _ref$attachments = _ref.attachments, attachments = _ref$attachments === void 0 ? null : _ref$attachments, _ref$color = _ref.color, color = _ref$color === void 0 ? true : _ref$color, _ref$depth = _ref.depth, depth = _ref$depth === void 0 ? true : _ref$depth, _ref$stencil = _ref.stencil, stencil = _ref$stencil === void 0 ? false : _ref$stencil, _ref$check = _ref.check, check = _ref$check === void 0 ? true : _ref$check, _ref$readBuffer = _ref.readBuffer, readBuffer2 = _ref$readBuffer === void 0 ? void 0 : _ref$readBuffer, _ref$drawBuffers = _ref.drawBuffers, drawBuffers2 = _ref$drawBuffers === void 0 ? void 0 : _ref$drawBuffers;
        assert5(width >= 0 && height >= 0, "Width and height need to be integers");
        this.width = width;
        this.height = height;
        if (attachments) {
          for (var attachment in attachments) {
            var target = attachments[attachment];
            var object = Array.isArray(target) ? target[0] : target;
            object.resize({
              width,
              height
            });
          }
        } else {
          attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
        }
        this.update({
          clearAttachments: true,
          attachments,
          readBuffer: readBuffer2,
          drawBuffers: drawBuffers2
        });
        if (attachments && check) {
          this.checkStatus();
        }
      }
    }, {
      key: "delete",
      value: function _delete() {
        var _iterator = _createForOfIteratorHelper12(this.ownResources), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var resource = _step.value;
            resource["delete"]();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        _get(_getPrototypeOf(Framebuffer2.prototype), "delete", this).call(this);
        return this;
      }
    }, {
      key: "update",
      value: function update3(_ref2) {
        var _ref2$attachments = _ref2.attachments, attachments = _ref2$attachments === void 0 ? {} : _ref2$attachments, readBuffer2 = _ref2.readBuffer, drawBuffers2 = _ref2.drawBuffers, _ref2$clearAttachment = _ref2.clearAttachments, clearAttachments = _ref2$clearAttachment === void 0 ? false : _ref2$clearAttachment, _ref2$resizeAttachmen = _ref2.resizeAttachments, resizeAttachments = _ref2$resizeAttachmen === void 0 ? true : _ref2$resizeAttachmen;
        this.attach(attachments, {
          clearAttachments,
          resizeAttachments
        });
        var gl = this.gl;
        var prevHandle = gl.bindFramebuffer(36160, this.handle);
        if (readBuffer2) {
          this._setReadBuffer(readBuffer2);
        }
        if (drawBuffers2) {
          this._setDrawBuffers(drawBuffers2);
        }
        gl.bindFramebuffer(36160, prevHandle || null);
        return this;
      }
    }, {
      key: "resize",
      value: function resize() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var width = options.width, height = options.height;
        if (this.handle === null) {
          assert5(width === void 0 && height === void 0);
          this.width = this.gl.drawingBufferWidth;
          this.height = this.gl.drawingBufferHeight;
          return this;
        }
        if (width === void 0) {
          width = this.gl.drawingBufferWidth;
        }
        if (height === void 0) {
          height = this.gl.drawingBufferHeight;
        }
        if (width !== this.width && height !== this.height) {
          log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
        }
        for (var attachmentPoint in this.attachments) {
          this.attachments[attachmentPoint].resize({
            width,
            height
          });
        }
        this.width = width;
        this.height = height;
        return this;
      }
    }, {
      key: "attach",
      value: function attach(attachments) {
        var _this2 = this;
        var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref3$clearAttachment = _ref3.clearAttachments, clearAttachments = _ref3$clearAttachment === void 0 ? false : _ref3$clearAttachment, _ref3$resizeAttachmen = _ref3.resizeAttachments, resizeAttachments = _ref3$resizeAttachmen === void 0 ? true : _ref3$resizeAttachmen;
        var newAttachments = {};
        if (clearAttachments) {
          Object.keys(this.attachments).forEach(function(key2) {
            newAttachments[key2] = null;
          });
        }
        Object.assign(newAttachments, attachments);
        var prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        for (var key in newAttachments) {
          assert5(key !== void 0, "Misspelled framebuffer binding point?");
          var attachment = Number(key);
          var descriptor = newAttachments[attachment];
          var object = descriptor;
          if (!object) {
            this._unattach(attachment);
          } else if (object instanceof Renderbuffer) {
            this._attachRenderbuffer({
              attachment,
              renderbuffer: object
            });
          } else if (Array.isArray(descriptor)) {
            var _descriptor = _slicedToArray(descriptor, 3), texture = _descriptor[0], _descriptor$ = _descriptor[1], layer = _descriptor$ === void 0 ? 0 : _descriptor$, _descriptor$2 = _descriptor[2], level = _descriptor$2 === void 0 ? 0 : _descriptor$2;
            object = texture;
            this._attachTexture({
              attachment,
              texture,
              layer,
              level
            });
          } else {
            this._attachTexture({
              attachment,
              texture: object,
              layer: 0,
              level: 0
            });
          }
          if (resizeAttachments && object) {
            object.resize({
              width: this.width,
              height: this.height
            });
          }
        }
        this.gl.bindFramebuffer(36160, prevHandle || null);
        Object.assign(this.attachments, attachments);
        Object.keys(this.attachments).filter(function(key2) {
          return !_this2.attachments[key2];
        }).forEach(function(key2) {
          delete _this2.attachments[key2];
        });
      }
    }, {
      key: "checkStatus",
      value: function checkStatus() {
        var gl = this.gl;
        var status = this.getStatus();
        if (status !== 36053) {
          throw new Error(_getFrameBufferStatus(status));
        }
        return this;
      }
    }, {
      key: "getStatus",
      value: function getStatus() {
        var gl = this.gl;
        var prevHandle = gl.bindFramebuffer(36160, this.handle);
        var status = gl.checkFramebufferStatus(36160);
        gl.bindFramebuffer(36160, prevHandle || null);
        return status;
      }
    }, {
      key: "clear",
      value: function clear2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var color = options.color, depth = options.depth, stencil = options.stencil, _options$drawBuffers = options.drawBuffers, drawBuffers2 = _options$drawBuffers === void 0 ? [] : _options$drawBuffers;
        var prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        if (color || depth || stencil) {
          clear(this.gl, {
            color,
            depth,
            stencil
          });
        }
        drawBuffers2.forEach(function(value17, drawBuffer) {
          clearBuffer({
            drawBuffer,
            value: value17
          });
        });
        this.gl.bindFramebuffer(36160, prevHandle || null);
        return this;
      }
    }, {
      key: "readPixels",
      value: function readPixels() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
        return null;
      }
    }, {
      key: "readPixelsToBuffer",
      value: function readPixelsToBuffer2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
        return null;
      }
    }, {
      key: "copyToDataUrl",
      value: function copyToDataUrl2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
        return null;
      }
    }, {
      key: "copyToImage",
      value: function copyToImage2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
        return null;
      }
    }, {
      key: "copyToTexture",
      value: function copyToTexture2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
      }
    }, {
      key: "blit",
      value: function blit2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
        return null;
      }
    }, {
      key: "invalidate",
      value: function invalidate(_ref4) {
        var _ref4$attachments = _ref4.attachments, attachments = _ref4$attachments === void 0 ? [] : _ref4$attachments, _ref4$x = _ref4.x, x = _ref4$x === void 0 ? 0 : _ref4$x, _ref4$y = _ref4.y, y = _ref4$y === void 0 ? 0 : _ref4$y, width = _ref4.width, height = _ref4.height;
        var gl2 = assertWebGL2Context(this.gl);
        var prevHandle = gl2.bindFramebuffer(36008, this.handle);
        var invalidateAll = x === 0 && y === 0 && width === void 0 && height === void 0;
        if (invalidateAll) {
          gl2.invalidateFramebuffer(36008, attachments);
        } else {
          gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
        }
        gl2.bindFramebuffer(36008, prevHandle);
        return this;
      }
    }, {
      key: "getAttachmentParameter",
      value: function getAttachmentParameter(attachment, pname, keys) {
        var value17 = this._getAttachmentParameterFallback(pname);
        if (value17 === null) {
          this.gl.bindFramebuffer(36160, this.handle);
          value17 = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
          this.gl.bindFramebuffer(36160, null);
        }
        if (keys && value17 > 1e3) {
          value17 = getKey(this.gl, value17);
        }
        return value17;
      }
    }, {
      key: "getAttachmentParameters",
      value: function getAttachmentParameters() {
        var attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
        var keys = arguments.length > 1 ? arguments[1] : void 0;
        var parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
        var values = {};
        var _iterator2 = _createForOfIteratorHelper12(parameters), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var pname = _step2.value;
            var key = keys ? getKey(this.gl, pname) : pname;
            values[key] = this.getAttachmentParameter(attachment, pname, keys);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return values;
      }
    }, {
      key: "getParameters",
      value: function getParameters2() {
        var keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var attachments = Object.keys(this.attachments);
        var parameters = {};
        for (var _i = 0, _attachments = attachments; _i < _attachments.length; _i++) {
          var attachmentName = _attachments[_i];
          var attachment = Number(attachmentName);
          var key = keys ? getKey(this.gl, attachment) : attachment;
          parameters[key] = this.getAttachmentParameters(attachment, keys);
        }
        return parameters;
      }
    }, {
      key: "show",
      value: function show() {
        if (typeof window !== "undefined") {
          window.open(copyToDataUrl(this), "luma-debug-texture");
        }
        return this;
      }
    }, {
      key: "log",
      value: function log3() {
        var logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (logLevel > log.level || typeof window === "undefined") {
          return this;
        }
        message = message || "Framebuffer ".concat(this.id);
        var image = copyToDataUrl(this, {
          targetMaxHeight: 100
        });
        log.image({
          logLevel,
          message,
          image
        }, message)();
        return this;
      }
    }, {
      key: "bind",
      value: function bind() {
        var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref5$target = _ref5.target, target = _ref5$target === void 0 ? 36160 : _ref5$target;
        this.gl.bindFramebuffer(target, this.handle);
        return this;
      }
    }, {
      key: "unbind",
      value: function unbind() {
        var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref6$target = _ref6.target, target = _ref6$target === void 0 ? 36160 : _ref6$target;
        this.gl.bindFramebuffer(target, null);
        return this;
      }
    }, {
      key: "_createDefaultAttachments",
      value: function _createDefaultAttachments(color, depth, stencil, width, height) {
        var defaultAttachments = null;
        if (color) {
          var _parameters;
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[36064] = new Texture2D(this.gl, {
            id: "".concat(this.id, "-color0"),
            pixels: null,
            format: 6408,
            type: 5121,
            width,
            height,
            mipmaps: false,
            parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9729), _defineProperty(_parameters, 10240, 9729), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters)
          });
          this.ownResources.push(defaultAttachments[36064]);
        }
        if (depth && stencil) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[33306] = new Renderbuffer(this.gl, {
            id: "".concat(this.id, "-depth-stencil"),
            format: 35056,
            width,
            height: 111
          });
          this.ownResources.push(defaultAttachments[33306]);
        } else if (depth) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[36096] = new Renderbuffer(this.gl, {
            id: "".concat(this.id, "-depth"),
            format: 33189,
            width,
            height
          });
          this.ownResources.push(defaultAttachments[36096]);
        } else if (stencil) {
          assert5(false);
        }
        return defaultAttachments;
      }
    }, {
      key: "_unattach",
      value: function _unattach(attachment) {
        var oldAttachment = this.attachments[attachment];
        if (!oldAttachment) {
          return;
        }
        if (oldAttachment instanceof Renderbuffer) {
          this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
        } else {
          this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
        }
        delete this.attachments[attachment];
      }
    }, {
      key: "_attachRenderbuffer",
      value: function _attachRenderbuffer(_ref7) {
        var _ref7$attachment = _ref7.attachment, attachment = _ref7$attachment === void 0 ? 36064 : _ref7$attachment, renderbuffer = _ref7.renderbuffer;
        var gl = this.gl;
        gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
        this.attachments[attachment] = renderbuffer;
      }
    }, {
      key: "_attachTexture",
      value: function _attachTexture(_ref8) {
        var _ref8$attachment = _ref8.attachment, attachment = _ref8$attachment === void 0 ? 36064 : _ref8$attachment, texture = _ref8.texture, layer = _ref8.layer, level = _ref8.level;
        var gl = this.gl;
        gl.bindTexture(texture.target, texture.handle);
        switch (texture.target) {
          case 35866:
          case 32879:
            var gl2 = assertWebGL2Context(gl);
            gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
            break;
          case 34067:
            var face = mapIndexToCubeMapFace(layer);
            gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
            break;
          case 3553:
            gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
            break;
          default:
            assert5(false, "Illegal texture type");
        }
        gl.bindTexture(texture.target, null);
        this.attachments[attachment] = texture;
      }
    }, {
      key: "_setReadBuffer",
      value: function _setReadBuffer(readBuffer2) {
        var gl2 = getWebGL2Context(this.gl);
        if (gl2) {
          gl2.readBuffer(readBuffer2);
        } else {
          assert5(readBuffer2 === 36064 || readBuffer2 === 1029, ERR_MULTIPLE_RENDERTARGETS);
        }
        this.readBuffer = readBuffer2;
      }
    }, {
      key: "_setDrawBuffers",
      value: function _setDrawBuffers(drawBuffers2) {
        var gl = this.gl;
        var gl2 = assertWebGL2Context(gl);
        if (gl2) {
          gl2.drawBuffers(drawBuffers2);
        } else {
          var ext = gl.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ext.drawBuffersWEBGL(drawBuffers2);
          } else {
            assert5(drawBuffers2.length === 1 && (drawBuffers2[0] === 36064 || drawBuffers2[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
          }
        }
        this.drawBuffers = drawBuffers2;
      }
    }, {
      key: "_getAttachmentParameterFallback",
      value: function _getAttachmentParameterFallback(pname) {
        var caps = getFeatures(this.gl);
        switch (pname) {
          case 36052:
            return !caps.WEBGL2 ? 0 : null;
          case 33298:
          case 33299:
          case 33300:
          case 33301:
          case 33302:
          case 33303:
            return !caps.WEBGL2 ? 8 : null;
          case 33297:
            return !caps.WEBGL2 ? 5125 : null;
          case 33296:
            return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
          default:
            return null;
        }
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createFramebuffer();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteFramebuffer(this.handle);
      }
    }, {
      key: "_bindHandle",
      value: function _bindHandle(handle) {
        return this.gl.bindFramebuffer(36160, handle);
      }
    }, {
      key: "color",
      get: function get2() {
        return this.attachments[36064] || null;
      }
    }, {
      key: "texture",
      get: function get2() {
        return this.attachments[36064] || null;
      }
    }, {
      key: "depth",
      get: function get2() {
        return this.attachments[36096] || this.attachments[33306] || null;
      }
    }, {
      key: "stencil",
      get: function get2() {
        return this.attachments[36128] || this.attachments[33306] || null;
      }
    }]);
    return Framebuffer2;
  }(Resource);
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    var STATUS = Framebuffer.STATUS || {};
    return STATUS[status] || "Framebuffer error ".concat(status);
  }
  var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
  function cloneTextureFrom(refTexture, overrides) {
    assert5(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
    var TextureType = refTexture.constructor;
    var gl = refTexture.gl, width = refTexture.width, height = refTexture.height, format = refTexture.format, type = refTexture.type, dataFormat = refTexture.dataFormat, border = refTexture.border, mipmaps = refTexture.mipmaps;
    var textureOptions = Object.assign({
      width,
      height,
      format,
      type,
      dataFormat,
      border,
      mipmaps
    }, overrides);
    return new TextureType(gl, textureOptions);
  }
  function toFramebuffer(texture, opts) {
    var gl = texture.gl, width = texture.width, height = texture.height, id = texture.id;
    var framebuffer2 = new Framebuffer(gl, Object.assign({}, opts, {
      id: "framebuffer-for-".concat(id),
      width,
      height,
      attachments: _defineProperty({}, 36064, texture)
    }));
    return framebuffer2;
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
  function getShaderName(shader) {
    var defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
    var SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    var match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;
  function getShaderTypeName(type) {
    switch (type) {
      case GL_FRAGMENT_SHADER:
        return "fragment";
      case GL_VERTEX_SHADER:
        return "vertex";
      default:
        return "unknown type";
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
  function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
    var errorStrings = errLog.split(/\r?\n/);
    var errors = {};
    var warnings = {};
    var name = shaderName || getShaderName(src) || "(unnamed)";
    var shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name);
    for (var i = 0; i < errorStrings.length; i++) {
      var errorString = errorStrings[i];
      if (errorString.length <= 1) {
        continue;
      }
      var segments = errorString.split(":");
      var type = segments[0];
      var line = parseInt(segments[2], 10);
      if (isNaN(line)) {
        throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
      }
      if (type !== "WARNING") {
        errors[line] = errorString;
      } else {
        warnings[line] = errorString;
      }
    }
    var lines = addLineNumbers(src);
    return {
      shaderName: shaderDescription,
      errors: formatErrors(errors, lines),
      warnings: formatErrors(warnings, lines)
    };
  }
  function formatErrors(errors, lines) {
    var message = "";
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
        continue;
      }
      message += "".concat(line, "\n");
      if (errors[i + 1]) {
        var error2 = errors[i + 1];
        var segments = error2.split(":", 3);
        var type = segments[0];
        var column = parseInt(segments[1], 10) || 0;
        var err = error2.substring(segments.join(":").length + 1).trim();
        message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
      }
    }
    return message;
  }
  function addLineNumbers(string) {
    var start2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
    var lines = string.split(/\r?\n/);
    var maxDigits = String(lines.length + start2 - 1).length;
    return lines.map(function(line, i) {
      var lineNumber = String(i + start2);
      var digits = lineNumber.length;
      var prefix = padLeft(lineNumber, maxDigits - digits);
      return prefix + delim + line;
    });
  }
  function padLeft(string, digits) {
    var result = "";
    for (var i = 0; i < digits; ++i) {
      result += " ";
    }
    return "".concat(result).concat(string);
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
  function getShaderVersion(source) {
    var version2 = 100;
    var words = source.match(/[^\s]+/g);
    if (words.length >= 2 && words[0] === "#version") {
      var v = parseInt(words[1], 10);
      if (Number.isFinite(v)) {
        version2 = v;
      }
    }
    return version2;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
  function _createSuper8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct9();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct9() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
  var Shader = function(_Resource) {
    _inherits(Shader2, _Resource);
    var _super = _createSuper8(Shader2);
    _createClass(Shader2, null, [{
      key: "getTypeName",
      value: function getTypeName(shaderType) {
        switch (shaderType) {
          case 35633:
            return "vertex-shader";
          case 35632:
            return "fragment-shader";
          default:
            assert5(false);
            return "unknown";
        }
      }
    }]);
    function Shader2(gl, props) {
      var _this;
      _classCallCheck(this, Shader2);
      assertWebGLContext(gl);
      assert5(typeof props.source === "string", ERR_SOURCE);
      var id = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(Shader2.getTypeName(props.shaderType)));
      _this = _super.call(this, gl, {
        id
      });
      _this.shaderType = props.shaderType;
      _this.source = props.source;
      _this.initialize(props);
      return _this;
    }
    _createClass(Shader2, [{
      key: "initialize",
      value: function initialize(_ref) {
        var source = _ref.source;
        var shaderName = getShaderName(source, null);
        if (shaderName) {
          this.id = uid(shaderName);
        }
        this._compile(source);
      }
    }, {
      key: "getParameter",
      value: function getParameter(pname) {
        return this.gl.getShaderParameter(this.handle, pname);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(Shader2.getTypeName(this.shaderType), ":").concat(this.id);
      }
    }, {
      key: "getName",
      value: function getName() {
        return getShaderName(this.source) || "unnamed-shader";
      }
    }, {
      key: "getSource",
      value: function getSource() {
        return this.gl.getShaderSource(this.handle);
      }
    }, {
      key: "getTranslatedSource",
      value: function getTranslatedSource() {
        var extension = this.gl.getExtension("WEBGL_debug_shaders");
        return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
      }
    }, {
      key: "_compile",
      value: function _compile() {
        var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
        if (!source.startsWith("#version ")) {
          source = "#version 100\n".concat(source);
        }
        this.source = source;
        this.gl.shaderSource(this.handle, this.source);
        this.gl.compileShader(this.handle);
        var compileStatus = this.getParameter(35713);
        if (!compileStatus) {
          var infoLog = this.gl.getShaderInfoLog(this.handle);
          var _parseGLSLCompilerErr = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id), shaderName = _parseGLSLCompilerErr.shaderName, errors = _parseGLSLCompilerErr.errors, warnings = _parseGLSLCompilerErr.warnings;
          log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
          log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
          throw new Error("GLSL compilation errors in ".concat(shaderName));
        }
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteShader(this.handle);
      }
    }, {
      key: "_getOptsFromHandle",
      value: function _getOptsFromHandle() {
        return {
          type: this.getParameter(35663),
          source: this.getSource()
        };
      }
    }]);
    return Shader2;
  }(Resource);
  var VertexShader = function(_Shader) {
    _inherits(VertexShader2, _Shader);
    var _super2 = _createSuper8(VertexShader2);
    function VertexShader2(gl, props) {
      _classCallCheck(this, VertexShader2);
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      return _super2.call(this, gl, Object.assign({}, props, {
        shaderType: 35633
      }));
    }
    _createClass(VertexShader2, [{
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createShader(35633);
      }
    }]);
    return VertexShader2;
  }(Shader);
  var FragmentShader = function(_Shader2) {
    _inherits(FragmentShader2, _Shader2);
    var _super3 = _createSuper8(FragmentShader2);
    function FragmentShader2(gl, props) {
      _classCallCheck(this, FragmentShader2);
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      return _super3.call(this, gl, Object.assign({}, props, {
        shaderType: 35632
      }));
    }
    _createClass(FragmentShader2, [{
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createShader(35632);
      }
    }]);
    return FragmentShader2;
  }(Shader);

  // node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
  var _UNIFORM_SETTERS;
  var UNIFORM_SETTERS = (_UNIFORM_SETTERS = {}, _defineProperty(_UNIFORM_SETTERS, 5126, getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35664, getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35665, getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35666, getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 5124, getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35667, getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35668, getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35669, getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35670, getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35671, getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35672, getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35673, getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35674, getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35675, getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35676, getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35678, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 35680, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 5125, getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 36294, getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 36295, getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 36296, getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform)), _defineProperty(_UNIFORM_SETTERS, 35685, getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35686, getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35687, getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35688, getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35689, getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35690, getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform)), _defineProperty(_UNIFORM_SETTERS, 35678, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 35680, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 35679, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 35682, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36289, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36292, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36293, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36298, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36299, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36300, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36303, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36306, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36307, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36308, getSamplerSetter), _defineProperty(_UNIFORM_SETTERS, 36311, getSamplerSetter), _UNIFORM_SETTERS);
  var FLOAT_ARRAY = {};
  var INT_ARRAY = {};
  var UINT_ARRAY = {};
  var array1 = [0];
  function toTypedArray(value17, uniformLength, Type, cache3) {
    if (uniformLength === 1 && typeof value17 === "boolean") {
      value17 = value17 ? 1 : 0;
    }
    if (Number.isFinite(value17)) {
      array1[0] = value17;
      value17 = array1;
    }
    var length4 = value17.length;
    if (length4 % uniformLength) {
      log.warn("Uniform size should be multiples of ".concat(uniformLength), value17)();
    }
    if (value17 instanceof Type) {
      return value17;
    }
    var result = cache3[length4];
    if (!result) {
      result = new Type(length4);
      cache3[length4] = result;
    }
    for (var i = 0; i < length4; i++) {
      result[i] = value17[i];
    }
    return result;
  }
  function toFloatArray(value17, uniformLength) {
    return toTypedArray(value17, uniformLength, Float32Array, FLOAT_ARRAY);
  }
  function toIntArray(value17, uniformLength) {
    return toTypedArray(value17, uniformLength, Int32Array, INT_ARRAY);
  }
  function toUIntArray(value17, uniformLength) {
    return toTypedArray(value17, uniformLength, Uint32Array, UINT_ARRAY);
  }
  function getUniformSetter(gl, location, info) {
    var setter = UNIFORM_SETTERS[info.type];
    if (!setter) {
      throw new Error("Unknown GLSL uniform type ".concat(info.type));
    }
    return setter().bind(null, gl, location);
  }
  function parseUniformName(name) {
    if (name[name.length - 1] !== "]") {
      return {
        name,
        length: 1,
        isArray: false
      };
    }
    var UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    var matches3 = name.match(UNIFORM_NAME_REGEXP);
    if (!matches3 || matches3.length < 2) {
      throw new Error("Failed to parse GLSL uniform name ".concat(name));
    }
    return {
      name: matches3[1],
      length: matches3[2] || 1,
      isArray: Boolean(matches3[2])
    };
  }
  function checkUniformValues(uniforms, source, uniformMap) {
    for (var uniformName in uniforms) {
      var value17 = uniforms[uniformName];
      var shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
      if (shouldCheck && !checkUniformValue(value17)) {
        source = source ? "".concat(source, " ") : "";
        console.error("".concat(source, " Bad uniform ").concat(uniformName), value17);
        throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
      }
    }
    return true;
  }
  function checkUniformValue(value17) {
    if (Array.isArray(value17) || ArrayBuffer.isView(value17)) {
      return checkUniformArray(value17);
    }
    if (isFinite(value17)) {
      return true;
    } else if (value17 === true || value17 === false) {
      return true;
    } else if (value17 instanceof Texture) {
      return true;
    } else if (value17 instanceof Renderbuffer) {
      return true;
    } else if (value17 instanceof Framebuffer) {
      return Boolean(value17.texture);
    }
    return false;
  }
  function copyUniform(uniforms, key, value17) {
    if (Array.isArray(value17) || ArrayBuffer.isView(value17)) {
      if (uniforms[key]) {
        var dest = uniforms[key];
        for (var i = 0, len2 = value17.length; i < len2; ++i) {
          dest[i] = value17[i];
        }
      } else {
        uniforms[key] = value17.slice();
      }
    } else {
      uniforms[key] = value17;
    }
  }
  function checkUniformArray(value17) {
    if (value17.length === 0) {
      return false;
    }
    var checkLength = Math.min(value17.length, 16);
    for (var i = 0; i < checkLength; ++i) {
      if (!Number.isFinite(value17[i])) {
        return false;
      }
    }
    return true;
  }
  function getSamplerSetter() {
    var cache3 = null;
    return function(gl, location, value17) {
      var update3 = cache3 !== value17;
      if (update3) {
        gl.uniform1i(location, value17);
        cache3 = value17;
      }
      return update3;
    };
  }
  function getArraySetter(functionName, toArray, size, uniformSetter) {
    var cache3 = null;
    var cacheLength = null;
    return function(gl, location, value17) {
      var arrayValue = toArray(value17, size);
      var length4 = arrayValue.length;
      var update3 = false;
      if (cache3 === null) {
        cache3 = new Float32Array(length4);
        cacheLength = length4;
        update3 = true;
      } else {
        assert5(cacheLength === length4, "Uniform length cannot change.");
        for (var i = 0; i < length4; ++i) {
          if (arrayValue[i] !== cache3[i]) {
            update3 = true;
            break;
          }
        }
      }
      if (update3) {
        uniformSetter(gl, functionName, location, arrayValue);
        cache3.set(arrayValue);
      }
      return update3;
    };
  }
  function setVectorUniform(gl, functionName, location, value17) {
    gl[functionName](location, value17);
  }
  function setMatrixUniform(gl, functionName, location, value17) {
    gl[functionName](location, false, value17);
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
  var _COMPOSITE_GL_TYPES;
  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_LINE_LOOP = 2;
  var GL_LINE_STRIP = 3;
  var GL_TRIANGLES = 4;
  var GL_TRIANGLE_STRIP = 5;
  var GL_TRIANGLE_FAN = 6;
  var GL_FLOAT = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_UNSIGNED_INT = 5125;
  var GL_UNSIGNED_INT_VEC2 = 36294;
  var GL_UNSIGNED_INT_VEC3 = 36295;
  var GL_UNSIGNED_INT_VEC4 = 36296;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_FLOAT_MAT2x3 = 35685;
  var GL_FLOAT_MAT2x4 = 35686;
  var GL_FLOAT_MAT3x2 = 35687;
  var GL_FLOAT_MAT3x4 = 35688;
  var GL_FLOAT_MAT4x2 = 35689;
  var GL_FLOAT_MAT4x3 = 35690;
  var COMPOSITE_GL_TYPES = (_COMPOSITE_GL_TYPES = {}, _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT, [GL_FLOAT, 1, "float"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC2, [GL_FLOAT, 2, "vec2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC3, [GL_FLOAT, 3, "vec3"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC4, [GL_FLOAT, 4, "vec4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_INT, [GL_INT, 1, "int"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_INT_VEC2, [GL_INT, 2, "ivec2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_INT_VEC3, [GL_INT, 3, "ivec3"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_INT_VEC4, [GL_INT, 4, "ivec4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT, [GL_UNSIGNED_INT, 1, "uint"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC2, [GL_UNSIGNED_INT, 2, "uvec2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC3, [GL_UNSIGNED_INT, 3, "uvec3"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC4, [GL_UNSIGNED_INT, 4, "uvec4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_BOOL, [GL_FLOAT, 1, "bool"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_BOOL_VEC2, [GL_FLOAT, 2, "bvec2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_BOOL_VEC3, [GL_FLOAT, 3, "bvec3"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_BOOL_VEC4, [GL_FLOAT, 4, "bvec4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2, [GL_FLOAT, 8, "mat2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2x3, [GL_FLOAT, 8, "mat2x3"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2x4, [GL_FLOAT, 8, "mat2x4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3, [GL_FLOAT, 12, "mat3"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3x2, [GL_FLOAT, 12, "mat3x2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3x4, [GL_FLOAT, 12, "mat3x4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4, [GL_FLOAT, 16, "mat4"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4x2, [GL_FLOAT, 16, "mat4x2"]), _defineProperty(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4x3, [GL_FLOAT, 16, "mat4x3"]), _COMPOSITE_GL_TYPES);
  function getPrimitiveDrawMode(drawMode) {
    switch (drawMode) {
      case GL_POINTS:
        return GL_POINTS;
      case GL_LINES:
        return GL_LINES;
      case GL_LINE_STRIP:
        return GL_LINES;
      case GL_LINE_LOOP:
        return GL_LINES;
      case GL_TRIANGLES:
        return GL_TRIANGLES;
      case GL_TRIANGLE_STRIP:
        return GL_TRIANGLES;
      case GL_TRIANGLE_FAN:
        return GL_TRIANGLES;
      default:
        assert5(false);
        return 0;
    }
  }
  function decomposeCompositeGLType(compositeGLType) {
    var typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) {
      return null;
    }
    var _typeAndSize = _slicedToArray(typeAndSize, 2), type = _typeAndSize[0], components = _typeAndSize[1];
    return {
      type,
      components
    };
  }
  function getCompositeGLType(type, components) {
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
        type = GL_FLOAT;
        break;
      default:
    }
    for (var glType in COMPOSITE_GL_TYPES) {
      var _COMPOSITE_GL_TYPES$g = _slicedToArray(COMPOSITE_GL_TYPES[glType], 3), compType = _COMPOSITE_GL_TYPES$g[0], compComponents = _COMPOSITE_GL_TYPES$g[1], name = _COMPOSITE_GL_TYPES$g[2];
      if (compType === type && compComponents === components) {
        return {
          glType,
          name
        };
      }
    }
    return null;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
  var ProgramConfiguration = function() {
    function ProgramConfiguration2(program) {
      _classCallCheck(this, ProgramConfiguration2);
      this.id = program.id;
      this.attributeInfos = [];
      this.attributeInfosByName = {};
      this.attributeInfosByLocation = [];
      this.varyingInfos = [];
      this.varyingInfosByName = {};
      Object.seal(this);
      this._readAttributesFromProgram(program);
      this._readVaryingsFromProgram(program);
    }
    _createClass(ProgramConfiguration2, [{
      key: "getAttributeInfo",
      value: function getAttributeInfo(locationOrName) {
        var location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return this.attributeInfosByLocation[location];
        }
        return this.attributeInfosByName[locationOrName] || null;
      }
    }, {
      key: "getAttributeLocation",
      value: function getAttributeLocation(locationOrName) {
        var attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.location : -1;
      }
    }, {
      key: "getAttributeAccessor",
      value: function getAttributeAccessor(locationOrName) {
        var attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.accessor : null;
      }
    }, {
      key: "getVaryingInfo",
      value: function getVaryingInfo(locationOrName) {
        var location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return this.varyingInfos[location];
        }
        return this.varyingInfosByName[locationOrName] || null;
      }
    }, {
      key: "getVaryingIndex",
      value: function getVaryingIndex(locationOrName) {
        var varying = this.getVaryingInfo();
        return varying ? varying.location : -1;
      }
    }, {
      key: "getVaryingAccessor",
      value: function getVaryingAccessor(locationOrName) {
        var varying = this.getVaryingInfo();
        return varying ? varying.accessor : null;
      }
    }, {
      key: "_readAttributesFromProgram",
      value: function _readAttributesFromProgram(program) {
        var gl = program.gl;
        var count3 = gl.getProgramParameter(program.handle, 35721);
        for (var index = 0; index < count3; index++) {
          var _gl$getActiveAttrib = gl.getActiveAttrib(program.handle, index), name = _gl$getActiveAttrib.name, type = _gl$getActiveAttrib.type, size = _gl$getActiveAttrib.size;
          var location = gl.getAttribLocation(program.handle, name);
          if (location >= 0) {
            this._addAttribute(location, name, type, size);
          }
        }
        this.attributeInfos.sort(function(a, b) {
          return a.location - b.location;
        });
      }
    }, {
      key: "_readVaryingsFromProgram",
      value: function _readVaryingsFromProgram(program) {
        var gl = program.gl;
        if (!isWebGL2(gl)) {
          return;
        }
        var count3 = gl.getProgramParameter(program.handle, 35971);
        for (var location = 0; location < count3; location++) {
          var _gl$getTransformFeedb = gl.getTransformFeedbackVarying(program.handle, location), name = _gl$getTransformFeedb.name, type = _gl$getTransformFeedb.type, size = _gl$getTransformFeedb.size;
          this._addVarying(location, name, type, size);
        }
        this.varyingInfos.sort(function(a, b) {
          return a.location - b.location;
        });
      }
    }, {
      key: "_addAttribute",
      value: function _addAttribute(location, name, compositeType, size) {
        var _decomposeCompositeGL = decomposeCompositeGLType(compositeType), type = _decomposeCompositeGL.type, components = _decomposeCompositeGL.components;
        var accessor = {
          type,
          size: size * components
        };
        this._inferProperties(location, name, accessor);
        var attributeInfo = {
          location,
          name,
          accessor: new Accessor(accessor)
        };
        this.attributeInfos.push(attributeInfo);
        this.attributeInfosByLocation[location] = attributeInfo;
        this.attributeInfosByName[attributeInfo.name] = attributeInfo;
      }
    }, {
      key: "_inferProperties",
      value: function _inferProperties(location, name, accessor) {
        if (/instance/i.test(name)) {
          accessor.divisor = 1;
        }
      }
    }, {
      key: "_addVarying",
      value: function _addVarying(location, name, compositeType, size) {
        var _decomposeCompositeGL2 = decomposeCompositeGLType(compositeType), type = _decomposeCompositeGL2.type, components = _decomposeCompositeGL2.components;
        var accessor = new Accessor({
          type,
          size: size * components
        });
        var varying = {
          location,
          name,
          accessor
        };
        this.varyingInfos.push(varying);
        this.varyingInfosByName[varying.name] = varying;
      }
    }]);
    return ProgramConfiguration2;
  }();

  // node_modules/@luma.gl/webgl/dist/esm/classes/program.js
  function _createForOfIteratorHelper13(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray14(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray14(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray14(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray14(o, minLen);
  }
  function _arrayLikeToArray14(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct10();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct10() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var GL_SEPARATE_ATTRIBS = 35981;
  var V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
  var Program = function(_Resource) {
    _inherits(Program2, _Resource);
    var _super = _createSuper9(Program2);
    function Program2(gl) {
      var _this;
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Program2);
      _this = _super.call(this, gl, props);
      _this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
      _this._isCached = false;
      _this.initialize(props);
      Object.seal(_assertThisInitialized(_this));
      _this._setId(props.id);
      return _this;
    }
    _createClass(Program2, [{
      key: "initialize",
      value: function initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var hash = props.hash, vs7 = props.vs, fs4 = props.fs, varyings = props.varyings, _props$bufferMode = props.bufferMode, bufferMode = _props$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _props$bufferMode;
        this.hash = hash || "";
        this.vs = typeof vs7 === "string" ? new VertexShader(this.gl, {
          id: "".concat(props.id, "-vs"),
          source: vs7
        }) : vs7;
        this.fs = typeof fs4 === "string" ? new FragmentShader(this.gl, {
          id: "".concat(props.id, "-fs"),
          source: fs4
        }) : fs4;
        assert5(this.vs instanceof VertexShader);
        assert5(this.fs instanceof FragmentShader);
        this.uniforms = {};
        this._textureUniforms = {};
        if (varyings && varyings.length > 0) {
          assertWebGL2Context(this.gl);
          this.varyings = varyings;
          this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        }
        this._compileAndLink();
        this._readUniformLocationsFromLinkedProgram();
        this.configuration = new ProgramConfiguration(this);
        return this.setProps(props);
      }
    }, {
      key: "delete",
      value: function _delete() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._isCached) {
          return this;
        }
        return _get(_getPrototypeOf(Program2.prototype), "delete", this).call(this, options);
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("uniforms" in props) {
          this.setUniforms(props.uniforms);
        }
        return this;
      }
    }, {
      key: "draw",
      value: function draw(_ref) {
        var _this2 = this;
        var logPriority = _ref.logPriority, _ref$drawMode = _ref.drawMode, drawMode = _ref$drawMode === void 0 ? 4 : _ref$drawMode, vertexCount = _ref.vertexCount, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset, start2 = _ref.start, end = _ref.end, _ref$isIndexed = _ref.isIndexed, isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed, _ref$indexType = _ref.indexType, indexType = _ref$indexType === void 0 ? 5123 : _ref$indexType, _ref$instanceCount = _ref.instanceCount, instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount, _ref$isInstanced = _ref.isInstanced, isInstanced = _ref$isInstanced === void 0 ? instanceCount > 0 : _ref$isInstanced, _ref$vertexArray = _ref.vertexArray, vertexArray = _ref$vertexArray === void 0 ? null : _ref$vertexArray, transformFeedback = _ref.transformFeedback, framebuffer2 = _ref.framebuffer, _ref$parameters = _ref.parameters, parameters = _ref$parameters === void 0 ? {} : _ref$parameters, uniforms = _ref.uniforms, samplers = _ref.samplers;
        if (uniforms || samplers) {
          log.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
          this.setUniforms(uniforms || {});
        }
        if (log.priority >= logPriority) {
          var fb = framebuffer2 ? framebuffer2.id : "default";
          var message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
          log.log(logPriority, message)();
        }
        assert5(vertexArray);
        this.gl.useProgram(this.handle);
        if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
          return false;
        }
        vertexArray.bindForDraw(vertexCount, instanceCount, function() {
          if (framebuffer2 !== void 0) {
            parameters = Object.assign({}, parameters, {
              framebuffer: framebuffer2
            });
          }
          if (transformFeedback) {
            var primitiveMode = getPrimitiveDrawMode(drawMode);
            transformFeedback.begin(primitiveMode);
          }
          _this2._bindTextures();
          withParameters(_this2.gl, parameters, function() {
            if (isIndexed && isInstanced) {
              _this2.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
            } else if (isIndexed && isWebGL2(_this2.gl) && !isNaN(start2) && !isNaN(end)) {
              _this2.gl2.drawRangeElements(drawMode, start2, end, vertexCount, indexType, offset);
            } else if (isIndexed) {
              _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);
            } else if (isInstanced) {
              _this2.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
            } else {
              _this2.gl.drawArrays(drawMode, offset, vertexCount);
            }
          });
          if (transformFeedback) {
            transformFeedback.end();
          }
        });
        return true;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms() {
        var uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (log.priority >= 2) {
          checkUniformValues(uniforms, this.id, this._uniformSetters);
        }
        this.gl.useProgram(this.handle);
        for (var uniformName in uniforms) {
          var uniform = uniforms[uniformName];
          var uniformSetter = this._uniformSetters[uniformName];
          if (uniformSetter) {
            var value17 = uniform;
            var textureUpdate = false;
            if (value17 instanceof Framebuffer) {
              value17 = value17.texture;
            }
            if (value17 instanceof Texture) {
              textureUpdate = this.uniforms[uniformName] !== uniform;
              if (textureUpdate) {
                if (uniformSetter.textureIndex === void 0) {
                  uniformSetter.textureIndex = this._textureIndexCounter++;
                }
                var texture = value17;
                var textureIndex = uniformSetter.textureIndex;
                texture.bind(textureIndex);
                value17 = textureIndex;
                this._textureUniforms[uniformName] = texture;
              } else {
                value17 = uniformSetter.textureIndex;
              }
            } else if (this._textureUniforms[uniformName]) {
              delete this._textureUniforms[uniformName];
            }
            if (uniformSetter(value17) || textureUpdate) {
              copyUniform(this.uniforms, uniformName, uniform);
            }
          }
        }
        return this;
      }
    }, {
      key: "_areTexturesRenderable",
      value: function _areTexturesRenderable() {
        var texturesRenderable = true;
        for (var uniformName in this._textureUniforms) {
          var texture = this._textureUniforms[uniformName];
          texture.update();
          texturesRenderable = texturesRenderable && texture.loaded;
        }
        return texturesRenderable;
      }
    }, {
      key: "_bindTextures",
      value: function _bindTextures() {
        for (var uniformName in this._textureUniforms) {
          var textureIndex = this._uniformSetters[uniformName].textureIndex;
          this._textureUniforms[uniformName].bind(textureIndex);
        }
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createProgram();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteProgram(this.handle);
      }
    }, {
      key: "_getOptionsFromHandle",
      value: function _getOptionsFromHandle(handle) {
        var shaderHandles = this.gl.getAttachedShaders(handle);
        var opts = {};
        var _iterator = _createForOfIteratorHelper13(shaderHandles), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var shaderHandle = _step.value;
            var type = this.gl.getShaderParameter(this.handle, 35663);
            switch (type) {
              case 35633:
                opts.vs = new VertexShader({
                  handle: shaderHandle
                });
                break;
              case 35632:
                opts.fs = new FragmentShader({
                  handle: shaderHandle
                });
                break;
              default:
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return opts;
      }
    }, {
      key: "_getParameter",
      value: function _getParameter(pname) {
        return this.gl.getProgramParameter(this.handle, pname);
      }
    }, {
      key: "_setId",
      value: function _setId(id) {
        if (!id) {
          var programName = this._getName();
          this.id = uid(programName);
        }
      }
    }, {
      key: "_getName",
      value: function _getName() {
        var programName = this.vs.getName() || this.fs.getName();
        programName = programName.replace(/shader/i, "");
        programName = programName ? "".concat(programName, "-program") : "program";
        return programName;
      }
    }, {
      key: "_compileAndLink",
      value: function _compileAndLink() {
        var gl = this.gl;
        gl.attachShader(this.handle, this.vs.handle);
        gl.attachShader(this.handle, this.fs.handle);
        log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        gl.linkProgram(this.handle);
        log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        if (gl.debug || log.level > 0) {
          var linked = gl.getProgramParameter(this.handle, 35714);
          if (!linked) {
            throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
          }
          gl.validateProgram(this.handle);
          var validated = gl.getProgramParameter(this.handle, 35715);
          if (!validated) {
            throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
          }
        }
      }
    }, {
      key: "_readUniformLocationsFromLinkedProgram",
      value: function _readUniformLocationsFromLinkedProgram() {
        var gl = this.gl;
        this._uniformSetters = {};
        this._uniformCount = this._getParameter(35718);
        for (var i = 0; i < this._uniformCount; i++) {
          var info = this.gl.getActiveUniform(this.handle, i);
          var _parseUniformName = parseUniformName(info.name), name = _parseUniformName.name;
          var location = gl.getUniformLocation(this.handle, name);
          this._uniformSetters[name] = getUniformSetter(gl, location, info);
          if (info.size > 1) {
            for (var l = 0; l < info.size; l++) {
              location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
              this._uniformSetters["".concat(name, "[").concat(l, "]")] = getUniformSetter(gl, location, info);
            }
          }
        }
        this._textureIndexCounter = 0;
      }
    }, {
      key: "getActiveUniforms",
      value: function getActiveUniforms(uniformIndices, pname) {
        return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
      }
    }, {
      key: "getUniformBlockIndex",
      value: function getUniformBlockIndex(blockName) {
        return this.gl2.getUniformBlockIndex(this.handle, blockName);
      }
    }, {
      key: "getActiveUniformBlockParameter",
      value: function getActiveUniformBlockParameter(blockIndex, pname) {
        return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
      }
    }, {
      key: "uniformBlockBinding",
      value: function uniformBlockBinding(blockIndex, blockBinding) {
        this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
      }
    }]);
    return Program2;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/classes/query.js
  function _createForOfIteratorHelper14(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray15(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray15(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray15(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray15(o, minLen);
  }
  function _arrayLikeToArray15(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper10(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct11();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct11() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var GL_QUERY_RESULT = 34918;
  var GL_QUERY_RESULT_AVAILABLE = 34919;
  var GL_TIME_ELAPSED_EXT = 35007;
  var GL_GPU_DISJOINT_EXT2 = 36795;
  var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
  var GL_ANY_SAMPLES_PASSED = 35887;
  var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
  var Query = function(_Resource) {
    _inherits(Query2, _Resource);
    var _super = _createSuper10(Query2);
    _createClass(Query2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var webgl2 = isWebGL2(gl);
        var hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
        var supported = webgl2 || hasTimerQuery;
        var _iterator = _createForOfIteratorHelper14(opts), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            switch (key) {
              case "queries":
                supported = supported && webgl2;
                break;
              case "timers":
                supported = supported && hasTimerQuery;
                break;
              default:
                assert5(false);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return supported;
      }
    }]);
    function Query2(gl) {
      var _this;
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Query2);
      _this = _super.call(this, gl, opts);
      _this.target = null;
      _this._queryPending = false;
      _this._pollingPromise = null;
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(Query2, [{
      key: "beginTimeElapsedQuery",
      value: function beginTimeElapsedQuery() {
        return this.begin(GL_TIME_ELAPSED_EXT);
      }
    }, {
      key: "beginOcclusionQuery",
      value: function beginOcclusionQuery() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$conservative = _ref.conservative, conservative = _ref$conservative === void 0 ? false : _ref$conservative;
        return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
      }
    }, {
      key: "beginTransformFeedbackQuery",
      value: function beginTransformFeedbackQuery() {
        return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
      }
    }, {
      key: "begin",
      value: function begin(target) {
        if (this._queryPending) {
          return this;
        }
        this.target = target;
        this.gl2.beginQuery(this.target, this.handle);
        return this;
      }
    }, {
      key: "end",
      value: function end() {
        if (this._queryPending) {
          return this;
        }
        if (this.target) {
          this.gl2.endQuery(this.target);
          this.target = null;
          this._queryPending = true;
        }
        return this;
      }
    }, {
      key: "isResultAvailable",
      value: function isResultAvailable() {
        if (!this._queryPending) {
          return false;
        }
        var resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
        if (resultAvailable) {
          this._queryPending = false;
        }
        return resultAvailable;
      }
    }, {
      key: "isTimerDisjoint",
      value: function isTimerDisjoint() {
        return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
      }
    }, {
      key: "getResult",
      value: function getResult() {
        return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
      }
    }, {
      key: "getTimerMilliseconds",
      value: function getTimerMilliseconds() {
        return this.getResult() / 1e6;
      }
    }, {
      key: "createPoll",
      value: function createPoll() {
        var _this2 = this;
        var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
        if (this._pollingPromise) {
          return this._pollingPromise;
        }
        var counter2 = 0;
        this._pollingPromise = new Promise(function(resolve, reject) {
          var poll = function poll2() {
            if (_this2.isResultAvailable()) {
              resolve(_this2.getResult());
              _this2._pollingPromise = null;
            } else if (counter2++ > limit) {
              reject("Timed out");
              _this2._pollingPromise = null;
            } else {
              requestAnimationFrame(poll2);
            }
          };
          requestAnimationFrame(poll);
        });
        return this._pollingPromise;
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return Query2.isSupported(this.gl) ? this.gl2.createQuery() : null;
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl2.deleteQuery(this.handle);
      }
    }]);
    return Query2;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
  function _createSuper11(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct12();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct12() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var TransformFeedback = function(_Resource) {
    _inherits(TransformFeedback2, _Resource);
    var _super = _createSuper11(TransformFeedback2);
    _createClass(TransformFeedback2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        return isWebGL2(gl);
      }
    }]);
    function TransformFeedback2(gl) {
      var _this;
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, TransformFeedback2);
      assertWebGL2Context(gl);
      _this = _super.call(this, gl, props);
      _this.initialize(props);
      _this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(TransformFeedback2, [{
      key: "initialize",
      value: function initialize() {
        var _this2 = this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.buffers = {};
        this.unused = {};
        this.configuration = null;
        this.bindOnUse = true;
        if (!isObjectEmpty2(this.buffers)) {
          this.bind(function() {
            return _this2._unbindBuffers();
          });
        }
        this.setProps(props);
        return this;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("program" in props) {
          this.configuration = props.program && props.program.configuration;
        }
        if ("configuration" in props) {
          this.configuration = props.configuration;
        }
        if ("bindOnUse" in props) {
          props = props.bindOnUse;
        }
        if ("buffers" in props) {
          this.setBuffers(props.buffers);
        }
      }
    }, {
      key: "setBuffers",
      value: function setBuffers() {
        var _this3 = this;
        var buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.bind(function() {
          for (var bufferName in buffers) {
            _this3.setBuffer(bufferName, buffers[bufferName]);
          }
        });
        return this;
      }
    }, {
      key: "setBuffer",
      value: function setBuffer(locationOrName, bufferOrParams) {
        var _this4 = this;
        var location = this._getVaryingIndex(locationOrName);
        var _this$_getBufferParam = this._getBufferParams(bufferOrParams), buffer = _this$_getBufferParam.buffer, byteSize = _this$_getBufferParam.byteSize, byteOffset = _this$_getBufferParam.byteOffset;
        if (location < 0) {
          this.unused[locationOrName] = buffer;
          log.warn(function() {
            return "".concat(_this4.id, " unused varying buffer ").concat(locationOrName);
          })();
          return this;
        }
        this.buffers[location] = bufferOrParams;
        if (!this.bindOnUse) {
          this._bindBuffer(location, buffer, byteOffset, byteSize);
        }
        return this;
      }
    }, {
      key: "begin",
      value: function begin() {
        var primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bindBuffers();
        this.gl.beginTransformFeedback(primitiveMode);
        return this;
      }
    }, {
      key: "end",
      value: function end() {
        this.gl.endTransformFeedback();
        this._unbindBuffers();
        this.gl.bindTransformFeedback(36386, null);
        return this;
      }
    }, {
      key: "_getBufferParams",
      value: function _getBufferParams(bufferOrParams) {
        var byteOffset;
        var byteSize;
        var buffer;
        if (bufferOrParams instanceof Buffer2 === false) {
          buffer = bufferOrParams.buffer;
          byteSize = bufferOrParams.byteSize;
          byteOffset = bufferOrParams.byteOffset;
        } else {
          buffer = bufferOrParams;
        }
        if (byteOffset !== void 0 || byteSize !== void 0) {
          byteOffset = byteOffset || 0;
          byteSize = byteSize || buffer.byteLength - byteOffset;
        }
        return {
          buffer,
          byteOffset,
          byteSize
        };
      }
    }, {
      key: "_getVaryingInfo",
      value: function _getVaryingInfo(locationOrName) {
        return this.configuration && this.configuration.getVaryingInfo(locationOrName);
      }
    }, {
      key: "_getVaryingIndex",
      value: function _getVaryingIndex(locationOrName) {
        if (this.configuration) {
          return this.configuration.getVaryingInfo(locationOrName).location;
        }
        var location = Number(locationOrName);
        return Number.isFinite(location) ? location : -1;
      }
    }, {
      key: "_bindBuffers",
      value: function _bindBuffers() {
        if (this.bindOnUse) {
          for (var bufferIndex in this.buffers) {
            var _this$_getBufferParam2 = this._getBufferParams(this.buffers[bufferIndex]), buffer = _this$_getBufferParam2.buffer, byteSize = _this$_getBufferParam2.byteSize, byteOffset = _this$_getBufferParam2.byteOffset;
            this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
          }
        }
      }
    }, {
      key: "_unbindBuffers",
      value: function _unbindBuffers() {
        if (this.bindOnUse) {
          for (var bufferIndex in this.buffers) {
            this._bindBuffer(bufferIndex, null);
          }
        }
      }
    }, {
      key: "_bindBuffer",
      value: function _bindBuffer(index, buffer) {
        var byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var byteSize = arguments.length > 3 ? arguments[3] : void 0;
        var handle = buffer && buffer.handle;
        if (!handle || byteSize === void 0) {
          this.gl.bindBufferBase(35982, index, handle);
        } else {
          this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
        }
        return this;
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        return this.gl.createTransformFeedback();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle() {
        this.gl.deleteTransformFeedback(this.handle);
      }
    }, {
      key: "_bindHandle",
      value: function _bindHandle(handle) {
        this.gl.bindTransformFeedback(36386, this.handle);
      }
    }]);
    return TransformFeedback2;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
  var arrayBuffer = null;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type, length4) {
    var scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length4);
    return new Type(scratchArrayBuffer, 0, length4);
  }
  function fillArray(_ref) {
    var target = _ref.target, source = _ref.source, _ref$start = _ref.start, start2 = _ref$start === void 0 ? 0 : _ref$start, _ref$count = _ref.count, count3 = _ref$count === void 0 ? 1 : _ref$count;
    var length4 = source.length;
    var total = count3 * length4;
    var copied = 0;
    for (var i = start2; copied < length4; copied++) {
      target[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start2 + copied, start2, start2 + copied);
        copied *= 2;
      } else {
        target.copyWithin(start2 + copied, start2, start2 + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
  function _createSuper12(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct13();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct13() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
  var VertexArrayObject = function(_Resource) {
    _inherits(VertexArrayObject2, _Resource);
    var _super = _createSuper12(VertexArrayObject2);
    _createClass(VertexArrayObject2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (options.constantAttributeZero) {
          return isWebGL2(gl) || getBrowser() === "Chrome";
        }
        return true;
      }
    }, {
      key: "getDefaultArray",
      value: function getDefaultArray(gl) {
        gl.luma = gl.luma || {};
        if (!gl.luma.defaultVertexArray) {
          gl.luma.defaultVertexArray = new VertexArrayObject2(gl, {
            handle: null,
            isDefaultArray: true
          });
        }
        return gl.luma.defaultVertexArray;
      }
    }, {
      key: "getMaxAttributes",
      value: function getMaxAttributes(gl) {
        VertexArrayObject2.MAX_ATTRIBUTES = VertexArrayObject2.MAX_ATTRIBUTES || gl.getParameter(34921);
        return VertexArrayObject2.MAX_ATTRIBUTES;
      }
    }, {
      key: "setConstant",
      value: function setConstant(gl, location, array) {
        switch (array.constructor) {
          case Float32Array:
            VertexArrayObject2._setConstantFloatArray(gl, location, array);
            break;
          case Int32Array:
            VertexArrayObject2._setConstantIntArray(gl, location, array);
            break;
          case Uint32Array:
            VertexArrayObject2._setConstantUintArray(gl, location, array);
            break;
          default:
            assert5(false);
        }
      }
    }]);
    function VertexArrayObject2(gl) {
      var _this;
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, VertexArrayObject2);
      var id = opts.id || opts.program && opts.program.id;
      _this = _super.call(this, gl, Object.assign({}, opts, {
        id
      }));
      _this.buffer = null;
      _this.bufferValue = null;
      _this.isDefaultArray = opts.isDefaultArray || false;
      _this.gl2 = gl;
      _this.initialize(opts);
      Object.seal(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(VertexArrayObject2, [{
      key: "delete",
      value: function _delete() {
        _get(_getPrototypeOf(VertexArrayObject2.prototype), "delete", this).call(this);
        if (this.buffer) {
          this.buffer["delete"]();
        }
        return this;
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return this.setProps(props);
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        return this;
      }
    }, {
      key: "setElementBuffer",
      value: function setElementBuffer() {
        var _this2 = this;
        var elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assert5(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
        this.bind(function() {
          _this2.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
        });
        return this;
      }
    }, {
      key: "setBuffer",
      value: function setBuffer(location, buffer, accessor) {
        if (buffer.target === 34963) {
          return this.setElementBuffer(buffer, accessor);
        }
        var size = accessor.size, type = accessor.type, stride = accessor.stride, offset = accessor.offset, normalized = accessor.normalized, integer = accessor.integer, divisor = accessor.divisor;
        var gl = this.gl, gl2 = this.gl2;
        location = Number(location);
        this.bind(function() {
          gl.bindBuffer(34962, buffer.handle);
          if (integer) {
            assert5(isWebGL2(gl));
            gl2.vertexAttribIPointer(location, size, type, stride, offset);
          } else {
            gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
          }
          gl.enableVertexAttribArray(location);
          gl2.vertexAttribDivisor(location, divisor || 0);
        });
        return this;
      }
    }, {
      key: "enable",
      value: function enable4(location) {
        var _this3 = this;
        var _enable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        var disablingAttributeZero = !_enable && location === 0 && !VertexArrayObject2.isSupported(this.gl, {
          constantAttributeZero: true
        });
        if (!disablingAttributeZero) {
          location = Number(location);
          this.bind(function() {
            return _enable ? _this3.gl.enableVertexAttribArray(location) : _this3.gl.disableVertexAttribArray(location);
          });
        }
        return this;
      }
    }, {
      key: "getConstantBuffer",
      value: function getConstantBuffer(elementCount, value17) {
        var constantValue = this._normalizeConstantArrayValue(value17);
        var byteLength = constantValue.byteLength * elementCount;
        var length4 = constantValue.length * elementCount;
        var updateNeeded = !this.buffer;
        this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
        updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
        updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
        if (updateNeeded) {
          var typedArray = getScratchArray(value17.constructor, length4);
          fillArray({
            target: typedArray,
            source: constantValue,
            start: 0,
            count: length4
          });
          this.buffer.subData(typedArray);
          this.bufferValue = value17;
        }
        return this.buffer;
      }
    }, {
      key: "_normalizeConstantArrayValue",
      value: function _normalizeConstantArrayValue(arrayValue) {
        if (Array.isArray(arrayValue)) {
          return new Float32Array(arrayValue);
        }
        return arrayValue;
      }
    }, {
      key: "_compareConstantArrayValues",
      value: function _compareConstantArrayValues(v1, v2) {
        if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
          return false;
        }
        for (var i = 0; i < v1.length; ++i) {
          if (v1[i] !== v2[i]) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "_createHandle",
      value: function _createHandle() {
        var gl2 = this.gl;
        return gl2.createVertexArray();
      }
    }, {
      key: "_deleteHandle",
      value: function _deleteHandle(handle) {
        this.gl2.deleteVertexArray(handle);
        return [this.elements];
      }
    }, {
      key: "_bindHandle",
      value: function _bindHandle(handle) {
        this.gl2.bindVertexArray(handle);
      }
    }, {
      key: "_getParameter",
      value: function _getParameter(pname, _ref) {
        var _this4 = this;
        var location = _ref.location;
        assert5(Number.isFinite(location));
        return this.bind(function() {
          switch (pname) {
            case 34373:
              return _this4.gl.getVertexAttribOffset(location, pname);
            default:
              return _this4.gl.getVertexAttrib(location, pname);
          }
        });
      }
    }, {
      key: "MAX_ATTRIBUTES",
      get: function get2() {
        return VertexArrayObject2.getMaxAttributes(this.gl);
      }
    }], [{
      key: "_setConstantFloatArray",
      value: function _setConstantFloatArray(gl, location, array) {
        switch (array.length) {
          case 1:
            gl.vertexAttrib1fv(location, array);
            break;
          case 2:
            gl.vertexAttrib2fv(location, array);
            break;
          case 3:
            gl.vertexAttrib3fv(location, array);
            break;
          case 4:
            gl.vertexAttrib4fv(location, array);
            break;
          default:
            assert5(false);
        }
      }
    }, {
      key: "_setConstantIntArray",
      value: function _setConstantIntArray(gl, location, array) {
        assert5(isWebGL2(gl));
        switch (array.length) {
          case 1:
            gl.vertexAttribI1iv(location, array);
            break;
          case 2:
            gl.vertexAttribI2iv(location, array);
            break;
          case 3:
            gl.vertexAttribI3iv(location, array);
            break;
          case 4:
            gl.vertexAttribI4iv(location, array);
            break;
          default:
            assert5(false);
        }
      }
    }, {
      key: "_setConstantUintArray",
      value: function _setConstantUintArray(gl, location, array) {
        assert5(isWebGL2(gl));
        switch (array.length) {
          case 1:
            gl.vertexAttribI1uiv(location, array);
            break;
          case 2:
            gl.vertexAttribI2uiv(location, array);
            break;
          case 3:
            gl.vertexAttribI3uiv(location, array);
            break;
          case 4:
            gl.vertexAttribI4uiv(location, array);
            break;
          default:
            assert5(false);
        }
      }
    }]);
    return VertexArrayObject2;
  }(Resource);

  // node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
  var ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
  var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
  var DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
  var VertexArray = function() {
    function VertexArray2(gl) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, VertexArray2);
      var id = opts.id || opts.program && opts.program.id;
      this.id = id;
      this.gl = gl;
      this.configuration = null;
      this.elements = null;
      this.elementsAccessor = null;
      this.values = null;
      this.accessors = null;
      this.unused = null;
      this.drawParams = null;
      this.buffer = null;
      this.attributes = {};
      this.vertexArrayObject = new VertexArrayObject(gl);
      stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
      this.initialize(opts);
      Object.seal(this);
    }
    _createClass(VertexArray2, [{
      key: "delete",
      value: function _delete() {
        if (this.buffer) {
          this.buffer["delete"]();
        }
        this.vertexArrayObject["delete"]();
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.reset();
        this.configuration = null;
        this.bindOnUse = false;
        return this.setProps(props);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.elements = null;
        this.elementsAccessor = null;
        var MAX_ATTRIBUTES = this.vertexArrayObject.MAX_ATTRIBUTES;
        this.values = new Array(MAX_ATTRIBUTES).fill(null);
        this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
        this.unused = {};
        this.drawParams = null;
        return this;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("program" in props) {
          this.configuration = props.program && props.program.configuration;
        }
        if ("configuration" in props) {
          this.configuration = props.configuration;
        }
        if ("attributes" in props) {
          this.setAttributes(props.attributes);
        }
        if ("elements" in props) {
          this.setElementBuffer(props.elements);
        }
        if ("bindOnUse" in props) {
          props = props.bindOnUse;
        }
        return this;
      }
    }, {
      key: "clearDrawParams",
      value: function clearDrawParams() {
        this.drawParams = null;
      }
    }, {
      key: "getDrawParams",
      value: function getDrawParams() {
        this.drawParams = this.drawParams || this._updateDrawParams();
        return this.drawParams;
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(attributes) {
        var _this = this;
        Object.assign(this.attributes, attributes);
        this.vertexArrayObject.bind(function() {
          for (var locationOrName in attributes) {
            var value17 = attributes[locationOrName];
            _this._setAttribute(locationOrName, value17);
          }
          _this.gl.bindBuffer(34962, null);
        });
        return this;
      }
    }, {
      key: "setElementBuffer",
      value: function setElementBuffer() {
        var elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        var accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.elements = elementBuffer;
        this.elementsAccessor = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
        return this;
      }
    }, {
      key: "setBuffer",
      value: function setBuffer(locationOrName, buffer) {
        var appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (buffer.target === 34963) {
          return this.setElementBuffer(buffer, appAccessor);
        }
        var _this$_resolveLocatio = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor), location = _this$_resolveLocatio.location, accessor = _this$_resolveLocatio.accessor;
        if (location >= 0) {
          this.values[location] = buffer;
          this.accessors[location] = accessor;
          this.clearDrawParams();
          this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
        return this;
      }
    }, {
      key: "setConstant",
      value: function setConstant(locationOrName, arrayValue) {
        var appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var _this$_resolveLocatio2 = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
          size: arrayValue.length
        }, appAccessor)), location = _this$_resolveLocatio2.location, accessor = _this$_resolveLocatio2.accessor;
        if (location >= 0) {
          arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
          this.values[location] = arrayValue;
          this.accessors[location] = accessor;
          this.clearDrawParams();
          this.vertexArrayObject.enable(location, false);
        }
        return this;
      }
    }, {
      key: "unbindBuffers",
      value: function unbindBuffers() {
        var _this2 = this;
        this.vertexArrayObject.bind(function() {
          if (_this2.elements) {
            _this2.vertexArrayObject.setElementBuffer(null);
          }
          _this2.buffer = _this2.buffer || new Buffer2(_this2.gl, {
            accessor: {
              size: 4
            }
          });
          for (var location = 0; location < _this2.vertexArrayObject.MAX_ATTRIBUTES; location++) {
            if (_this2.values[location] instanceof Buffer2) {
              _this2.gl.disableVertexAttribArray(location);
              _this2.gl.bindBuffer(34962, _this2.buffer.handle);
              _this2.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
            }
          }
        });
        return this;
      }
    }, {
      key: "bindBuffers",
      value: function bindBuffers() {
        var _this3 = this;
        this.vertexArrayObject.bind(function() {
          if (_this3.elements) {
            _this3.setElementBuffer(_this3.elements);
          }
          for (var location = 0; location < _this3.vertexArrayObject.MAX_ATTRIBUTES; location++) {
            var buffer = _this3.values[location];
            if (buffer instanceof Buffer2) {
              _this3.setBuffer(location, buffer);
            }
          }
        });
        return this;
      }
    }, {
      key: "bindForDraw",
      value: function bindForDraw(vertexCount, instanceCount, func) {
        var _this4 = this;
        var value17;
        this.vertexArrayObject.bind(function() {
          _this4._setConstantAttributes(vertexCount, instanceCount);
          value17 = func();
        });
        return value17;
      }
    }, {
      key: "_resolveLocationAndAccessor",
      value: function _resolveLocationAndAccessor(locationOrName, value17, valueAccessor, appAccessor) {
        var _this5 = this;
        var INVALID_RESULT = {
          location: -1,
          accessor: null
        };
        var _this$_getAttributeIn = this._getAttributeIndex(locationOrName), location = _this$_getAttributeIn.location, name = _this$_getAttributeIn.name;
        if (!Number.isFinite(location) || location < 0) {
          this.unused[locationOrName] = value17;
          log.once(3, function() {
            return "unused value ".concat(locationOrName, " in ").concat(_this5.id);
          })();
          return INVALID_RESULT;
        }
        var accessInfo = this._getAttributeInfo(name || location);
        if (!accessInfo) {
          return INVALID_RESULT;
        }
        var currentAccessor = this.accessors[location] || {};
        var accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
        var size = accessor.size, type = accessor.type;
        assert5(Number.isFinite(size) && Number.isFinite(type));
        return {
          location,
          accessor
        };
      }
    }, {
      key: "_getAttributeInfo",
      value: function _getAttributeInfo(attributeName) {
        return this.configuration && this.configuration.getAttributeInfo(attributeName);
      }
    }, {
      key: "_getAttributeIndex",
      value: function _getAttributeIndex(locationOrName) {
        var location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return {
            location
          };
        }
        var multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
        var name = multiLocation ? multiLocation[1] : locationOrName;
        var locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
        if (this.configuration) {
          return {
            location: this.configuration.getAttributeLocation(name) + locationOffset,
            name
          };
        }
        return {
          location: -1
        };
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(locationOrName, value17) {
        if (value17 instanceof Buffer2) {
          this.setBuffer(locationOrName, value17);
        } else if (Array.isArray(value17) && value17.length && value17[0] instanceof Buffer2) {
          var buffer = value17[0];
          var accessor = value17[1];
          this.setBuffer(locationOrName, buffer, accessor);
        } else if (ArrayBuffer.isView(value17) || Array.isArray(value17)) {
          var constant = value17;
          this.setConstant(locationOrName, constant);
        } else if (value17.buffer instanceof Buffer2) {
          var _accessor = value17;
          this.setBuffer(locationOrName, _accessor.buffer, _accessor);
        } else {
          throw new Error(ERR_ATTRIBUTE_TYPE);
        }
      }
    }, {
      key: "_setConstantAttributes",
      value: function _setConstantAttributes(vertexCount, instanceCount) {
        var elementCount = Math.max(vertexCount | 0, instanceCount | 0);
        var constant = this.values[0];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttributeZero(constant, elementCount);
        }
        for (var location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          constant = this.values[location];
          if (ArrayBuffer.isView(constant)) {
            this._setConstantAttribute(location, constant);
          }
        }
      }
    }, {
      key: "_setConstantAttributeZero",
      value: function _setConstantAttributeZero(constant, elementCount) {
        if (VertexArrayObject.isSupported(this.gl, {
          constantAttributeZero: true
        })) {
          this._setConstantAttribute(0, constant);
          return;
        }
        var buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
        this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
      }
    }, {
      key: "_setConstantAttribute",
      value: function _setConstantAttribute(location, constant) {
        VertexArrayObject.setConstant(this.gl, location, constant);
      }
    }, {
      key: "_updateDrawParams",
      value: function _updateDrawParams() {
        var drawParams = {
          isIndexed: false,
          isInstanced: false,
          indexCount: Infinity,
          vertexCount: Infinity,
          instanceCount: Infinity
        };
        for (var location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          this._updateDrawParamsForLocation(drawParams, location);
        }
        if (this.elements) {
          drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
          drawParams.isIndexed = true;
          drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
          drawParams.indexOffset = this.elementsAccessor.offset || 0;
        }
        if (drawParams.indexCount === Infinity) {
          drawParams.indexCount = 0;
        }
        if (drawParams.vertexCount === Infinity) {
          drawParams.vertexCount = 0;
        }
        if (drawParams.instanceCount === Infinity) {
          drawParams.instanceCount = 0;
        }
        return drawParams;
      }
    }, {
      key: "_updateDrawParamsForLocation",
      value: function _updateDrawParamsForLocation(drawParams, location) {
        var value17 = this.values[location];
        var accessor = this.accessors[location];
        if (!value17) {
          return;
        }
        var divisor = accessor.divisor;
        var isInstanced = divisor > 0;
        drawParams.isInstanced = drawParams.isInstanced || isInstanced;
        if (value17 instanceof Buffer2) {
          var buffer = value17;
          if (isInstanced) {
            var instanceCount = buffer.getVertexCount(accessor);
            drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
          } else {
            var vertexCount = buffer.getVertexCount(accessor);
            drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
          }
        }
      }
    }, {
      key: "setElements",
      value: function setElements() {
        var elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        var accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        log.deprecated("setElements", "setElementBuffer")();
        return this.setElementBuffer(elementBuffer, accessor);
      }
    }]);
    return VertexArray2;
  }();

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
  function _createForOfIteratorHelper15(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray16(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray16(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray16(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray16(o, minLen);
  }
  function _arrayLikeToArray16(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function getDebugTableForUniforms(_ref) {
    var _ref$header = _ref.header, header = _ref$header === void 0 ? "Uniforms" : _ref$header, program = _ref.program, uniforms = _ref.uniforms, _ref$undefinedOnly = _ref.undefinedOnly, undefinedOnly = _ref$undefinedOnly === void 0 ? false : _ref$undefinedOnly;
    assert5(program);
    var SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    var PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    var uniformLocations = program._uniformSetters;
    var table = {};
    var uniformNames = Object.keys(uniformLocations).sort();
    var count3 = 0;
    var _iterator = _createForOfIteratorHelper15(uniformNames), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _uniformName = _step.value;
        if (!_uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !_uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
          if (addUniformToTable({
            table,
            header,
            uniforms,
            uniformName: _uniformName,
            undefinedOnly
          })) {
            count3++;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper15(uniformNames), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _uniformName2 = _step2.value;
        if (_uniformName2.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
          if (addUniformToTable({
            table,
            header,
            uniforms,
            uniformName: _uniformName2,
            undefinedOnly
          })) {
            count3++;
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    var _iterator3 = _createForOfIteratorHelper15(uniformNames), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _uniformName3 = _step3.value;
        if (!table[_uniformName3]) {
          if (addUniformToTable({
            table,
            header,
            uniforms,
            uniformName: _uniformName3,
            undefinedOnly
          })) {
            count3++;
          }
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    var unusedCount = 0;
    var unusedTable = {};
    if (!undefinedOnly) {
      for (var uniformName in uniforms) {
        var uniform = uniforms[uniformName];
        if (!table[uniformName]) {
          unusedCount++;
          unusedTable[uniformName] = _defineProperty({
            Type: "NOT USED: ".concat(uniform)
          }, header, formatValue(uniform));
        }
      }
    }
    return {
      table,
      count: count3,
      unusedTable,
      unusedCount
    };
  }
  function addUniformToTable(_ref2) {
    var table = _ref2.table, header = _ref2.header, uniforms = _ref2.uniforms, uniformName = _ref2.uniformName, undefinedOnly = _ref2.undefinedOnly;
    var value17 = uniforms[uniformName];
    var isDefined = isUniformDefined(value17);
    if (!undefinedOnly || !isDefined) {
      var _table$uniformName;
      table[uniformName] = (_table$uniformName = {}, _defineProperty(_table$uniformName, header, isDefined ? formatValue(value17) : "N/A"), _defineProperty(_table$uniformName, "Uniform Type", isDefined ? value17 : "NOT PROVIDED"), _table$uniformName);
      return true;
    }
    return false;
  }
  function isUniformDefined(value17) {
    return value17 !== void 0 && value17 !== null;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
  function getDebugTableForVertexArray(_ref) {
    var vertexArray = _ref.vertexArray, _ref$header = _ref.header, header = _ref$header === void 0 ? "Attributes" : _ref$header;
    if (!vertexArray.configuration) {
      return {};
    }
    var table = {};
    if (vertexArray.elements) {
      table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    }
    var attributes = vertexArray.values;
    for (var attributeLocation in attributes) {
      var info = vertexArray._getAttributeInfo(attributeLocation);
      if (info) {
        var rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
        var accessor = vertexArray.accessors[info.location];
        if (accessor) {
          rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
        }
        table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
      }
    }
    return table;
  }
  function getDebugTableRow(vertexArray, attribute, accessor, header) {
    var _ref4;
    var gl = vertexArray.gl;
    if (!attribute) {
      var _ref2;
      return _ref2 = {}, _defineProperty(_ref2, header, "null"), _defineProperty(_ref2, "Format ", "N/A"), _ref2;
    }
    var type = "NOT PROVIDED";
    var size = 1;
    var verts = 0;
    var bytes = 0;
    var isInteger;
    var marker;
    var value17;
    if (accessor) {
      type = accessor.type;
      size = accessor.size;
      type = String(type).replace("Array", "");
      isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof Buffer2) {
      var _ref3;
      var buffer = attribute;
      var _buffer$getDebugData = buffer.getDebugData(), data = _buffer$getDebugData.data, changed = _buffer$getDebugData.changed;
      marker = changed ? "*" : "";
      value17 = data;
      bytes = buffer.byteLength;
      verts = bytes / data.BYTES_PER_ELEMENT / size;
      var format;
      if (accessor) {
        var instanced = accessor.divisor > 0;
        format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
      } else {
        isInteger = true;
        format = "".concat(bytes, " bytes");
      }
      return _ref3 = {}, _defineProperty(_ref3, header, "".concat(marker).concat(formatValue(value17, {
        size,
        isInteger
      }))), _defineProperty(_ref3, "Format ", format), _ref3;
    }
    value17 = attribute;
    size = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return _ref4 = {}, _defineProperty(_ref4, header, "".concat(formatValue(value17, {
      size,
      isInteger
    }), " (constant)")), _defineProperty(_ref4, "Format ", "".concat(size, "x").concat(type, " (constant)")), _ref4;
  }
  function getGLSLDeclaration(name, accessor) {
    var type = accessor.type, size = accessor.size;
    var typeAndName = getCompositeGLType(type, size);
    return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
  function _createForOfIteratorHelper16(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray17(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray17(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray17(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray17(o, minLen);
  }
  function _arrayLikeToArray17(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function getDebugTableForProgramConfiguration(config2) {
    var table = {};
    var header = "Accessors for ".concat(config2.id);
    var _iterator = _createForOfIteratorHelper16(config2.attributeInfos), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var attributeInfo = _step.value;
        if (attributeInfo) {
          var glslDeclaration = getGLSLDeclaration2(attributeInfo);
          table["in ".concat(glslDeclaration)] = _defineProperty({}, header, JSON.stringify(attributeInfo.accessor));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper16(config2.varyingInfos), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var varyingInfo = _step2.value;
        if (varyingInfo) {
          var _glslDeclaration = getGLSLDeclaration2(varyingInfo);
          table["out ".concat(_glslDeclaration)] = _defineProperty({}, header, JSON.stringify(varyingInfo.accessor));
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return table;
  }
  function getGLSLDeclaration2(attributeInfo) {
    var _attributeInfo$access = attributeInfo.accessor, type = _attributeInfo$access.type, size = _attributeInfo$access.size;
    var typeAndName = getCompositeGLType(type, size);
    if (typeAndName) {
      return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    }
    return attributeInfo.name;
  }

  // node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
  var import_regenerator24 = __toModule(require_regenerator());
  var import_env6 = __toModule(require_env2());
  var isPage2 = (0, import_env6.isBrowser)() && typeof document !== "undefined";
  var statIdCounter = 0;
  var AnimationLoop = function() {
    function AnimationLoop2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, AnimationLoop2);
      var _props$onCreateContex = props.onCreateContext, onCreateContext = _props$onCreateContex === void 0 ? function(opts) {
        return createGLContext(opts);
      } : _props$onCreateContex, _props$onAddHTML = props.onAddHTML, onAddHTML = _props$onAddHTML === void 0 ? null : _props$onAddHTML, _props$onInitialize = props.onInitialize, onInitialize = _props$onInitialize === void 0 ? function() {
      } : _props$onInitialize, _props$onRender = props.onRender, onRender = _props$onRender === void 0 ? function() {
      } : _props$onRender, _props$onFinalize = props.onFinalize, onFinalize = _props$onFinalize === void 0 ? function() {
      } : _props$onFinalize, onError = props.onError, _props$gl = props.gl, gl = _props$gl === void 0 ? null : _props$gl, _props$glOptions = props.glOptions, glOptions = _props$glOptions === void 0 ? {} : _props$glOptions, _props$debug = props.debug, debug2 = _props$debug === void 0 ? false : _props$debug, _props$createFramebuf = props.createFramebuffer, createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf, _props$autoResizeView = props.autoResizeViewport, autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView, _props$autoResizeDraw = props.autoResizeDrawingBuffer, autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw, _props$stats = props.stats, stats = _props$stats === void 0 ? lumaStats.get("animation-loop-".concat(statIdCounter++)) : _props$stats;
      var _props$useDevicePixel = props.useDevicePixels, useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;
      if ("useDevicePixelRatio" in props) {
        log.deprecated("useDevicePixelRatio", "useDevicePixels")();
        useDevicePixels = props.useDevicePixelRatio;
      }
      this.props = {
        onCreateContext,
        onAddHTML,
        onInitialize,
        onRender,
        onFinalize,
        onError,
        gl,
        glOptions,
        debug: debug2,
        createFramebuffer
      };
      this.gl = gl;
      this.needsRedraw = null;
      this.timeline = null;
      this.stats = stats;
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this._initialized = false;
      this._running = false;
      this._animationFrameId = null;
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._cpuStartTime = 0;
      this.setProps({
        autoResizeViewport,
        autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._pageLoadPromise = null;
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    _createClass(AnimationLoop2, [{
      key: "delete",
      value: function _delete() {
        this.stop();
        this._setDisplay(null);
      }
    }, {
      key: "setNeedsRedraw",
      value: function setNeedsRedraw(reason) {
        assert5(typeof reason === "string");
        this.needsRedraw = this.needsRedraw || reason;
        return this;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("autoResizeViewport" in props) {
          this.autoResizeViewport = props.autoResizeViewport;
        }
        if ("autoResizeDrawingBuffer" in props) {
          this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
        }
        if ("useDevicePixels" in props) {
          this.useDevicePixels = props.useDevicePixels;
        }
        return this;
      }
    }, {
      key: "start",
      value: function start2() {
        var _this = this;
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._running) {
          return this;
        }
        this._running = true;
        var startPromise = this._getPageLoadPromise().then(function() {
          if (!_this._running || _this._initialized) {
            return null;
          }
          _this._createWebGLContext(opts);
          _this._createFramebuffer();
          _this._startEventHandling();
          _this._initializeCallbackData();
          _this._updateCallbackData();
          _this._resizeCanvasDrawingBuffer();
          _this._resizeViewport();
          _this._gpuTimeQuery = Query.isSupported(_this.gl, ["timers"]) ? new Query(_this.gl) : null;
          _this._initialized = true;
          return _this.onInitialize(_this.animationProps);
        }).then(function(appContext) {
          if (_this._running) {
            _this._addCallbackData(appContext || {});
            if (appContext !== false) {
              _this._startLoop();
            }
          }
        });
        if (this.props.onError) {
          startPromise["catch"](this.props.onError);
        }
        return this;
      }
    }, {
      key: "redraw",
      value: function redraw() {
        if (this.isContextLost()) {
          return this;
        }
        this._beginTimers();
        this._setupFrame();
        this._updateCallbackData();
        this._renderFrame(this.animationProps);
        this._clearNeedsRedraw();
        if (this.offScreen && this.gl.commit) {
          this.gl.commit();
        }
        if (this._resolveNextFrame) {
          this._resolveNextFrame(this);
          this._nextFramePromise = null;
          this._resolveNextFrame = null;
        }
        this._endTimers();
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        if (this._running) {
          this._finalizeCallbackData();
          cancelAnimationFrame(this._animationFrameId);
          this._nextFramePromise = null;
          this._resolveNextFrame = null;
          this._animationFrameId = null;
          this._running = false;
        }
        return this;
      }
    }, {
      key: "attachTimeline",
      value: function attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
      }
    }, {
      key: "detachTimeline",
      value: function detachTimeline() {
        this.timeline = null;
      }
    }, {
      key: "waitForRender",
      value: function waitForRender() {
        var _this2 = this;
        this.setNeedsRedraw("waitForRender");
        if (!this._nextFramePromise) {
          this._nextFramePromise = new Promise(function(resolve) {
            _this2._resolveNextFrame = resolve;
          });
        }
        return this._nextFramePromise;
      }
    }, {
      key: "toDataURL",
      value: function() {
        var _toDataURL = _asyncToGenerator(import_regenerator24.default.mark(function _callee() {
          return import_regenerator24.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.setNeedsRedraw("toDataURL");
                  _context.next = 3;
                  return this.waitForRender();
                case 3:
                  return _context.abrupt("return", this.gl.canvas.toDataURL());
                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function toDataURL() {
          return _toDataURL.apply(this, arguments);
        }
        return toDataURL;
      }()
    }, {
      key: "isContextLost",
      value: function isContextLost() {
        return this.gl.isContextLost();
      }
    }, {
      key: "onCreateContext",
      value: function onCreateContext() {
        var _this$props;
        return (_this$props = this.props).onCreateContext.apply(_this$props, arguments);
      }
    }, {
      key: "onInitialize",
      value: function onInitialize() {
        var _this$props2;
        return (_this$props2 = this.props).onInitialize.apply(_this$props2, arguments);
      }
    }, {
      key: "onRender",
      value: function onRender() {
        var _this$props3;
        return (_this$props3 = this.props).onRender.apply(_this$props3, arguments);
      }
    }, {
      key: "onFinalize",
      value: function onFinalize() {
        var _this$props4;
        return (_this$props4 = this.props).onFinalize.apply(_this$props4, arguments);
      }
    }, {
      key: "getHTMLControlValue",
      value: function getHTMLControlValue(id) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var element = document.getElementById(id);
        return element ? Number(element.value) : defaultValue;
      }
    }, {
      key: "setViewParameters",
      value: function setViewParameters() {
        log.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
        return this;
      }
    }, {
      key: "_startLoop",
      value: function _startLoop() {
        var _this3 = this;
        var renderFrame = function renderFrame2() {
          if (!_this3._running) {
            return;
          }
          _this3.redraw();
          _this3._animationFrameId = _this3._requestAnimationFrame(renderFrame2);
        };
        cancelAnimationFrame(this._animationFrameId);
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
      }
    }, {
      key: "_getPageLoadPromise",
      value: function _getPageLoadPromise() {
        if (!this._pageLoadPromise) {
          this._pageLoadPromise = isPage2 ? new Promise(function(resolve, reject) {
            if (isPage2 && document.readyState === "complete") {
              resolve(document);
              return;
            }
            window.addEventListener("load", function() {
              resolve(document);
            });
          }) : Promise.resolve({});
        }
        return this._pageLoadPromise;
      }
    }, {
      key: "_setDisplay",
      value: function _setDisplay(display) {
        if (this.display) {
          this.display["delete"]();
          this.display.animationLoop = null;
        }
        if (display) {
          display.animationLoop = this;
        }
        this.display = display;
      }
    }, {
      key: "_requestAnimationFrame",
      value: function _requestAnimationFrame(renderFrameCallback) {
        if (this.display && this.display.requestAnimationFrame(renderFrameCallback)) {
          return;
        }
        requestAnimationFrame2(renderFrameCallback);
      }
    }, {
      key: "_renderFrame",
      value: function _renderFrame() {
        if (this.display) {
          var _this$display;
          (_this$display = this.display)._renderFrame.apply(_this$display, arguments);
          return;
        }
        this.onRender.apply(this, arguments);
      }
    }, {
      key: "_clearNeedsRedraw",
      value: function _clearNeedsRedraw() {
        this.needsRedraw = null;
      }
    }, {
      key: "_setupFrame",
      value: function _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._resizeFramebuffer();
      }
    }, {
      key: "_initializeCallbackData",
      value: function _initializeCallbackData() {
        this.animationProps = {
          gl: this.gl,
          stop: this.stop,
          canvas: this.gl.canvas,
          framebuffer: this.framebuffer,
          useDevicePixels: this.useDevicePixels,
          needsRedraw: null,
          startTime: Date.now(),
          engineTime: 0,
          tick: 0,
          tock: 0,
          time: 0,
          _timeline: this.timeline,
          _loop: this,
          _animationLoop: this,
          _mousePosition: null
        };
      }
    }, {
      key: "_updateCallbackData",
      value: function _updateCallbackData() {
        var _this$_getSizeAndAspe = this._getSizeAndAspect(), width = _this$_getSizeAndAspe.width, height = _this$_getSizeAndAspe.height, aspect = _this$_getSizeAndAspe.aspect;
        if (width !== this.animationProps.width || height !== this.animationProps.height) {
          this.setNeedsRedraw("drawing buffer resized");
        }
        if (aspect !== this.animationProps.aspect) {
          this.setNeedsRedraw("drawing buffer aspect changed");
        }
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) {
          this.timeline.update(this.animationProps.engineTime);
        }
        this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
        this.animationProps.tock++;
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
        this.animationProps._offScreen = this.offScreen;
      }
    }, {
      key: "_finalizeCallbackData",
      value: function _finalizeCallbackData() {
        this.onFinalize(this.animationProps);
      }
    }, {
      key: "_addCallbackData",
      value: function _addCallbackData(appContext) {
        if (_typeof(appContext) === "object" && appContext !== null) {
          this.animationProps = Object.assign({}, this.animationProps, appContext);
        }
      }
    }, {
      key: "_createWebGLContext",
      value: function _createWebGLContext(opts) {
        this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
        opts = Object.assign({}, opts, this.props.glOptions);
        this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
        if (!isWebGL(this.gl)) {
          throw new Error("AnimationLoop.onCreateContext - illegal context returned");
        }
        resetParameters(this.gl);
        this._createInfoDiv();
      }
    }, {
      key: "_createInfoDiv",
      value: function _createInfoDiv() {
        if (this.gl.canvas && this.props.onAddHTML) {
          var wrapperDiv = document.createElement("div");
          document.body.appendChild(wrapperDiv);
          wrapperDiv.style.position = "relative";
          var div = document.createElement("div");
          div.style.position = "absolute";
          div.style.left = "10px";
          div.style.bottom = "10px";
          div.style.width = "300px";
          div.style.background = "white";
          wrapperDiv.appendChild(this.gl.canvas);
          wrapperDiv.appendChild(div);
          var html = this.props.onAddHTML(div);
          if (html) {
            div.innerHTML = html;
          }
        }
      }
    }, {
      key: "_getSizeAndAspect",
      value: function _getSizeAndAspect() {
        var width = this.gl.drawingBufferWidth;
        var height = this.gl.drawingBufferHeight;
        var aspect = 1;
        var canvas = this.gl.canvas;
        if (canvas && canvas.clientHeight) {
          aspect = canvas.clientWidth / canvas.clientHeight;
        } else if (width > 0 && height > 0) {
          aspect = width / height;
        }
        return {
          width,
          height,
          aspect
        };
      }
    }, {
      key: "_resizeViewport",
      value: function _resizeViewport() {
        if (this.autoResizeViewport) {
          this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        }
      }
    }, {
      key: "_resizeCanvasDrawingBuffer",
      value: function _resizeCanvasDrawingBuffer() {
        if (this.autoResizeDrawingBuffer) {
          resizeGLContext(this.gl, {
            useDevicePixels: this.useDevicePixels
          });
        }
      }
    }, {
      key: "_createFramebuffer",
      value: function _createFramebuffer() {
        if (this.props.createFramebuffer) {
          this.framebuffer = new Framebuffer(this.gl);
        }
      }
    }, {
      key: "_resizeFramebuffer",
      value: function _resizeFramebuffer() {
        if (this.framebuffer) {
          this.framebuffer.resize({
            width: this.gl.drawingBufferWidth,
            height: this.gl.drawingBufferHeight
          });
        }
      }
    }, {
      key: "_beginTimers",
      value: function _beginTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
          this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
        }
        if (this._gpuTimeQuery) {
          this._gpuTimeQuery.beginTimeElapsedQuery();
        }
        this.cpuTime.timeStart();
      }
    }, {
      key: "_endTimers",
      value: function _endTimers() {
        this.cpuTime.timeEnd();
        if (this._gpuTimeQuery) {
          this._gpuTimeQuery.end();
        }
      }
    }, {
      key: "_startEventHandling",
      value: function _startEventHandling() {
        var canvas = this.gl.canvas;
        if (canvas) {
          canvas.addEventListener("mousemove", this._onMousemove);
          canvas.addEventListener("mouseleave", this._onMouseleave);
        }
      }
    }, {
      key: "_onMousemove",
      value: function _onMousemove(e) {
        this.animationProps._mousePosition = [e.offsetX, e.offsetY];
      }
    }, {
      key: "_onMouseleave",
      value: function _onMouseleave(e) {
        this.animationProps._mousePosition = null;
      }
    }]);
    return AnimationLoop2;
  }();

  // node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
  var VERTEX_SHADER = "vs";
  var FRAGMENT_SHADER = "fs";

  // node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
  function assert6(condition, message) {
    if (!condition) {
      throw new Error(message || "shadertools: assertion failed.");
    }
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
  var TYPE_DEFINITIONS = {
    number: {
      validate: function validate(value17, propType) {
        return Number.isFinite(value17) && (!("max" in propType) || value17 <= propType.max) && (!("min" in propType) || value17 >= propType.min);
      }
    },
    array: {
      validate: function validate2(value17, propType) {
        return Array.isArray(value17) || ArrayBuffer.isView(value17);
      }
    }
  };
  function parsePropTypes(propDefs) {
    var propTypes = {};
    for (var propName in propDefs) {
      var propDef = propDefs[propName];
      var propType = parsePropType(propDef);
      propTypes[propName] = propType;
    }
    return propTypes;
  }
  function parsePropType(propDef) {
    var type = getTypeOf(propDef);
    if (type === "object") {
      if (!propDef) {
        return {
          type: "object",
          value: null
        };
      }
      if ("type" in propDef) {
        return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
      }
      if (!("value" in propDef)) {
        return {
          type: "object",
          value: propDef
        };
      }
      type = getTypeOf(propDef.value);
      return Object.assign({
        type
      }, propDef, TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
      type,
      value: propDef
    }, TYPE_DEFINITIONS[type]);
  }
  function getTypeOf(value17) {
    if (Array.isArray(value17) || ArrayBuffer.isView(value17)) {
      return "array";
    }
    return _typeof(value17);
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
  var VERTEX_SHADER2 = "vs";
  var FRAGMENT_SHADER2 = "fs";
  var ShaderModule = function() {
    function ShaderModule2(_ref) {
      var name = _ref.name, vs7 = _ref.vs, fs4 = _ref.fs, _ref$dependencies = _ref.dependencies, dependencies = _ref$dependencies === void 0 ? [] : _ref$dependencies, uniforms = _ref.uniforms, getUniforms6 = _ref.getUniforms, _ref$deprecations = _ref.deprecations, deprecations = _ref$deprecations === void 0 ? [] : _ref$deprecations, _ref$defines = _ref.defines, defines = _ref$defines === void 0 ? {} : _ref$defines, _ref$inject = _ref.inject, inject = _ref$inject === void 0 ? {} : _ref$inject, vertexShader = _ref.vertexShader, fragmentShader = _ref.fragmentShader;
      _classCallCheck(this, ShaderModule2);
      assert6(typeof name === "string");
      this.name = name;
      this.vs = vs7 || vertexShader;
      this.fs = fs4 || fragmentShader;
      this.getModuleUniforms = getUniforms6;
      this.dependencies = dependencies;
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines;
      this.injections = normalizeInjections(inject);
      if (uniforms) {
        this.uniforms = parsePropTypes(uniforms);
      }
    }
    _createClass(ShaderModule2, [{
      key: "getModuleSource",
      value: function getModuleSource(type) {
        var moduleSource;
        switch (type) {
          case VERTEX_SHADER2:
            moduleSource = this.vs || "";
            break;
          case FRAGMENT_SHADER2:
            moduleSource = this.fs || "";
            break;
          default:
            assert6(false);
        }
        return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
      }
    }, {
      key: "getUniforms",
      value: function getUniforms6(opts, uniforms) {
        if (this.getModuleUniforms) {
          return this.getModuleUniforms(opts, uniforms);
        }
        if (this.uniforms) {
          return this._defaultGetUniforms(opts);
        }
        return {};
      }
    }, {
      key: "getDefines",
      value: function getDefines() {
        return this.defines;
      }
    }, {
      key: "checkDeprecations",
      value: function checkDeprecations(shaderSource, log3) {
        this.deprecations.forEach(function(def) {
          if (def.regex.test(shaderSource)) {
            if (def.deprecated) {
              log3.deprecated(def.old, def["new"])();
            } else {
              log3.removed(def.old, def["new"])();
            }
          }
        });
      }
    }, {
      key: "_parseDeprecationDefinitions",
      value: function _parseDeprecationDefinitions(deprecations) {
        deprecations.forEach(function(def) {
          switch (def.type) {
            case "function":
              def.regex = new RegExp("\\b".concat(def.old, "\\("));
              break;
            default:
              def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
          }
        });
        return deprecations;
      }
    }, {
      key: "_defaultGetUniforms",
      value: function _defaultGetUniforms() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var uniforms = {};
        var propTypes = this.uniforms;
        for (var key in propTypes) {
          var propDef = propTypes[key];
          if (key in opts && !propDef["private"]) {
            if (propDef.validate) {
              assert6(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
            }
            uniforms[key] = opts[key];
          } else {
            uniforms[key] = propDef.value;
          }
        }
        return uniforms;
      }
    }]);
    return ShaderModule2;
  }();
  function normalizeInjections(injections) {
    var result = {
      vs: {},
      fs: {}
    };
    for (var hook in injections) {
      var injection = injections[hook];
      var stage = hook.slice(0, 2);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
  function _createForOfIteratorHelper17(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray18(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray18(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray18(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray18(o, minLen);
  }
  function _arrayLikeToArray18(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function resolveModules(modules) {
    return getShaderDependencies(instantiateModules(modules));
  }
  function getShaderDependencies(modules) {
    var moduleMap = {};
    var moduleDepth = {};
    getDependencyGraph({
      modules,
      level: 0,
      moduleMap,
      moduleDepth
    });
    return Object.keys(moduleDepth).sort(function(a, b) {
      return moduleDepth[b] - moduleDepth[a];
    }).map(function(name) {
      return moduleMap[name];
    });
  }
  function getDependencyGraph(_ref) {
    var modules = _ref.modules, level = _ref.level, moduleMap = _ref.moduleMap, moduleDepth = _ref.moduleDepth;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    var _iterator = _createForOfIteratorHelper17(modules), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var module2 = _step.value;
        moduleMap[module2.name] = module2;
        if (moduleDepth[module2.name] === void 0 || moduleDepth[module2.name] < level) {
          moduleDepth[module2.name] = level;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper17(modules), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _module = _step2.value;
        if (_module.dependencies) {
          getDependencyGraph({
            modules: _module.dependencies,
            level: level + 1,
            moduleMap,
            moduleDepth
          });
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  function instantiateModules(modules, seen) {
    return modules.map(function(module2) {
      if (module2 instanceof ShaderModule) {
        return module2;
      }
      assert6(typeof module2 !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module2, "' and use it directly."));
      assert6(module2.name, "shader module has no name");
      module2 = new ShaderModule(module2);
      module2.dependencies = instantiateModules(module2.dependencies);
      return module2;
    });
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
  function isOldIE() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
    var userAgent2 = opts.userAgent || navigator2.userAgent || "";
    var isMSIE = userAgent2.indexOf("MSIE ") !== -1;
    var isTrident = userAgent2.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
  var GL_VENDOR = 7936;
  var GL_RENDERER = 7937;
  var GL_VERSION = 7938;
  var GL_SHADING_LANGUAGE_VERSION = 35724;
  var WEBGL_FEATURES = {
    GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
    GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
    GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
    GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
  };
  var FEATURES2 = {};
  Object.keys(WEBGL_FEATURES).forEach(function(key) {
    FEATURES2[key] = key;
  });
  function isWebGL22(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getContextInfo(gl) {
    var info = gl.getExtension("WEBGL_debug_renderer_info");
    var vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
    var renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
    var gpuVendor = identifyGPUVendor(vendor, renderer);
    var gpuInfo = {
      gpuVendor,
      vendor,
      renderer,
      version: gl.getParameter(GL_VERSION),
      shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
  }
  function identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
      return "NVIDIA";
    }
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
      return "INTEL";
    }
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
      return "AMD";
    }
    return "UNKNOWN GPU";
  }
  var compiledGlslExtensions = {};
  function canCompileGLGSExtension(gl, cap) {
    var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var feature = WEBGL_FEATURES[cap];
    assert6(feature, cap);
    if (!isOldIE(opts)) {
      return true;
    }
    if (cap in compiledGlslExtensions) {
      return compiledGlslExtensions[cap];
    }
    var extensionName = feature[0];
    var behavior = opts.behavior || "enable";
    var source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    var shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    compiledGlslExtensions[cap] = canCompile;
    return canCompile;
  }
  function getFeature(gl, cap) {
    var feature = WEBGL_FEATURES[cap];
    assert6(feature, cap);
    var extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
    var value17 = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    assert6(value17 === false || value17 === true);
    return value17;
  }
  function hasFeatures2(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every(function(feature) {
      return getFeature(gl, feature);
    });
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
  function getPlatformShaderDefines(gl) {
    var debugInfo = getContextInfo(gl);
    switch (debugInfo.gpuVendor.toLowerCase()) {
      case "nvidia":
        return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
      case "intel":
        return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
      case "amd":
        return "#define AMD_GPU\n";
      default:
        return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
  }
  function getVersionDefines(gl, glslVersion, isFragment) {
    var versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
      versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES2.GLSL_DERIVATIVES)) {
      versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES2.GLSL_FRAG_DATA, {
      behavior: "require"
    })) {
      versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
      versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    }
    return versionDefines;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
  var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
  var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";

  // node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
  var _MODULE_INJECTORS;
  var MODULE_INJECTORS = (_MODULE_INJECTORS = {}, _defineProperty(_MODULE_INJECTORS, VERTEX_SHADER, MODULE_INJECTORS_VS), _defineProperty(_MODULE_INJECTORS, FRAGMENT_SHADER, MODULE_INJECTORS_FS), _MODULE_INJECTORS);
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  function injectShader(source, type, inject) {
    var injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var isVertex = type === VERTEX_SHADER;
    var _loop = function _loop2(key2) {
      var fragmentData = inject[key2];
      fragmentData.sort(function(a, b) {
        return a.order - b.order;
      });
      fragments.length = fragmentData.length;
      for (var i = 0, len2 = fragmentData.length; i < len2; ++i) {
        fragments[i] = fragmentData[i].injection;
      }
      var fragmentString = "".concat(fragments.join("\n"), "\n");
      switch (key2) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, function(match) {
              return match + fragmentString;
            });
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, function(match) {
              return fragmentString + match;
            });
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, function(match) {
              return match + fragmentString;
            });
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, function(match) {
              return fragmentString + match;
            });
          }
          break;
        default:
          source = source.replace(key2, function(match) {
            return match + fragmentString;
          });
      }
    };
    for (var key in inject) {
      _loop(key);
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, function(match) {
        return match + MODULE_INJECTORS[type];
      });
    }
    return source;
  }
  function combineInjects(injects) {
    var result = {};
    assert6(Array.isArray(injects) && injects.length > 1);
    injects.forEach(function(inject) {
      for (var key in inject) {
        result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
      }
    });
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
  function _createForOfIteratorHelper18(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray19(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray19(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray19(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray19(o, minLen);
  }
  function _arrayLikeToArray19(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var ES300_VERTEX_REPLACEMENTS = [].concat(ES300_REPLACEMENTS, [[/^[ \t]*attribute[ \t]+(.+;)/gm, "in $1"], [/^[ \t]*varying[ \t]+(.+;)/gm, "out $1"]]);
  var ES300_FRAGMENT_REPLACEMENTS = [].concat(ES300_REPLACEMENTS, [[/^[ \t]*varying[ \t]+(.+;)/gm, "in $1"]]);
  var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var ES100_VERTEX_REPLACEMENTS = [].concat(ES100_REPLACEMENTS, [[/^[ \t]*in[ \t]+(.+;)/gm, "attribute $1"], [/^[ \t]*out[ \t]+(.+;)/gm, "varying $1"]]);
  var ES100_FRAGMENT_REPLACEMENTS = [].concat(ES100_REPLACEMENTS, [[/^[ \t]*in[ \t]+/gm, "varying "]]);
  var FS_OUTPUT_REGEX = /^[ \t]*out[ \t]+vec4[ \t]+(\w+)[ \t]*;\s+/m;
  function transpileShader(source, targetGLSLVersion, isVertex) {
    switch (targetGLSLVersion) {
      case 300:
        return convertShader(source, isVertex ? ES300_VERTEX_REPLACEMENTS : ES300_FRAGMENT_REPLACEMENTS);
      case 100:
        return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
      default:
        throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
  }
  function convertShader(source, replacements) {
    var _iterator = _createForOfIteratorHelper18(replacements), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), pattern = _step$value[0], replacement = _step$value[1];
        source = source.replace(pattern, replacement);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return source;
  }
  function convertFragmentShaderTo100(source) {
    source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
    var outputMatch = source.match(FS_OUTPUT_REGEX);
    if (outputMatch) {
      var outputName = outputMatch[1];
      source = source.replace(FS_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), "gl_FragColor");
    }
    return source;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
  var _SHADER_TYPE;
  function _createForOfIteratorHelper19(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray20(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray20(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray20(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray20(o, minLen);
  }
  function _arrayLikeToArray20(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
  var SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, "vertex"), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, "fragment"), _SHADER_TYPE);
  var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  function assembleShaders(gl, opts) {
    var vs7 = opts.vs, fs4 = opts.fs;
    var modules = resolveModules(opts.modules || []);
    return {
      gl,
      vs: assembleShader(gl, Object.assign({}, opts, {
        source: vs7,
        type: VERTEX_SHADER,
        modules
      })),
      fs: assembleShader(gl, Object.assign({}, opts, {
        source: fs4,
        type: FRAGMENT_SHADER,
        modules
      })),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShader(gl, _ref) {
    var id = _ref.id, source = _ref.source, type = _ref.type, modules = _ref.modules, _ref$defines = _ref.defines, defines = _ref$defines === void 0 ? {} : _ref$defines, _ref$hookFunctions = _ref.hookFunctions, hookFunctions = _ref$hookFunctions === void 0 ? [] : _ref$hookFunctions, _ref$inject = _ref.inject, inject = _ref$inject === void 0 ? {} : _ref$inject, _ref$transpileToGLSL = _ref.transpileToGLSL100, transpileToGLSL100 = _ref$transpileToGLSL === void 0 ? false : _ref$transpileToGLSL, _ref$prologue = _ref.prologue, prologue = _ref$prologue === void 0 ? true : _ref$prologue, log3 = _ref.log;
    assert6(typeof source === "string", "shader source must be a string");
    var isVertex = type === VERTEX_SHADER;
    var sourceLines = source.split("\n");
    var glslVersion = 100;
    var versionLine = "";
    var coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
      glslVersion = 300;
      versionLine = sourceLines[0];
      coreSource = sourceLines.slice(1).join("\n");
    } else {
      versionLine = "#version ".concat(glslVersion);
    }
    var allDefines = {};
    modules.forEach(function(module3) {
      Object.assign(allDefines, module3.getDefines());
    });
    Object.assign(allDefines, defines);
    var assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
      id,
      source,
      type
    }), "\n").concat(getShaderType({
      type
    }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    var hookFunctionMap = normalizeHookFunctions(hookFunctions);
    var hookInjections = {};
    var declInjections = {};
    var mainInjections = {};
    for (var key in inject) {
      var injection = typeof inject[key] === "string" ? {
        injection: inject[key],
        order: 0
      } : inject[key];
      var match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
      if (match) {
        var hash = match[2];
        var name = match[3];
        if (hash) {
          if (name === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    var _iterator = _createForOfIteratorHelper19(modules), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var module2 = _step.value;
        if (log3) {
          module2.checkDeprecations(coreSource, log3);
        }
        var moduleSource = module2.getModuleSource(type, glslVersion);
        assembledSource += moduleSource;
        var injections = module2.injections[type];
        for (var _key in injections) {
          var _match = _key.match(/^(v|f)s:#([\w-]+)$/);
          if (_match) {
            var _name = _match[2];
            var injectionType = _name === "decl" ? declInjections : mainInjections;
            injectionType[_key] = injectionType[_key] || [];
            injectionType[_key].push(injections[_key]);
          } else {
            hookInjections[_key] = hookInjections[_key] || [];
            hookInjections[_key].push(injections[_key]);
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, type, declInjections);
    assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, type, mainInjections);
    assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
  }
  function assembleGetUniforms(modules) {
    return function getUniforms6(opts) {
      var uniforms = {};
      var _iterator2 = _createForOfIteratorHelper19(modules), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var module2 = _step2.value;
          var moduleUniforms = module2.getUniforms(opts, uniforms);
          Object.assign(uniforms, moduleUniforms);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return uniforms;
    };
  }
  function getShaderType(_ref2) {
    var type = _ref2.type;
    return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
  }
  function getShaderName2(_ref3) {
    var id = _ref3.id, source = _ref3.source, type = _ref3.type;
    var injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
  }
  function getApplicationDefines() {
    var defines = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var count3 = 0;
    var sourceText = "";
    for (var define2 in defines) {
      if (count3 === 0) {
        sourceText += "\n// APPLICATION DEFINES\n";
      }
      count3++;
      var value17 = defines[define2];
      if (value17 || Number.isFinite(value17)) {
        sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines[define2], "\n");
      }
    }
    if (count3 === 0) {
      sourceText += "\n";
    }
    return sourceText;
  }
  function getHookFunctions(hookFunctions, hookInjections) {
    var result = "";
    for (var hookName in hookFunctions) {
      var hookFunction = hookFunctions[hookName];
      result += "void ".concat(hookFunction.signature, " {\n");
      if (hookFunction.header) {
        result += "  ".concat(hookFunction.header);
      }
      if (hookInjections[hookName]) {
        var injections = hookInjections[hookName];
        injections.sort(function(a, b) {
          return a.order - b.order;
        });
        var _iterator3 = _createForOfIteratorHelper19(injections), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var injection = _step3.value;
            result += "  ".concat(injection.injection, "\n");
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      if (hookFunction.footer) {
        result += "  ".concat(hookFunction.footer);
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeHookFunctions(hookFunctions) {
    var result = {
      vs: {},
      fs: {}
    };
    hookFunctions.forEach(function(hook) {
      var opts;
      if (typeof hook !== "string") {
        opts = hook;
        hook = opts.hook;
      } else {
        opts = {};
      }
      hook = hook.trim();
      var _hook$split = hook.split(":"), _hook$split2 = _slicedToArray(_hook$split, 2), stage = _hook$split2[0], signature = _hook$split2[1];
      var name = hook.replace(/\(.+/, "");
      result[stage][name] = Object.assign(opts, {
        signature
      });
    });
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
  var FS100 = "void main() {gl_FragColor = vec4(0);}";
  var FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
  var FS300 = "#version 300 es\n".concat(FS_GLES);
  function getQualifierDetails(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
    var words = line.replace(/^\s+/, "").split(/\s+/);
    var _words = _slicedToArray(words, 3), qualifier = _words[0], type = _words[1], definition = _words[2];
    if (!qualifiers.includes(qualifier) || !type || !definition) {
      return null;
    }
    var name = definition.split(";")[0];
    return {
      qualifier,
      type,
      name
    };
  }
  function getPassthroughFS() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _options$version = options.version, version2 = _options$version === void 0 ? 100 : _options$version, input = options.input, inputType = options.inputType, output = options.output;
    if (!input) {
      if (version2 === 300) {
        return FS300;
      } else if (version2 > 300) {
        return "#version ".concat(version2, "\n").concat(FS_GLES);
      }
      return FS100;
    }
    var outputValue = convertToVec4(input, inputType);
    if (version2 >= 300) {
      return "#version ".concat(version2, " ").concat(version2 === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
    }
    return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
  }
  function typeToChannelSuffix(type) {
    switch (type) {
      case "float":
        return "x";
      case "vec2":
        return "xy";
      case "vec3":
        return "xyz";
      case "vec4":
        return "xyzw";
      default:
        assert6(false);
        return null;
    }
  }
  function typeToChannelCount(type) {
    switch (type) {
      case "float":
        return 1;
      case "vec2":
        return 2;
      case "vec3":
        return 3;
      case "vec4":
        return 4;
      default:
        assert6(false);
        return null;
    }
  }
  function convertToVec4(variable, type) {
    switch (type) {
      case "float":
        return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
      case "vec2":
        return "vec4(".concat(variable, ", 0.0, 1.0)");
      case "vec3":
        return "vec4(".concat(variable, ", 1.0)");
      case "vec4":
        return variable;
      default:
        assert6(false);
        return null;
    }
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
  var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
  var fp32 = {
    name: "fp32",
    vs: fp32shader,
    fs: null
  };

  // node_modules/@math.gl/core/dist/esm/lib/assert.js
  function assert7(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message));
    }
  }

  // node_modules/@math.gl/core/dist/esm/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var config = {};
  config.EPSILON = 1e-12;
  config.debug = false;
  config.precision = 4;
  config.printTypes = false;
  config.printDegrees = false;
  config.printRowMajor = true;
  function round(value17) {
    return Math.round(value17 / config.EPSILON) * config.EPSILON;
  }
  function formatValue2(value17) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$precision = _ref.precision, precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;
    value17 = round(value17);
    return "".concat(parseFloat(value17.toPrecision(precision)));
  }
  function isArray2(value17) {
    return Array.isArray(value17) || ArrayBuffer.isView(value17) && !(value17 instanceof DataView);
  }
  function duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map(value17, func, result) {
    if (isArray2(value17)) {
      result = result || duplicateArray(value17);
      for (var i = 0; i < result.length && i < value17.length; ++i) {
        result[i] = func(value17[i], i, result);
      }
      return result;
    }
    return func(value17);
  }
  function clamp(value17, min, max) {
    return map(value17, function(value18) {
      return Math.max(min, Math.min(max, value18));
    });
  }
  function lerp(a, b, t) {
    if (isArray2(a)) {
      return a.map(function(ai, i) {
        return lerp(ai, b[i], t);
      });
    }
    return t * b + (1 - t) * a;
  }
  function equals(a, b, epsilon) {
    var oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a === b) {
        return true;
      }
      if (isArray2(a) && isArray2(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; ++i) {
          if (!equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a && a.equals) {
        return a.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a);
      }
      if (Number.isFinite(a) && Number.isFinite(b)) {
        return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  // node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }

  // node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
  function _createSuper13(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct14();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct14() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var MathArray = function(_Array) {
    _inherits(MathArray2, _Array);
    var _super = _createSuper13(MathArray2);
    function MathArray2() {
      _classCallCheck(this, MathArray2);
      return _super.apply(this, arguments);
    }
    _createClass(MathArray2, [{
      key: "clone",
      value: function clone3() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "from",
      value: function from(arrayOrObject) {
        return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = array[i + offset];
        }
        return this.check();
      }
    }, {
      key: "to",
      value: function to(arrayOrObject) {
        if (arrayOrObject === this) {
          return this;
        }
        return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
      }
    }, {
      key: "toTarget",
      value: function toTarget(target) {
        return target ? this.to(target) : this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        for (var i = 0; i < this.ELEMENTS; ++i) {
          array[offset + i] = this[i];
        }
        return array;
      }
    }, {
      key: "toFloat32Array",
      value: function toFloat32Array() {
        return new Float32Array(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.formatString(config);
      }
    }, {
      key: "formatString",
      value: function formatString(opts) {
        var string = "";
        for (var i = 0; i < this.ELEMENTS; ++i) {
          string += (i > 0 ? ", " : "") + formatValue2(this[i], opts);
        }
        return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
      }
    }, {
      key: "equals",
      value: function equals5(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (var i = 0; i < this.ELEMENTS; ++i) {
          if (!equals(this[i], array[i])) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "exactEquals",
      value: function exactEquals3(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (var i = 0; i < this.ELEMENTS; ++i) {
          if (this[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "negate",
      value: function negate3() {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = -this[i];
        }
        return this.check();
      }
    }, {
      key: "lerp",
      value: function lerp7(a, b, t) {
        if (t === void 0) {
          t = b;
          b = a;
          a = this;
        }
        for (var i = 0; i < this.ELEMENTS; ++i) {
          var ai = a[i];
          this[i] = ai + t * (b[i] - ai);
        }
        return this.check();
      }
    }, {
      key: "min",
      value: function min(vector) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(vector[i], this[i]);
        }
        return this.check();
      }
    }, {
      key: "max",
      value: function max(vector) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.max(vector[i], this[i]);
        }
        return this.check();
      }
    }, {
      key: "clamp",
      value: function clamp2(minVector, maxVector) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
        }
        return this.check();
      }
    }, {
      key: "add",
      value: function add6() {
        for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
          vectors[_key] = arguments[_key];
        }
        for (var _i = 0, _vectors = vectors; _i < _vectors.length; _i++) {
          var vector = _vectors[_i];
          for (var i = 0; i < this.ELEMENTS; ++i) {
            this[i] += vector[i];
          }
        }
        return this.check();
      }
    }, {
      key: "subtract",
      value: function subtract2() {
        for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          vectors[_key2] = arguments[_key2];
        }
        for (var _i2 = 0, _vectors2 = vectors; _i2 < _vectors2.length; _i2++) {
          var vector = _vectors2[_i2];
          for (var i = 0; i < this.ELEMENTS; ++i) {
            this[i] -= vector[i];
          }
        }
        return this.check();
      }
    }, {
      key: "scale",
      value: function scale5(_scale) {
        if (Array.isArray(_scale)) {
          return this.multiply(_scale);
        }
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= _scale;
        }
        return this.check();
      }
    }, {
      key: "sub",
      value: function sub2(a) {
        return this.subtract(a);
      }
    }, {
      key: "setScalar",
      value: function setScalar(a) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = a;
        }
        return this.check();
      }
    }, {
      key: "addScalar",
      value: function addScalar(a) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] += a;
        }
        return this.check();
      }
    }, {
      key: "subScalar",
      value: function subScalar(a) {
        return this.addScalar(-a);
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(scalar) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scalar;
        }
        return this.check();
      }
    }, {
      key: "divideScalar",
      value: function divideScalar(a) {
        return this.scale(1 / a);
      }
    }, {
      key: "clampScalar",
      value: function clampScalar(min, max) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(Math.max(this[i], min), max);
        }
        return this.check();
      }
    }, {
      key: "multiplyByScalar",
      value: function multiplyByScalar(scalar) {
        return this.scale(scalar);
      }
    }, {
      key: "check",
      value: function check() {
        if (config.debug && !this.validate()) {
          throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
        }
        return this;
      }
    }, {
      key: "validate",
      value: function validate11() {
        var valid = this.length === this.ELEMENTS;
        for (var i = 0; i < this.ELEMENTS; ++i) {
          valid = valid && Number.isFinite(this[i]);
        }
        return valid;
      }
    }, {
      key: "ELEMENTS",
      get: function get2() {
        assert7(false);
        return 0;
      }
    }, {
      key: "RANK",
      get: function get2() {
        assert7(false);
        return 0;
      }
    }, {
      key: "elements",
      get: function get2() {
        return this;
      }
    }]);
    return MathArray2;
  }(_wrapNativeSuper(Array));

  // node_modules/@math.gl/core/dist/esm/lib/validators.js
  function validateVector(v, length4) {
    if (v.length !== length4) {
      return false;
    }
    for (var i = 0; i < v.length; ++i) {
      if (!Number.isFinite(v[i])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value17) {
    if (!Number.isFinite(value17)) {
      throw new Error("Invalid number ".concat(value17));
    }
    return value17;
  }
  function checkVector(v, length4) {
    var callerName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    if (config.debug && !validateVector(v, length4)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v;
  }
  var map2 = {};
  function deprecated(method, version2) {
    if (!map2[method]) {
      map2[method] = true;
      console.warn("".concat(method, " has been removed in version ").concat(version2, ", see upgrade guide for more information"));
    }
  }

  // node_modules/@math.gl/core/dist/esm/classes/base/vector.js
  function _createSuper14(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct15();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct15() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Vector = function(_MathArray) {
    _inherits(Vector2, _MathArray);
    var _super = _createSuper14(Vector2);
    function Vector2() {
      _classCallCheck(this, Vector2);
      return _super.apply(this, arguments);
    }
    _createClass(Vector2, [{
      key: "copy",
      value: function copy3(vector) {
        assert7(false);
        return this;
      }
    }, {
      key: "len",
      value: function len2() {
        return Math.sqrt(this.lengthSquared());
      }
    }, {
      key: "magnitude",
      value: function magnitude() {
        return this.len();
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        var length4 = 0;
        for (var i = 0; i < this.ELEMENTS; ++i) {
          length4 += this[i] * this[i];
        }
        return length4;
      }
    }, {
      key: "magnitudeSquared",
      value: function magnitudeSquared() {
        return this.lengthSquared();
      }
    }, {
      key: "distance",
      value: function distance2(mathArray) {
        return Math.sqrt(this.distanceSquared(mathArray));
      }
    }, {
      key: "distanceSquared",
      value: function distanceSquared(mathArray) {
        var length4 = 0;
        for (var i = 0; i < this.ELEMENTS; ++i) {
          var dist = this[i] - mathArray[i];
          length4 += dist * dist;
        }
        return checkNumber(length4);
      }
    }, {
      key: "dot",
      value: function dot4(mathArray) {
        var product = 0;
        for (var i = 0; i < this.ELEMENTS; ++i) {
          product += this[i] * mathArray[i];
        }
        return checkNumber(product);
      }
    }, {
      key: "normalize",
      value: function normalize5() {
        var length4 = this.magnitude();
        if (length4 !== 0) {
          for (var i = 0; i < this.ELEMENTS; ++i) {
            this[i] /= length4;
          }
        }
        return this.check();
      }
    }, {
      key: "multiply",
      value: function multiply5() {
        for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
          vectors[_key] = arguments[_key];
        }
        for (var _i = 0, _vectors = vectors; _i < _vectors.length; _i++) {
          var vector = _vectors[_i];
          for (var i = 0; i < this.ELEMENTS; ++i) {
            this[i] *= vector[i];
          }
        }
        return this.check();
      }
    }, {
      key: "divide",
      value: function divide() {
        for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          vectors[_key2] = arguments[_key2];
        }
        for (var _i2 = 0, _vectors2 = vectors; _i2 < _vectors2.length; _i2++) {
          var vector = _vectors2[_i2];
          for (var i = 0; i < this.ELEMENTS; ++i) {
            this[i] /= vector[i];
          }
        }
        return this.check();
      }
    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.lengthSquared();
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(vector) {
        return this.distance(vector);
      }
    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(vector) {
        return this.distanceSquared(vector);
      }
    }, {
      key: "getComponent",
      value: function getComponent(i) {
        assert7(i >= 0 && i < this.ELEMENTS, "index is out of range");
        return checkNumber(this[i]);
      }
    }, {
      key: "setComponent",
      value: function setComponent(i, value17) {
        assert7(i >= 0 && i < this.ELEMENTS, "index is out of range");
        this[i] = value17;
        return this.check();
      }
    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        return this.copy(a).add(b);
      }
    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        return this.copy(a).subtract(b);
      }
    }, {
      key: "multiplyVectors",
      value: function multiplyVectors(a, b) {
        return this.copy(a).multiply(b);
      }
    }, {
      key: "addScaledVector",
      value: function addScaledVector(a, b) {
        return this.add(new this.constructor(a).multiplyScalar(b));
      }
    }, {
      key: "x",
      get: function get2() {
        return this[0];
      },
      set: function set2(value17) {
        this[0] = checkNumber(value17);
      }
    }, {
      key: "y",
      get: function get2() {
        return this[1];
      },
      set: function set2(value17) {
        this[1] = checkNumber(value17);
      }
    }]);
    return Vector2;
  }(MathArray);

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };

  // node_modules/gl-matrix/esm/vec2.js
  function create() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  var forEach2 = function() {
    var vec = create();
    return function(a, stride, offset, count3, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l = Math.min(count3 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a, m) {
    var x = a[0];
    var y = a[1];
    var w = m[3] * x + m[7] * y || 1;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a, m) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
  }
  function vec3_transformMat2(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    return out;
  }
  function vec4_transformMat3(out, a, m) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    out[0] = m[0] * x + m[3] * y + m[6] * z;
    out[1] = m[1] * x + m[4] * y + m[7] * z;
    out[2] = m[2] * x + m[5] * y + m[8] * z;
    out[3] = a[3];
    return out;
  }

  // node_modules/gl-matrix/esm/vec3.js
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len2 = x * x + y * y + z * z;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = a[0] * len2;
    out[1] = a[1] * len2;
    out[2] = a[2] * len2;
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp3(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat32(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var sub = subtract;
  var mul = multiply;
  var len = length;
  var sqrLen = squaredLength;
  var forEach3 = function() {
    var vec = create2();
    return function(a, stride, offset, count3, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l = Math.min(count3 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/vector3.js
  function _createSuper15(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct16();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct16() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var ORIGIN = [0, 0, 0];
  var constants = {};
  var Vector3 = function(_Vector) {
    _inherits(Vector32, _Vector);
    var _super = _createSuper15(Vector32);
    _createClass(Vector32, null, [{
      key: "ZERO",
      get: function get2() {
        return constants.ZERO = constants.ZERO || Object.freeze(new Vector32(0, 0, 0, 0));
      }
    }]);
    function Vector32() {
      var _this;
      var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      _classCallCheck(this, Vector32);
      _this = _super.call(this, -0, -0, -0);
      if (arguments.length === 1 && isArray2(x)) {
        _this.copy(x);
      } else {
        if (config.debug) {
          checkNumber(x);
          checkNumber(y);
          checkNumber(z);
        }
        _this[0] = x;
        _this[1] = y;
        _this[2] = z;
      }
      return _this;
    }
    _createClass(Vector32, [{
      key: "set",
      value: function set2(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this.check();
      }
    }, {
      key: "copy",
      value: function copy3(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        return this.check();
      }
    }, {
      key: "fromObject",
      value: function fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
          checkNumber(object.z);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        return this.check();
      }
    }, {
      key: "toObject",
      value: function toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        return object;
      }
    }, {
      key: "angle",
      value: function angle2(vector) {
        return angle(this, vector);
      }
    }, {
      key: "cross",
      value: function cross2(vector) {
        cross(this, this, vector);
        return this.check();
      }
    }, {
      key: "rotateX",
      value: function rotateX4(_ref) {
        var radians2 = _ref.radians, _ref$origin = _ref.origin, origin = _ref$origin === void 0 ? ORIGIN : _ref$origin;
        rotateX(this, this, origin, radians2);
        return this.check();
      }
    }, {
      key: "rotateY",
      value: function rotateY4(_ref2) {
        var radians2 = _ref2.radians, _ref2$origin = _ref2.origin, origin = _ref2$origin === void 0 ? ORIGIN : _ref2$origin;
        rotateY(this, this, origin, radians2);
        return this.check();
      }
    }, {
      key: "rotateZ",
      value: function rotateZ4(_ref3) {
        var radians2 = _ref3.radians, _ref3$origin = _ref3.origin, origin = _ref3$origin === void 0 ? ORIGIN : _ref3$origin;
        rotateZ(this, this, origin, radians2);
        return this.check();
      }
    }, {
      key: "transform",
      value: function transform4(matrix4) {
        return this.transformAsPoint(matrix4);
      }
    }, {
      key: "transformAsPoint",
      value: function transformAsPoint(matrix4) {
        transformMat42(this, this, matrix4);
        return this.check();
      }
    }, {
      key: "transformAsVector",
      value: function transformAsVector(matrix4) {
        vec3_transformMat4AsVector(this, this, matrix4);
        return this.check();
      }
    }, {
      key: "transformByMatrix3",
      value: function transformByMatrix3(matrix3) {
        transformMat32(this, this, matrix3);
        return this.check();
      }
    }, {
      key: "transformByMatrix2",
      value: function transformByMatrix2(matrix2) {
        vec3_transformMat2(this, this, matrix2);
        return this.check();
      }
    }, {
      key: "transformByQuaternion",
      value: function transformByQuaternion(quaternion) {
        transformQuat(this, this, quaternion);
        return this.check();
      }
    }, {
      key: "ELEMENTS",
      get: function get2() {
        return 3;
      }
    }, {
      key: "z",
      get: function get2() {
        return this[2];
      },
      set: function set2(value17) {
        this[2] = checkNumber(value17);
      }
    }]);
    return Vector32;
  }(Vector);

  // node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
  function _createSuper16(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct17();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct17() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Matrix = function(_MathArray) {
    _inherits(Matrix2, _MathArray);
    var _super = _createSuper16(Matrix2);
    function Matrix2() {
      _classCallCheck(this, Matrix2);
      return _super.apply(this, arguments);
    }
    _createClass(Matrix2, [{
      key: "toString",
      value: function toString() {
        var string = "[";
        if (config.printRowMajor) {
          string += "row-major:";
          for (var row = 0; row < this.RANK; ++row) {
            for (var col = 0; col < this.RANK; ++col) {
              string += " ".concat(this[col * this.RANK + row]);
            }
          }
        } else {
          string += "column-major:";
          for (var i = 0; i < this.ELEMENTS; ++i) {
            string += " ".concat(this[i]);
          }
        }
        string += "]";
        return string;
      }
    }, {
      key: "getElementIndex",
      value: function getElementIndex(row, col) {
        return col * this.RANK + row;
      }
    }, {
      key: "getElement",
      value: function getElement(row, col) {
        return this[col * this.RANK + row];
      }
    }, {
      key: "setElement",
      value: function setElement(row, col, value17) {
        this[col * this.RANK + row] = checkNumber(value17);
        return this;
      }
    }, {
      key: "getColumn",
      value: function getColumn(columnIndex) {
        var result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array(this.RANK).fill(-0);
        var firstIndex = columnIndex * this.RANK;
        for (var i = 0; i < this.RANK; ++i) {
          result[i] = this[firstIndex + i];
        }
        return result;
      }
    }, {
      key: "setColumn",
      value: function setColumn(columnIndex, columnVector) {
        var firstIndex = columnIndex * this.RANK;
        for (var i = 0; i < this.RANK; ++i) {
          this[firstIndex + i] = columnVector[i];
        }
        return this;
      }
    }]);
    return Matrix2;
  }(MathArray);

  // node_modules/gl-matrix/esm/mat3.js
  function create3() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply2(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // node_modules/@math.gl/core/dist/esm/classes/matrix3.js
  function _createSuper17(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct18();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct18() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var IDENTITY = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var INDICES = Object.freeze({
    COL0ROW0: 0,
    COL0ROW1: 1,
    COL0ROW2: 2,
    COL1ROW0: 3,
    COL1ROW1: 4,
    COL1ROW2: 5,
    COL2ROW0: 6,
    COL2ROW1: 7,
    COL2ROW2: 8
  });
  var constants2 = {};
  var Matrix3 = function(_Matrix) {
    _inherits(Matrix32, _Matrix);
    var _super = _createSuper17(Matrix32);
    _createClass(Matrix32, [{
      key: "ELEMENTS",
      get: function get2() {
        return 9;
      }
    }, {
      key: "RANK",
      get: function get2() {
        return 3;
      }
    }, {
      key: "INDICES",
      get: function get2() {
        return INDICES;
      }
    }], [{
      key: "IDENTITY",
      get: function get2() {
        constants2.IDENTITY = constants2.IDENTITY || Object.freeze(new Matrix32(IDENTITY));
        return constants2.IDENTITY;
      }
    }, {
      key: "ZERO",
      get: function get2() {
        constants2.ZERO = constants2.ZERO || Object.freeze(new Matrix32(ZERO));
        return constants2.ZERO;
      }
    }]);
    function Matrix32(array) {
      var _this;
      _classCallCheck(this, Matrix32);
      _this = _super.call(this, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        _this.copy(array);
      } else {
        _this.identity();
      }
      return _this;
    }
    _createClass(Matrix32, [{
      key: "copy",
      value: function copy3(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        return this.check();
      }
    }, {
      key: "set",
      value: function set2(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m01;
        this[4] = m11;
        this[5] = m21;
        this[6] = m02;
        this[7] = m12;
        this[8] = m22;
        return this.check();
      }
    }, {
      key: "setRowMajor",
      value: function setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m01;
        this[4] = m11;
        this[5] = m21;
        this[6] = m02;
        this[7] = m12;
        this[8] = m22;
        return this.check();
      }
    }, {
      key: "determinant",
      value: function determinant3() {
        return determinant(this);
      }
    }, {
      key: "identity",
      value: function identity3() {
        return this.copy(IDENTITY);
      }
    }, {
      key: "fromQuaternion",
      value: function fromQuaternion(q) {
        fromQuat(this, q);
        return this.check();
      }
    }, {
      key: "transpose",
      value: function transpose3() {
        transpose(this, this);
        return this.check();
      }
    }, {
      key: "invert",
      value: function invert4() {
        invert(this, this);
        return this.check();
      }
    }, {
      key: "multiplyLeft",
      value: function multiplyLeft(a) {
        multiply2(this, a, this);
        return this.check();
      }
    }, {
      key: "multiplyRight",
      value: function multiplyRight(a) {
        multiply2(this, this, a);
        return this.check();
      }
    }, {
      key: "rotate",
      value: function rotate3(radians2) {
        rotate(this, this, radians2);
        return this.check();
      }
    }, {
      key: "scale",
      value: function scale5(factor) {
        if (Array.isArray(factor)) {
          scale(this, this, factor);
        } else {
          scale(this, this, [factor, factor, factor]);
        }
        return this.check();
      }
    }, {
      key: "translate",
      value: function translate3(vec) {
        translate(this, this, vec);
        return this.check();
      }
    }, {
      key: "transform",
      value: function transform4(vector, result) {
        switch (vector.length) {
          case 2:
            result = transformMat3(result || [-0, -0], vector, this);
            break;
          case 3:
            result = transformMat32(result || [-0, -0, -0], vector, this);
            break;
          case 4:
            result = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(result, vector.length);
        return result;
      }
    }, {
      key: "transformVector",
      value: function transformVector3(vector, result) {
        deprecated("Matrix3.transformVector");
        return this.transform(vector, result);
      }
    }, {
      key: "transformVector2",
      value: function transformVector22(vector, result) {
        deprecated("Matrix3.transformVector");
        return this.transform(vector, result);
      }
    }, {
      key: "transformVector3",
      value: function transformVector3(vector, result) {
        deprecated("Matrix3.transformVector");
        return this.transform(vector, result);
      }
    }]);
    return Matrix32;
  }(Matrix);

  // node_modules/gl-matrix/esm/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a03 = a[3];
      var a12 = a[6], a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant2(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply3(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate2(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len2 = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len2 < EPSILON) {
      return null;
    }
    len2 = 1 / len2;
    x *= len2;
    y *= len2;
    z *= len2;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX2(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY2(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ2(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function fromQuat2(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len2 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len2;
    z1 *= len2;
    z2 *= len2;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len2 = Math.hypot(x0, x1, x2);
    if (!len2) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len2 = 1 / len2;
      x0 *= len2;
      x1 *= len2;
      x2 *= len2;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len2 = Math.hypot(y0, y1, y2);
    if (!len2) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len2 = 1 / len2;
      y0 *= len2;
      y1 *= len2;
      y2 *= len2;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function equals2(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }

  // node_modules/gl-matrix/esm/vec4.js
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  function length2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredLength2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  function normalize2(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len2 = x * x + y * y + z * z + w * w;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = x * len2;
    out[1] = y * len2;
    out[2] = z * len2;
    out[3] = w * len2;
    return out;
  }
  function dot2(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  function lerp4(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  function transformMat43(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat2(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  var forEach4 = function() {
    var vec = create4();
    return function(a, stride, offset, count3, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l = Math.min(count3 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/matrix4.js
  function _createSuper18(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct19();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct19() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var IDENTITY2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var ZERO2 = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var INDICES2 = Object.freeze({
    COL0ROW0: 0,
    COL0ROW1: 1,
    COL0ROW2: 2,
    COL0ROW3: 3,
    COL1ROW0: 4,
    COL1ROW1: 5,
    COL1ROW2: 6,
    COL1ROW3: 7,
    COL2ROW0: 8,
    COL2ROW1: 9,
    COL2ROW2: 10,
    COL2ROW3: 11,
    COL3ROW0: 12,
    COL3ROW1: 13,
    COL3ROW2: 14,
    COL3ROW3: 15
  });
  var constants3 = {};
  var Matrix4 = function(_Matrix) {
    _inherits(Matrix42, _Matrix);
    var _super = _createSuper18(Matrix42);
    _createClass(Matrix42, [{
      key: "INDICES",
      get: function get2() {
        return INDICES2;
      }
    }, {
      key: "ELEMENTS",
      get: function get2() {
        return 16;
      }
    }, {
      key: "RANK",
      get: function get2() {
        return 4;
      }
    }], [{
      key: "IDENTITY",
      get: function get2() {
        constants3.IDENTITY = constants3.IDENTITY || Object.freeze(new Matrix42(IDENTITY2));
        return constants3.IDENTITY;
      }
    }, {
      key: "ZERO",
      get: function get2() {
        constants3.ZERO = constants3.ZERO || Object.freeze(new Matrix42(ZERO2));
        return constants3.ZERO;
      }
    }]);
    function Matrix42(array) {
      var _this;
      _classCallCheck(this, Matrix42);
      _this = _super.call(this, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        _this.copy(array);
      } else {
        _this.identity();
      }
      return _this;
    }
    _createClass(Matrix42, [{
      key: "copy",
      value: function copy3(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        this[9] = array[9];
        this[10] = array[10];
        this[11] = array[11];
        this[12] = array[12];
        this[13] = array[13];
        this[14] = array[14];
        this[15] = array[15];
        return this.check();
      }
    }, {
      key: "set",
      value: function set2(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
      }
    }, {
      key: "setRowMajor",
      value: function setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
      }
    }, {
      key: "toRowMajor",
      value: function toRowMajor(result) {
        result[0] = this[0];
        result[1] = this[4];
        result[2] = this[8];
        result[3] = this[12];
        result[4] = this[1];
        result[5] = this[5];
        result[6] = this[9];
        result[7] = this[13];
        result[8] = this[2];
        result[9] = this[6];
        result[10] = this[10];
        result[11] = this[14];
        result[12] = this[3];
        result[13] = this[7];
        result[14] = this[11];
        result[15] = this[15];
        return result;
      }
    }, {
      key: "identity",
      value: function identity3() {
        return this.copy(IDENTITY2);
      }
    }, {
      key: "fromQuaternion",
      value: function fromQuaternion(q) {
        fromQuat2(this, q);
        return this.check();
      }
    }, {
      key: "frustum",
      value: function frustum2(_ref) {
        var left = _ref.left, right = _ref.right, bottom = _ref.bottom, top = _ref.top, near = _ref.near, far = _ref.far;
        if (far === Infinity) {
          Matrix42._computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
        } else {
          frustum(this, left, right, bottom, top, near, far);
        }
        return this.check();
      }
    }, {
      key: "lookAt",
      value: function lookAt2(eye, center, up) {
        if (arguments.length === 1) {
          var _eye = eye;
          eye = _eye.eye;
          center = _eye.center;
          up = _eye.up;
        }
        center = center || [0, 0, 0];
        up = up || [0, 1, 0];
        lookAt(this, eye, center, up);
        return this.check();
      }
    }, {
      key: "ortho",
      value: function ortho2(_ref2) {
        var left = _ref2.left, right = _ref2.right, bottom = _ref2.bottom, top = _ref2.top, _ref2$near = _ref2.near, near = _ref2$near === void 0 ? 0.1 : _ref2$near, _ref2$far = _ref2.far, far = _ref2$far === void 0 ? 500 : _ref2$far;
        ortho(this, left, right, bottom, top, near, far);
        return this.check();
      }
    }, {
      key: "orthographic",
      value: function orthographic(_ref3) {
        var _ref3$fovy = _ref3.fovy, fovy = _ref3$fovy === void 0 ? 45 * Math.PI / 180 : _ref3$fovy, _ref3$aspect = _ref3.aspect, aspect = _ref3$aspect === void 0 ? 1 : _ref3$aspect, _ref3$focalDistance = _ref3.focalDistance, focalDistance = _ref3$focalDistance === void 0 ? 1 : _ref3$focalDistance, _ref3$near = _ref3.near, near = _ref3$near === void 0 ? 0.1 : _ref3$near, _ref3$far = _ref3.far, far = _ref3$far === void 0 ? 500 : _ref3$far;
        if (fovy > Math.PI * 2) {
          throw Error("radians");
        }
        var halfY = fovy / 2;
        var top = focalDistance * Math.tan(halfY);
        var right = top * aspect;
        return new Matrix42().ortho({
          left: -right,
          right,
          bottom: -top,
          top,
          near,
          far
        });
      }
    }, {
      key: "perspective",
      value: function perspective2() {
        var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$fovy = _ref4.fovy, fovy = _ref4$fovy === void 0 ? void 0 : _ref4$fovy, _ref4$fov = _ref4.fov, fov = _ref4$fov === void 0 ? 45 * Math.PI / 180 : _ref4$fov, _ref4$aspect = _ref4.aspect, aspect = _ref4$aspect === void 0 ? 1 : _ref4$aspect, _ref4$near = _ref4.near, near = _ref4$near === void 0 ? 0.1 : _ref4$near, _ref4$far = _ref4.far, far = _ref4$far === void 0 ? 500 : _ref4$far;
        fovy = fovy || fov;
        if (fovy > Math.PI * 2) {
          throw Error("radians");
        }
        perspective(this, fovy, aspect, near, far);
        return this.check();
      }
    }, {
      key: "determinant",
      value: function determinant3() {
        return determinant2(this);
      }
    }, {
      key: "getScale",
      value: function getScale2() {
        var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
        result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
        result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        return result;
      }
    }, {
      key: "getTranslation",
      value: function getTranslation() {
        var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
        result[0] = this[12];
        result[1] = this[13];
        result[2] = this[14];
        return result;
      }
    }, {
      key: "getRotation",
      value: function getRotation() {
        var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
        var scaleResult = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var scale5 = this.getScale(scaleResult || [-0, -0, -0]);
        var inverseScale0 = 1 / scale5[0];
        var inverseScale1 = 1 / scale5[1];
        var inverseScale2 = 1 / scale5[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = 0;
        result[4] = this[4] * inverseScale0;
        result[5] = this[5] * inverseScale1;
        result[6] = this[6] * inverseScale2;
        result[7] = 0;
        result[8] = this[8] * inverseScale0;
        result[9] = this[9] * inverseScale1;
        result[10] = this[10] * inverseScale2;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
      }
    }, {
      key: "getRotationMatrix3",
      value: function getRotationMatrix3() {
        var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0, -0, -0, -0, -0, -0, -0];
        var scaleResult = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var scale5 = this.getScale(scaleResult || [-0, -0, -0]);
        var inverseScale0 = 1 / scale5[0];
        var inverseScale1 = 1 / scale5[1];
        var inverseScale2 = 1 / scale5[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = this[4] * inverseScale0;
        result[4] = this[5] * inverseScale1;
        result[5] = this[6] * inverseScale2;
        result[6] = this[8] * inverseScale0;
        result[7] = this[9] * inverseScale1;
        result[8] = this[10] * inverseScale2;
        return result;
      }
    }, {
      key: "transpose",
      value: function transpose3() {
        transpose2(this, this);
        return this.check();
      }
    }, {
      key: "invert",
      value: function invert4() {
        invert2(this, this);
        return this.check();
      }
    }, {
      key: "multiplyLeft",
      value: function multiplyLeft(a) {
        multiply3(this, a, this);
        return this.check();
      }
    }, {
      key: "multiplyRight",
      value: function multiplyRight(a) {
        multiply3(this, this, a);
        return this.check();
      }
    }, {
      key: "rotateX",
      value: function rotateX4(radians2) {
        rotateX2(this, this, radians2);
        return this.check();
      }
    }, {
      key: "rotateY",
      value: function rotateY4(radians2) {
        rotateY2(this, this, radians2);
        return this.check();
      }
    }, {
      key: "rotateZ",
      value: function rotateZ4(radians2) {
        rotateZ2(this, this, radians2);
        return this.check();
      }
    }, {
      key: "rotateXYZ",
      value: function rotateXYZ(_ref5) {
        var _ref6 = _slicedToArray(_ref5, 3), rx = _ref6[0], ry = _ref6[1], rz = _ref6[2];
        return this.rotateX(rx).rotateY(ry).rotateZ(rz);
      }
    }, {
      key: "rotateAxis",
      value: function rotateAxis(radians2, axis) {
        rotate2(this, this, radians2, axis);
        return this.check();
      }
    }, {
      key: "scale",
      value: function scale5(factor) {
        if (Array.isArray(factor)) {
          scale2(this, this, factor);
        } else {
          scale2(this, this, [factor, factor, factor]);
        }
        return this.check();
      }
    }, {
      key: "translate",
      value: function translate3(vec) {
        translate2(this, this, vec);
        return this.check();
      }
    }, {
      key: "transform",
      value: function transform4(vector, result) {
        if (vector.length === 4) {
          result = transformMat43(result || [-0, -0, -0, -0], vector, this);
          checkVector(result, 4);
          return result;
        }
        return this.transformAsPoint(vector, result);
      }
    }, {
      key: "transformAsPoint",
      value: function transformAsPoint(vector, result) {
        var length4 = vector.length;
        switch (length4) {
          case 2:
            result = transformMat4(result || [-0, -0], vector, this);
            break;
          case 3:
            result = transformMat42(result || [-0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(result, vector.length);
        return result;
      }
    }, {
      key: "transformAsVector",
      value: function transformAsVector(vector, result) {
        switch (vector.length) {
          case 2:
            result = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
            break;
          case 3:
            result = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(result, vector.length);
        return result;
      }
    }, {
      key: "makeRotationX",
      value: function makeRotationX(radians2) {
        return this.identity().rotateX(radians2);
      }
    }, {
      key: "makeTranslation",
      value: function makeTranslation(x, y, z) {
        return this.identity().translate([x, y, z]);
      }
    }, {
      key: "transformPoint",
      value: function transformPoint(vector, result) {
        deprecated("Matrix4.transformPoint", "3.0");
        return this.transformAsPoint(vector, result);
      }
    }, {
      key: "transformVector",
      value: function transformVector3(vector, result) {
        deprecated("Matrix4.transformVector", "3.0");
        return this.transformAsPoint(vector, result);
      }
    }, {
      key: "transformDirection",
      value: function transformDirection(vector, result) {
        deprecated("Matrix4.transformDirection", "3.0");
        return this.transformAsVector(vector, result);
      }
    }], [{
      key: "_computeInfinitePerspectiveOffCenter",
      value: function _computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
        var column0Row0 = 2 * near / (right - left);
        var column1Row1 = 2 * near / (top - bottom);
        var column2Row0 = (right + left) / (right - left);
        var column2Row1 = (top + bottom) / (top - bottom);
        var column2Row2 = -1;
        var column2Row3 = -1;
        var column3Row2 = -2 * near;
        result[0] = column0Row0;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = column1Row1;
        result[6] = 0;
        result[7] = 0;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = 0;
        result[13] = 0;
        result[14] = column3Row2;
        result[15] = 0;
        return result;
      }
    }]);
    return Matrix42;
  }(Matrix);

  // node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply4(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
  }
  function slerp(out, a, b, t) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert3(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot4 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot4 ? 1 / dot4 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i = 0;
      if (m[4] > m[0])
        i = 1;
      if (m[8] > m[i * 3 + i])
        i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
  }
  var add4 = add3;
  var scale4 = scale3;
  var dot3 = dot2;
  var lerp5 = lerp4;
  var length3 = length2;
  var squaredLength3 = squaredLength2;
  var normalize3 = normalize2;
  var rotationTo = function() {
    var tmpvec3 = create2();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function(out, a, b) {
      var dot4 = dot(a, b);
      if (dot4 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 1e-6)
          cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot4 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot4;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create3();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/quaternion.js
  function _createSuper19(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct20();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct20() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var IDENTITY_QUATERNION = [0, 0, 0, 1];
  var Quaternion = function(_MathArray) {
    _inherits(Quaternion2, _MathArray);
    var _super = _createSuper19(Quaternion2);
    function Quaternion2() {
      var _this;
      var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      _classCallCheck(this, Quaternion2);
      _this = _super.call(this, -0, -0, -0, -0);
      if (Array.isArray(x) && arguments.length === 1) {
        _this.copy(x);
      } else {
        _this.set(x, y, z, w);
      }
      return _this;
    }
    _createClass(Quaternion2, [{
      key: "copy",
      value: function copy3(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        return this.check();
      }
    }, {
      key: "set",
      value: function set2(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this.check();
      }
    }, {
      key: "fromMatrix3",
      value: function fromMatrix3(m) {
        fromMat3(this, m);
        return this.check();
      }
    }, {
      key: "identity",
      value: function identity3() {
        identity2(this);
        return this.check();
      }
    }, {
      key: "fromAxisRotation",
      value: function fromAxisRotation(axis, rad) {
        setAxisAngle(this, axis, rad);
        return this.check();
      }
    }, {
      key: "setAxisAngle",
      value: function setAxisAngle2(axis, rad) {
        return this.fromAxisRotation(axis, rad);
      }
    }, {
      key: "len",
      value: function len2() {
        return length3(this);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        return squaredLength3(this);
      }
    }, {
      key: "dot",
      value: function dot4(a, b) {
        if (b !== void 0) {
          throw new Error("Quaternion.dot only takes one argument");
        }
        return dot3(this, a);
      }
    }, {
      key: "rotationTo",
      value: function rotationTo2(vectorA, vectorB) {
        rotationTo(this, vectorA, vectorB);
        return this.check();
      }
    }, {
      key: "add",
      value: function add6(a, b) {
        if (b !== void 0) {
          throw new Error("Quaternion.add only takes one argument");
        }
        add4(this, this, a);
        return this.check();
      }
    }, {
      key: "calculateW",
      value: function calculateW2() {
        calculateW(this, this);
        return this.check();
      }
    }, {
      key: "conjugate",
      value: function conjugate2() {
        conjugate(this, this);
        return this.check();
      }
    }, {
      key: "invert",
      value: function invert4() {
        invert3(this, this);
        return this.check();
      }
    }, {
      key: "lerp",
      value: function lerp7(a, b, t) {
        lerp5(this, a, b, t);
        return this.check();
      }
    }, {
      key: "multiplyRight",
      value: function multiplyRight(a, b) {
        assert7(!b);
        multiply4(this, this, a);
        return this.check();
      }
    }, {
      key: "multiplyLeft",
      value: function multiplyLeft(a, b) {
        assert7(!b);
        multiply4(this, a, this);
        return this.check();
      }
    }, {
      key: "normalize",
      value: function normalize5() {
        var length4 = this.len();
        var l = length4 > 0 ? 1 / length4 : 0;
        this[0] = this[0] * l;
        this[1] = this[1] * l;
        this[2] = this[2] * l;
        this[3] = this[3] * l;
        if (length4 === 0) {
          this[3] = 1;
        }
        return this.check();
      }
    }, {
      key: "rotateX",
      value: function rotateX4(rad) {
        rotateX3(this, this, rad);
        return this.check();
      }
    }, {
      key: "rotateY",
      value: function rotateY4(rad) {
        rotateY3(this, this, rad);
        return this.check();
      }
    }, {
      key: "rotateZ",
      value: function rotateZ4(rad) {
        rotateZ3(this, this, rad);
        return this.check();
      }
    }, {
      key: "scale",
      value: function scale5(b) {
        scale4(this, this, b);
        return this.check();
      }
    }, {
      key: "slerp",
      value: function slerp2(start2, target, ratio) {
        switch (arguments.length) {
          case 1:
            var _arguments$ = arguments[0];
            var _arguments$$start = _arguments$.start;
            start2 = _arguments$$start === void 0 ? IDENTITY_QUATERNION : _arguments$$start;
            target = _arguments$.target;
            ratio = _arguments$.ratio;
            break;
          case 2:
            var _arguments = Array.prototype.slice.call(arguments);
            target = _arguments[0];
            ratio = _arguments[1];
            start2 = this;
            break;
          default:
        }
        slerp(this, start2, target, ratio);
        return this.check();
      }
    }, {
      key: "transformVector4",
      value: function transformVector4(vector) {
        var result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : vector;
        transformQuat2(result, vector, this);
        return checkVector(result, 4);
      }
    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.lengthSquared();
      }
    }, {
      key: "setFromAxisAngle",
      value: function setFromAxisAngle(axis, rad) {
        return this.setAxisAngle(axis, rad);
      }
    }, {
      key: "premultiply",
      value: function premultiply(a, b) {
        return this.multiplyLeft(a, b);
      }
    }, {
      key: "multiply",
      value: function multiply5(a, b) {
        return this.multiplyRight(a, b);
      }
    }, {
      key: "ELEMENTS",
      get: function get2() {
        return 4;
      }
    }, {
      key: "x",
      get: function get2() {
        return this[0];
      },
      set: function set2(value17) {
        this[0] = checkNumber(value17);
      }
    }, {
      key: "y",
      get: function get2() {
        return this[1];
      },
      set: function set2(value17) {
        this[1] = checkNumber(value17);
      }
    }, {
      key: "z",
      get: function get2() {
        return this[2];
      },
      set: function set2(value17) {
        this[2] = checkNumber(value17);
      }
    }, {
      key: "w",
      get: function get2() {
        return this[3];
      },
      set: function set2(value17) {
        this[3] = checkNumber(value17);
      }
    }]);
    return Quaternion2;
  }(MathArray);

  // node_modules/@math.gl/core/dist/esm/index.js
  var globals4 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global
  };
  var global_5 = globals4.global || globals4.self || globals4.window;
  global_5.mathgl = {
    config
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
  var lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";

  // node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
  function _createForOfIteratorHelper20(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray21(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray21(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray21(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray21(o, minLen);
  }
  function _arrayLikeToArray21(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var INITIAL_MODULE_OPTIONS = {
    lightSources: {}
  };
  function convertColor() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$color = _ref.color, color = _ref$color === void 0 ? [0, 0, 0] : _ref$color, _ref$intensity = _ref.intensity, intensity = _ref$intensity === void 0 ? 1 : _ref$intensity;
    return color.map(function(component) {
      return component * intensity / 255;
    });
  }
  function getLightSourceUniforms(_ref2) {
    var ambientLight = _ref2.ambientLight, _ref2$pointLights = _ref2.pointLights, pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights, _ref2$directionalLigh = _ref2.directionalLights, directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;
    var lightSourceUniforms = {};
    if (ambientLight) {
      lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
    } else {
      lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
    }
    pointLights.forEach(function(pointLight, index) {
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
    });
    lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
    directionalLights.forEach(function(directionalLight, index) {
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
    });
    lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
    return lightSourceUniforms;
  }
  function getUniforms() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
    if ("lightSources" in opts) {
      var _ref3 = opts.lightSources || {}, ambientLight = _ref3.ambientLight, pointLights = _ref3.pointLights, directionalLights = _ref3.directionalLights;
      var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
      if (!hasLights) {
        return {
          lighting_uEnabled: false
        };
      }
      return Object.assign({}, getLightSourceUniforms({
        ambientLight,
        pointLights,
        directionalLights
      }), {
        lighting_uEnabled: true
      });
    }
    if ("lights" in opts) {
      var lightSources = {
        pointLights: [],
        directionalLights: []
      };
      var _iterator = _createForOfIteratorHelper20(opts.lights || []), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var light = _step.value;
          switch (light.type) {
            case "ambient":
              lightSources.ambientLight = light;
              break;
            case "directional":
              lightSources.directionalLights.push(light);
              break;
            case "point":
              lightSources.pointLights.push(light);
              break;
            default:
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return getUniforms({
        lightSources
      });
    }
    return {};
  }
  var lights = {
    name: "lights",
    vs: lights_glsl_default,
    fs: lights_glsl_default,
    getUniforms,
    defines: {
      MAX_LIGHTS: 3
    }
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
  var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
  var DEFAULT_MODULE_OPTIONS = {
    pickingSelectedColor: null,
    pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
    pickingActive: false,
    pickingAttribute: false
  };
  function getUniforms2() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
    var uniforms = {};
    if (opts.pickingSelectedColor !== void 0) {
      if (!opts.pickingSelectedColor) {
        uniforms.picking_uSelectedColorValid = 0;
      } else {
        var selectedColor = opts.pickingSelectedColor.slice(0, 3);
        uniforms.picking_uSelectedColorValid = 1;
        uniforms.picking_uSelectedColor = selectedColor;
      }
    }
    if (opts.pickingHighlightColor) {
      var color = Array.from(opts.pickingHighlightColor, function(x) {
        return x / 255;
      });
      if (!Number.isFinite(color[3])) {
        color[3] = 1;
      }
      uniforms.picking_uHighlightColor = color;
    }
    if (opts.pickingActive !== void 0) {
      uniforms.picking_uActive = Boolean(opts.pickingActive);
      uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
    }
    return uniforms;
  }
  var vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
  var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
  var picking = {
    name: "picking",
    vs,
    fs,
    getUniforms: getUniforms2
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js
  var phong_lighting_glsl_default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";

  // node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js
  var INITIAL_MODULE_OPTIONS2 = {};
  function getMaterialUniforms(material) {
    var _material$ambient = material.ambient, ambient = _material$ambient === void 0 ? 0.35 : _material$ambient, _material$diffuse = material.diffuse, diffuse = _material$diffuse === void 0 ? 0.6 : _material$diffuse, _material$shininess = material.shininess, shininess = _material$shininess === void 0 ? 32 : _material$shininess, _material$specularCol = material.specularColor, specularColor = _material$specularCol === void 0 ? [30, 30, 30] : _material$specularCol;
    return {
      lighting_uAmbient: ambient,
      lighting_uDiffuse: diffuse,
      lighting_uShininess: shininess,
      lighting_uSpecularColor: specularColor.map(function(x) {
        return x / 255;
      })
    };
  }
  function getUniforms3() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS2;
    if (!("material" in opts)) {
      return {};
    }
    var material = opts.material;
    if (!material) {
      return {
        lighting_uEnabled: false
      };
    }
    return getMaterialUniforms(material);
  }
  var gouraudLighting = {
    name: "gouraud-lighting",
    dependencies: [lights],
    vs: phong_lighting_glsl_default,
    defines: {
      LIGHTING_VERTEX: 1
    },
    getUniforms: getUniforms3
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
  var vs2 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
  var transform = {
    name: "transform",
    vs: vs2,
    fs: null
  };

  // node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
  function _createForOfIteratorHelper21(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray22(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray22(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray22(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray22(o, minLen);
  }
  function _arrayLikeToArray22(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var ProgramManager = function() {
    _createClass(ProgramManager2, null, [{
      key: "getDefaultProgramManager",
      value: function getDefaultProgramManager(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager2(gl);
        return gl.luma.defaultProgramManager;
      }
    }]);
    function ProgramManager2(gl) {
      _classCallCheck(this, ProgramManager2);
      this.gl = gl;
      this._programCache = {};
      this._getUniforms = {};
      this._registeredModules = {};
      this._hookFunctions = [];
      this._defaultModules = [];
      this._hashes = {};
      this._hashCounter = 0;
      this.stateHash = 0;
      this._useCounts = {};
    }
    _createClass(ProgramManager2, [{
      key: "addDefaultModule",
      value: function addDefaultModule(module2) {
        if (!this._defaultModules.find(function(m) {
          return m.name === module2.name;
        })) {
          this._defaultModules.push(module2);
        }
        this.stateHash++;
      }
    }, {
      key: "removeDefaultModule",
      value: function removeDefaultModule(module2) {
        var moduleName = typeof module2 === "string" ? module2 : module2.name;
        this._defaultModules = this._defaultModules.filter(function(m) {
          return m.name !== moduleName;
        });
        this.stateHash++;
      }
    }, {
      key: "addShaderHook",
      value: function addShaderHook(hook, opts) {
        if (opts) {
          hook = Object.assign(opts, {
            hook
          });
        }
        this._hookFunctions.push(hook);
        this.stateHash++;
      }
    }, {
      key: "get",
      value: function get2() {
        var _this = this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _props$vs = props.vs, vs7 = _props$vs === void 0 ? "" : _props$vs, _props$fs = props.fs, fs4 = _props$fs === void 0 ? "" : _props$fs, _props$defines = props.defines, defines = _props$defines === void 0 ? {} : _props$defines, _props$inject = props.inject, inject = _props$inject === void 0 ? {} : _props$inject, _props$varyings = props.varyings, varyings = _props$varyings === void 0 ? [] : _props$varyings, _props$bufferMode = props.bufferMode, bufferMode = _props$bufferMode === void 0 ? 35981 : _props$bufferMode, _props$transpileToGLS = props.transpileToGLSL100, transpileToGLSL100 = _props$transpileToGLS === void 0 ? false : _props$transpileToGLS;
        var modules = this._getModuleList(props.modules);
        var vsHash = this._getHash(vs7);
        var fsHash = this._getHash(fs4);
        var moduleHashes = modules.map(function(m) {
          return _this._getHash(m.name);
        }).sort();
        var varyingHashes = varyings.map(function(v) {
          return _this._getHash(v);
        });
        var defineKeys = Object.keys(defines).sort();
        var injectKeys = Object.keys(inject).sort();
        var defineHashes = [];
        var injectHashes = [];
        var _iterator = _createForOfIteratorHelper21(defineKeys), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            defineHashes.push(this._getHash(key));
            defineHashes.push(this._getHash(defines[key]));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var _iterator2 = _createForOfIteratorHelper21(injectKeys), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _key = _step2.value;
            injectHashes.push(this._getHash(_key));
            injectHashes.push(this._getHash(inject[_key]));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
        if (!this._programCache[hash]) {
          var assembled = assembleShaders(this.gl, {
            vs: vs7,
            fs: fs4,
            modules,
            inject,
            defines,
            hookFunctions: this._hookFunctions,
            transpileToGLSL100
          });
          this._programCache[hash] = new Program(this.gl, {
            hash,
            vs: assembled.vs,
            fs: assembled.fs,
            varyings,
            bufferMode
          });
          this._getUniforms[hash] = assembled.getUniforms || function(x) {
          };
          this._useCounts[hash] = 0;
        }
        this._useCounts[hash]++;
        return this._programCache[hash];
      }
    }, {
      key: "getUniforms",
      value: function getUniforms6(program) {
        return this._getUniforms[program.hash] || null;
      }
    }, {
      key: "release",
      value: function release2(program) {
        var hash = program.hash;
        this._useCounts[hash]--;
        if (this._useCounts[hash] === 0) {
          this._programCache[hash]["delete"]();
          delete this._programCache[hash];
          delete this._getUniforms[hash];
          delete this._useCounts[hash];
        }
      }
    }, {
      key: "_getHash",
      value: function _getHash(key) {
        if (this._hashes[key] === void 0) {
          this._hashes[key] = this._hashCounter++;
        }
        return this._hashes[key];
      }
    }, {
      key: "_getModuleList",
      value: function _getModuleList() {
        var appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var modules = new Array(this._defaultModules.length + appModules.length);
        var seen = {};
        var count3 = 0;
        for (var i = 0, len2 = this._defaultModules.length; i < len2; ++i) {
          var module2 = this._defaultModules[i];
          var name = module2.name;
          modules[count3++] = module2;
          seen[name] = true;
        }
        for (var _i = 0, _len = appModules.length; _i < _len; ++_i) {
          var _module = appModules[_i];
          var _name = _module.name;
          if (!seen[_name]) {
            modules[count3++] = _module;
            seen[_name] = true;
          }
        }
        modules.length = count3;
        return modules;
      }
    }]);
    return ProgramManager2;
  }();

  // node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
  function ownKeys8(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys8(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys8(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
  };
  function getBuffersFromGeometry(gl, geometry, options) {
    var buffers = {};
    var indices = geometry.indices;
    for (var name in geometry.attributes) {
      var attribute = geometry.attributes[name];
      var remappedName = mapAttributeName(name, options);
      if (name === "indices") {
        indices = attribute;
      } else if (attribute.constant) {
        buffers[remappedName] = attribute.value;
      } else {
        var typedArray = attribute.value;
        var accessor = _objectSpread8({}, attribute);
        delete accessor.value;
        buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
        inferAttributeAccessor(name, accessor);
      }
    }
    if (indices) {
      var data = indices.value || indices;
      assert5(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      var _accessor = {
        size: 1,
        isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
      };
      buffers.indices = [new Buffer2(gl, {
        data,
        target: 34963
      }), _accessor];
    }
    return buffers;
  }
  function mapAttributeName(name, options) {
    var _ref = options || {}, _ref$attributeMap = _ref.attributeMap, attributeMap = _ref$attributeMap === void 0 ? GLTF_TO_LUMA_ATTRIBUTE_MAP : _ref$attributeMap;
    return attributeMap && attributeMap[name] || name;
  }
  function inferAttributeAccessor(attributeName, attribute) {
    var category;
    switch (attributeName) {
      case "texCoords":
      case "texCoord1":
      case "texCoord2":
      case "texCoord3":
        category = "uvs";
        break;
      case "vertices":
      case "positions":
      case "normals":
      case "pickingColors":
        category = "vectors";
        break;
      default:
    }
    switch (category) {
      case "vectors":
        attribute.size = attribute.size || 3;
        break;
      case "uvs":
        attribute.size = attribute.size || 2;
        break;
      default:
    }
    assert5(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
  }

  // node_modules/@luma.gl/engine/dist/esm/lib/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
  var NOOP = function NOOP2() {
  };
  var DRAW_PARAMS = {};
  var Model = function() {
    function Model3(gl) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Model3);
      var _props$id = props.id, id = _props$id === void 0 ? uid("model") : _props$id;
      assert5(isWebGL(gl));
      this.id = id;
      this.gl = gl;
      this.id = props.id || uid("Model");
      this.lastLogTime = 0;
      this.animated = false;
      this.initialize(props);
    }
    _createClass(Model3, [{
      key: "initialize",
      value: function initialize(props) {
        this.props = {};
        this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
        this._programManagerState = -1;
        this._managedProgram = false;
        var _props$program = props.program, program = _props$program === void 0 ? null : _props$program, vs7 = props.vs, fs4 = props.fs, modules = props.modules, defines = props.defines, inject = props.inject, varyings = props.varyings, bufferMode = props.bufferMode, transpileToGLSL100 = props.transpileToGLSL100;
        this.programProps = {
          program,
          vs: vs7,
          fs: fs4,
          modules,
          defines,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        };
        this.program = null;
        this.vertexArray = null;
        this._programDirty = true;
        this.userData = {};
        this.needsRedraw = true;
        this._attributes = {};
        this.attributes = {};
        this.uniforms = {};
        this.pickable = true;
        this._checkProgram();
        this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
        this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
        this.vertexCount = props.vertexCount || 0;
        this.geometryBuffers = {};
        this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
        this._setModelProps(props);
        this.geometry = {};
        assert5(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        this._setModelProps(props);
      }
    }, {
      key: "delete",
      value: function _delete() {
        for (var key in this._attributes) {
          if (this._attributes[key] !== this.attributes[key]) {
            this._attributes[key]["delete"]();
          }
        }
        if (this._managedProgram) {
          this.programManager.release(this.program);
          this._managedProgram = false;
        }
        this.vertexArray["delete"]();
        this._deleteGeometryBuffers();
      }
    }, {
      key: "getDrawMode",
      value: function getDrawMode() {
        return this.drawMode;
      }
    }, {
      key: "getVertexCount",
      value: function getVertexCount() {
        return this.vertexCount;
      }
    }, {
      key: "getInstanceCount",
      value: function getInstanceCount() {
        return this.instanceCount;
      }
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        return this.attributes;
      }
    }, {
      key: "getProgram",
      value: function getProgram() {
        return this.program;
      }
    }, {
      key: "setProgram",
      value: function setProgram(props) {
        var program = props.program, vs7 = props.vs, fs4 = props.fs, modules = props.modules, defines = props.defines, inject = props.inject, varyings = props.varyings, bufferMode = props.bufferMode, transpileToGLSL100 = props.transpileToGLSL100;
        this.programProps = {
          program,
          vs: vs7,
          fs: fs4,
          modules,
          defines,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        };
        this._programDirty = true;
      }
    }, {
      key: "getUniforms",
      value: function getUniforms6() {
        return this.uniforms;
      }
    }, {
      key: "setDrawMode",
      value: function setDrawMode(drawMode) {
        this.drawMode = drawMode;
        return this;
      }
    }, {
      key: "setVertexCount",
      value: function setVertexCount(vertexCount) {
        assert5(Number.isFinite(vertexCount));
        this.vertexCount = vertexCount;
        return this;
      }
    }, {
      key: "setInstanceCount",
      value: function setInstanceCount(instanceCount) {
        assert5(Number.isFinite(instanceCount));
        this.instanceCount = instanceCount;
        return this;
      }
    }, {
      key: "setGeometry",
      value: function setGeometry(geometry) {
        this.drawMode = geometry.drawMode;
        this.vertexCount = geometry.getVertexCount();
        this._deleteGeometryBuffers();
        this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
        this.vertexArray.setAttributes(this.geometryBuffers);
        return this;
      }
    }, {
      key: "setAttributes",
      value: function setAttributes() {
        var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (isObjectEmpty2(attributes)) {
          return this;
        }
        var normalizedAttributes = {};
        for (var name in attributes) {
          var attribute = attributes[name];
          normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
        }
        this.vertexArray.setAttributes(normalizedAttributes);
        return this;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms() {
        var uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Object.assign(this.uniforms, uniforms);
        return this;
      }
    }, {
      key: "getModuleUniforms",
      value: function getModuleUniforms(opts) {
        this._checkProgram();
        var getUniforms6 = this.programManager.getUniforms(this.program);
        if (getUniforms6) {
          return getUniforms6(opts);
        }
        return {};
      }
    }, {
      key: "updateModuleSettings",
      value: function updateModuleSettings(opts) {
        var uniforms = this.getModuleUniforms(opts || {});
        return this.setUniforms(uniforms);
      }
    }, {
      key: "clear",
      value: function clear2(opts) {
        clear(this.program.gl, opts);
        return this;
      }
    }, {
      key: "draw",
      value: function draw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._checkProgram();
        var _opts$moduleSettings = opts.moduleSettings, moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings, framebuffer2 = opts.framebuffer, _opts$uniforms = opts.uniforms, uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms, _opts$attributes = opts.attributes, attributes = _opts$attributes === void 0 ? {} : _opts$attributes, _opts$transformFeedba = opts.transformFeedback, transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba, _opts$parameters = opts.parameters, parameters = _opts$parameters === void 0 ? {} : _opts$parameters, _opts$vertexArray = opts.vertexArray, vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray;
        this.setAttributes(attributes);
        this.updateModuleSettings(moduleSettings);
        this.setUniforms(uniforms);
        var logPriority;
        if (log.priority >= LOG_DRAW_PRIORITY) {
          logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
        }
        var drawParams = this.vertexArray.getDrawParams();
        var _this$props = this.props, _this$props$isIndexed = _this$props.isIndexed, isIndexed = _this$props$isIndexed === void 0 ? drawParams.isIndexed : _this$props$isIndexed, _this$props$indexType = _this$props.indexType, indexType = _this$props$indexType === void 0 ? drawParams.indexType : _this$props$indexType, _this$props$indexOffs = _this$props.indexOffset, indexOffset = _this$props$indexOffs === void 0 ? drawParams.indexOffset : _this$props$indexOffs, _this$props$vertexArr = _this$props.vertexArrayInstanced, vertexArrayInstanced = _this$props$vertexArr === void 0 ? drawParams.isInstanced : _this$props$vertexArr;
        if (vertexArrayInstanced && !this.isInstanced) {
          log.warn("Found instanced attributes on non-instanced model", this.id)();
        }
        var isInstanced = this.isInstanced, instanceCount = this.instanceCount;
        var _this$props2 = this.props, _this$props2$onBefore = _this$props2.onBeforeRender, onBeforeRender = _this$props2$onBefore === void 0 ? NOOP : _this$props2$onBefore, _this$props2$onAfterR = _this$props2.onAfterRender, onAfterRender = _this$props2$onAfterR === void 0 ? NOOP : _this$props2$onAfterR;
        onBeforeRender();
        this.program.setUniforms(this.uniforms);
        var didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
          logPriority,
          uniforms: null,
          framebuffer: framebuffer2,
          parameters,
          drawMode: this.getDrawMode(),
          vertexCount: this.getVertexCount(),
          vertexArray,
          transformFeedback,
          isIndexed,
          indexType,
          isInstanced,
          instanceCount,
          offset: isIndexed ? indexOffset : 0
        }));
        onAfterRender();
        if (log.priority >= LOG_DRAW_PRIORITY) {
          this._logDrawCallEnd(logPriority, vertexArray, framebuffer2);
        }
        return didDraw;
      }
    }, {
      key: "transform",
      value: function transform4() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _opts$discard = opts.discard, discard = _opts$discard === void 0 ? true : _opts$discard, feedbackBuffers = opts.feedbackBuffers, _opts$unbindModels = opts.unbindModels, unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;
        var parameters = opts.parameters;
        if (feedbackBuffers) {
          this._setFeedbackBuffers(feedbackBuffers);
        }
        if (discard) {
          parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));
        }
        unbindModels.forEach(function(model) {
          return model.vertexArray.unbindBuffers();
        });
        try {
          this.draw(Object.assign({}, opts, {
            parameters
          }));
        } finally {
          unbindModels.forEach(function(model) {
            return model.vertexArray.bindBuffers();
          });
        }
        return this;
      }
    }, {
      key: "render",
      value: function render() {
        var uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
        return this.setUniforms(uniforms).draw();
      }
    }, {
      key: "_setModelProps",
      value: function _setModelProps(props) {
        Object.assign(this.props, props);
        if ("uniforms" in props) {
          this.setUniforms(props.uniforms);
        }
        if ("pickable" in props) {
          this.pickable = props.pickable;
        }
        if ("instanceCount" in props) {
          this.instanceCount = props.instanceCount;
        }
        if ("geometry" in props) {
          this.setGeometry(props.geometry);
        }
        if ("attributes" in props) {
          this.setAttributes(props.attributes);
        }
        if ("_feedbackBuffers" in props) {
          this._setFeedbackBuffers(props._feedbackBuffers);
        }
      }
    }, {
      key: "_checkProgram",
      value: function _checkProgram() {
        var needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
        if (!needsUpdate) {
          return;
        }
        var program = this.programProps.program;
        if (program) {
          this._managedProgram = false;
        } else {
          var _this$programProps = this.programProps, vs7 = _this$programProps.vs, fs4 = _this$programProps.fs, modules = _this$programProps.modules, inject = _this$programProps.inject, defines = _this$programProps.defines, varyings = _this$programProps.varyings, bufferMode = _this$programProps.bufferMode, transpileToGLSL100 = _this$programProps.transpileToGLSL100;
          program = this.programManager.get({
            vs: vs7,
            fs: fs4,
            modules,
            inject,
            defines,
            varyings,
            bufferMode,
            transpileToGLSL100
          });
          if (this.program && this._managedProgram) {
            this.programManager.release(this.program);
          }
          this._programManagerState = this.programManager.stateHash;
          this._managedProgram = true;
        }
        assert5(program instanceof Program, "Model needs a program");
        this._programDirty = false;
        if (program === this.program) {
          return;
        }
        this.program = program;
        if (this.vertexArray) {
          this.vertexArray.setProps({
            program: this.program,
            attributes: this.vertexArray.attributes
          });
        } else {
          this.vertexArray = new VertexArray(this.gl, {
            program: this.program
          });
        }
        this.setUniforms(Object.assign({}, this.getModuleUniforms()));
      }
    }, {
      key: "_deleteGeometryBuffers",
      value: function _deleteGeometryBuffers() {
        for (var name in this.geometryBuffers) {
          var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
          if (buffer instanceof Buffer2) {
            buffer["delete"]();
          }
        }
      }
    }, {
      key: "_setAnimationProps",
      value: function _setAnimationProps(animationProps) {
        if (this.animated) {
          assert5(animationProps, "Model.draw(): animated uniforms but no animationProps");
        }
      }
    }, {
      key: "_setFeedbackBuffers",
      value: function _setFeedbackBuffers() {
        var feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (isObjectEmpty2(feedbackBuffers)) {
          return this;
        }
        var gl = this.program.gl;
        this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
          program: this.program
        });
        this.transformFeedback.setBuffers(feedbackBuffers);
        return this;
      }
    }, {
      key: "_logDrawCallStart",
      value: function _logDrawCallStart(logLevel) {
        var logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
        if (Date.now() - this.lastLogTime < logDrawTimeout) {
          return void 0;
        }
        this.lastLogTime = Date.now();
        log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
          collapsed: log.level <= 2
        })();
        return logLevel;
      }
    }, {
      key: "_logDrawCallEnd",
      value: function _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer2) {
        if (logLevel === void 0) {
          return;
        }
        var attributeTable = getDebugTableForVertexArray({
          vertexArray,
          header: "".concat(this.id, " attributes"),
          attributes: this._attributes
        });
        var _getDebugTableForUnif = getDebugTableForUniforms({
          header: "".concat(this.id, " uniforms"),
          program: this.program,
          uniforms: Object.assign({}, this.program.uniforms, uniforms)
        }), uniformTable = _getDebugTableForUnif.table, unusedTable = _getDebugTableForUnif.unusedTable, unusedCount = _getDebugTableForUnif.unusedCount;
        var _getDebugTableForUnif2 = getDebugTableForUniforms({
          header: "".concat(this.id, " uniforms"),
          program: this.program,
          uniforms: Object.assign({}, this.program.uniforms, uniforms),
          undefinedOnly: true
        }), missingTable = _getDebugTableForUnif2.table, missingCount = _getDebugTableForUnif2.count;
        if (missingCount > 0) {
          log.log("MISSING UNIFORMS", Object.keys(missingTable))();
        }
        if (unusedCount > 0) {
          log.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
        }
        var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
        log.table(logLevel, attributeTable)();
        log.table(logLevel, uniformTable)();
        log.table(logLevel + 1, configTable)();
        if (framebuffer2) {
          framebuffer2.log({
            logLevel: LOG_DRAW_PRIORITY,
            message: "Rendered to ".concat(framebuffer2.id)
          });
        }
        log.groupEnd(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id))();
      }
    }]);
    return Model3;
  }();

  // node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
  function _createForOfIteratorHelper22(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray23(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray23(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray23(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray23(o, minLen);
  }
  function _arrayLikeToArray23(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var BufferTransform = function() {
    function BufferTransform2(gl) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, BufferTransform2);
      this.gl = gl;
      this.currentIndex = 0;
      this.feedbackMap = {};
      this.varyings = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    _createClass(BufferTransform2, [{
      key: "setupResources",
      value: function setupResources(opts) {
        var _iterator = _createForOfIteratorHelper22(this.bindings), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var binding = _step.value;
            this._setupTransformFeedback(binding, opts);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "updateModelProps",
      value: function updateModelProps() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var varyings = this.varyings;
        if (varyings.length > 0) {
          props = Object.assign({}, props, {
            varyings
          });
        }
        return props;
      }
    }, {
      key: "getDrawOptions",
      value: function getDrawOptions() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var binding = this.bindings[this.currentIndex];
        var sourceBuffers = binding.sourceBuffers, transformFeedback = binding.transformFeedback;
        var attributes = Object.assign({}, sourceBuffers, opts.attributes);
        return {
          attributes,
          transformFeedback
        };
      }
    }, {
      key: "swap",
      value: function swap() {
        if (this.feedbackMap) {
          this.currentIndex = this._getNextIndex();
          return true;
        }
        return false;
      }
    }, {
      key: "update",
      value: function update3() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupBuffers(opts);
      }
    }, {
      key: "getBuffer",
      value: function getBuffer(varyingName) {
        var feedbackBuffers = this.bindings[this.currentIndex].feedbackBuffers;
        var bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
        if (!bufferOrParams) {
          return null;
        }
        return bufferOrParams instanceof Buffer2 ? bufferOrParams : bufferOrParams.buffer;
      }
    }, {
      key: "getData",
      value: function getData() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var varyingName = options.varyingName;
        var buffer = this.getBuffer(varyingName);
        if (buffer) {
          return buffer.getData();
        }
        return null;
      }
    }, {
      key: "delete",
      value: function _delete() {
        for (var name in this.resources) {
          this.resources[name]["delete"]();
        }
      }
    }, {
      key: "_initialize",
      value: function _initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupBuffers(props);
        this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
        if (this.varyings.length > 0) {
          assert5(isWebGL2(this.gl));
        }
      }
    }, {
      key: "_getFeedbackBuffers",
      value: function _getFeedbackBuffers(props) {
        var _props$sourceBuffers = props.sourceBuffers, sourceBuffers = _props$sourceBuffers === void 0 ? {} : _props$sourceBuffers;
        var feedbackBuffers = {};
        if (this.bindings[this.currentIndex]) {
          Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
        }
        if (this.feedbackMap) {
          for (var sourceName in this.feedbackMap) {
            var feedbackName = this.feedbackMap[sourceName];
            if (sourceName in sourceBuffers) {
              feedbackBuffers[feedbackName] = sourceName;
            }
          }
        }
        Object.assign(feedbackBuffers, props.feedbackBuffers);
        for (var bufferName in feedbackBuffers) {
          var bufferOrRef = feedbackBuffers[bufferName];
          if (typeof bufferOrRef === "string") {
            var sourceBuffer = sourceBuffers[bufferOrRef];
            var byteLength = sourceBuffer.byteLength, usage = sourceBuffer.usage, accessor = sourceBuffer.accessor;
            feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
              byteLength,
              usage,
              accessor
            });
          }
        }
        return feedbackBuffers;
      }
    }, {
      key: "_setupBuffers",
      value: function _setupBuffers() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _props$sourceBuffers2 = props.sourceBuffers, sourceBuffers = _props$sourceBuffers2 === void 0 ? null : _props$sourceBuffers2;
        Object.assign(this.feedbackMap, props.feedbackMap);
        var feedbackBuffers = this._getFeedbackBuffers(props);
        this._updateBindings({
          sourceBuffers,
          feedbackBuffers
        });
      }
    }, {
      key: "_setupTransformFeedback",
      value: function _setupTransformFeedback(binding, _ref) {
        var model = _ref.model;
        var program = model.program;
        binding.transformFeedback = new TransformFeedback(this.gl, {
          program,
          buffers: binding.feedbackBuffers
        });
      }
    }, {
      key: "_updateBindings",
      value: function _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this.feedbackMap) {
          var _this$_swapBuffers = this._swapBuffers(this.bindings[this.currentIndex]), sourceBuffers = _this$_swapBuffers.sourceBuffers, feedbackBuffers = _this$_swapBuffers.feedbackBuffers;
          var nextIndex = this._getNextIndex();
          this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
            sourceBuffers,
            feedbackBuffers
          });
        }
      }
    }, {
      key: "_updateBinding",
      value: function _updateBinding(binding, opts) {
        if (!binding) {
          return {
            sourceBuffers: Object.assign({}, opts.sourceBuffers),
            feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
          };
        }
        Object.assign(binding.sourceBuffers, opts.sourceBuffers);
        Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
        if (binding.transformFeedback) {
          binding.transformFeedback.setBuffers(binding.feedbackBuffers);
        }
        return binding;
      }
    }, {
      key: "_swapBuffers",
      value: function _swapBuffers(opts) {
        if (!this.feedbackMap) {
          return null;
        }
        var sourceBuffers = Object.assign({}, opts.sourceBuffers);
        var feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
        for (var srcName in this.feedbackMap) {
          var dstName = this.feedbackMap[srcName];
          sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
          feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
          assert5(feedbackBuffers[dstName] instanceof Buffer2);
        }
        return {
          sourceBuffers,
          feedbackBuffers
        };
      }
    }, {
      key: "_createNewBuffer",
      value: function _createNewBuffer(name, opts) {
        var buffer = new Buffer2(this.gl, opts);
        if (this.resources[name]) {
          this.resources[name]["delete"]();
        }
        this.resources[name] = buffer;
        return buffer;
      }
    }, {
      key: "_getNextIndex",
      value: function _getNextIndex() {
        return (this.currentIndex + 1) % 2;
      }
    }]);
    return BufferTransform2;
  }();

  // node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
  var SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
  var SIZE_UNIFORM_PREFIX = "transform_uSize_";
  var VS_POS_VARIABLE = "transform_position";
  function updateForTextures(_ref) {
    var vs7 = _ref.vs, sourceTextureMap = _ref.sourceTextureMap, targetTextureVarying = _ref.targetTextureVarying, targetTexture = _ref.targetTexture;
    var texAttributeNames = Object.keys(sourceTextureMap);
    var sourceCount = texAttributeNames.length;
    var targetTextureType = null;
    var samplerTextureMap = {};
    var updatedVs = vs7;
    var finalInject = {};
    if (sourceCount > 0 || targetTextureVarying) {
      var vsLines = updatedVs.split("\n");
      var updateVsLines = vsLines.slice();
      vsLines.forEach(function(line, index, lines) {
        if (sourceCount > 0) {
          var updated = processAttributeDefinition(line, sourceTextureMap);
          if (updated) {
            var updatedLine = updated.updatedLine, inject2 = updated.inject;
            updateVsLines[index] = updatedLine;
            finalInject = combineInjects([finalInject, inject2]);
            Object.assign(samplerTextureMap, updated.samplerTextureMap);
            sourceCount--;
          }
        }
        if (targetTextureVarying && !targetTextureType) {
          targetTextureType = getVaryingType(line, targetTextureVarying);
        }
      });
      if (targetTextureVarying) {
        assert5(targetTexture);
        var sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
        var uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
        var posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
        var inject = {
          "vs:#decl": uniformDeclaration,
          "vs:#main-start": posInstructions
        };
        finalInject = combineInjects([finalInject, inject]);
      }
      updatedVs = updateVsLines.join("\n");
    }
    return {
      vs: updatedVs,
      targetTextureType,
      inject: finalInject,
      samplerTextureMap
    };
  }
  function getSizeUniforms(_ref2) {
    var sourceTextureMap = _ref2.sourceTextureMap, targetTextureVarying = _ref2.targetTextureVarying, targetTexture = _ref2.targetTexture;
    var uniforms = {};
    var width;
    var height;
    if (targetTextureVarying) {
      width = targetTexture.width;
      height = targetTexture.height;
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
    }
    for (var textureName in sourceTextureMap) {
      var _sourceTextureMap$tex = sourceTextureMap[textureName];
      width = _sourceTextureMap$tex.width;
      height = _sourceTextureMap$tex.height;
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
    }
    return uniforms;
  }
  function getAttributeDefinition(line) {
    return getQualifierDetails(line, ["attribute", "in"]);
  }
  function getSamplerDeclerations(textureName) {
    var samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
    var sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
    var uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
    return {
      samplerName,
      sizeName,
      uniformDeclerations
    };
  }
  function getVaryingType(line, varying) {
    var qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
    if (!qualaiferDetails) {
      return null;
    }
    return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
  }
  function processAttributeDefinition(line, textureMap) {
    var samplerTextureMap = {};
    var attributeData = getAttributeDefinition(line);
    if (!attributeData) {
      return null;
    }
    var type = attributeData.type, name = attributeData.name;
    if (name && textureMap[name]) {
      var updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
      var _getSamplerDecleratio = getSamplerDeclerations(name), samplerName = _getSamplerDecleratio.samplerName, sizeName = _getSamplerDecleratio.sizeName, uniformDeclerations = _getSamplerDecleratio.uniformDeclerations;
      var channels = typeToChannelSuffix(type);
      var sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
      samplerTextureMap[samplerName] = name;
      var inject = {
        "vs:#decl": uniformDeclerations,
        "vs:#main-start": sampleInstruction
      };
      return {
        updatedLine,
        inject,
        samplerTextureMap
      };
    }
    return null;
  }

  // node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
  var _SRC_TEX_PARAMETER_OV;
  var SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, _defineProperty(_SRC_TEX_PARAMETER_OV, 10241, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10240, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10242, 33071), _defineProperty(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = function() {
    function TextureTransform2(gl) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, TextureTransform2);
      this.gl = gl;
      this.id = this.currentIndex = 0;
      this._swapTexture = null;
      this.targetTextureVarying = null;
      this.targetTextureType = null;
      this.samplerTextureMap = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    _createClass(TextureTransform2, [{
      key: "updateModelProps",
      value: function updateModelProps() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var updatedModelProps = this._processVertexShader(props);
        return Object.assign({}, props, updatedModelProps);
      }
    }, {
      key: "getDrawOptions",
      value: function getDrawOptions() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$bindings$this$c = this.bindings[this.currentIndex], sourceBuffers = _this$bindings$this$c.sourceBuffers, sourceTextures = _this$bindings$this$c.sourceTextures, framebuffer2 = _this$bindings$this$c.framebuffer, targetTexture = _this$bindings$this$c.targetTexture;
        var attributes = Object.assign({}, sourceBuffers, opts.attributes);
        var uniforms = Object.assign({}, opts.uniforms);
        var parameters = Object.assign({}, opts.parameters);
        var discard = opts.discard;
        if (this.hasSourceTextures || this.hasTargetTexture) {
          attributes.transform_elementID = this.elementIDBuffer;
          for (var sampler in this.samplerTextureMap) {
            var textureName = this.samplerTextureMap[sampler];
            uniforms[sampler] = sourceTextures[textureName];
          }
          this._setSourceTextureParameters();
          var sizeUniforms = getSizeUniforms({
            sourceTextureMap: sourceTextures,
            targetTextureVarying: this.targetTextureVarying,
            targetTexture
          });
          Object.assign(uniforms, sizeUniforms);
        }
        if (this.hasTargetTexture) {
          discard = false;
          parameters.viewport = [0, 0, framebuffer2.width, framebuffer2.height];
        }
        return {
          attributes,
          framebuffer: framebuffer2,
          uniforms,
          discard,
          parameters
        };
      }
    }, {
      key: "swap",
      value: function swap() {
        if (this._swapTexture) {
          this.currentIndex = this._getNextIndex();
          return true;
        }
        return false;
      }
    }, {
      key: "update",
      value: function update3() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupTextures(opts);
      }
    }, {
      key: "getTargetTexture",
      value: function getTargetTexture() {
        var targetTexture = this.bindings[this.currentIndex].targetTexture;
        return targetTexture;
      }
    }, {
      key: "getData",
      value: function getData() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$packed = _ref.packed, packed = _ref$packed === void 0 ? false : _ref$packed;
        var framebuffer2 = this.bindings[this.currentIndex].framebuffer;
        var pixels = readPixelsToArray(framebuffer2);
        if (!packed) {
          return pixels;
        }
        var ArrayType = pixels.constructor;
        var channelCount = typeToChannelCount(this.targetTextureType);
        var packedPixels = new ArrayType(pixels.length * channelCount / 4);
        var packCount = 0;
        for (var i = 0; i < pixels.length; i += 4) {
          for (var j = 0; j < channelCount; j++) {
            packedPixels[packCount++] = pixels[i + j];
          }
        }
        return packedPixels;
      }
    }, {
      key: "getFramebuffer",
      value: function getFramebuffer3() {
        var currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
      }
    }, {
      key: "delete",
      value: function _delete() {
        if (this.ownTexture) {
          this.ownTexture["delete"]();
        }
        if (this.elementIDBuffer) {
          this.elementIDBuffer["delete"]();
        }
      }
    }, {
      key: "_initialize",
      value: function _initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _targetTextureVarying = props._targetTextureVarying, _swapTexture = props._swapTexture;
        this._swapTexture = _swapTexture;
        this.targetTextureVarying = _targetTextureVarying;
        this.hasTargetTexture = _targetTextureVarying;
        this._setupTextures(props);
      }
    }, {
      key: "_createTargetTexture",
      value: function _createTargetTexture(props) {
        var sourceTextures = props.sourceTextures, textureOrReference = props.textureOrReference;
        if (textureOrReference instanceof Texture2D) {
          return textureOrReference;
        }
        var refTexture = sourceTextures[textureOrReference];
        if (!refTexture) {
          return null;
        }
        this._targetRefTexName = textureOrReference;
        return this._createNewTexture(refTexture);
      }
    }, {
      key: "_setupTextures",
      value: function _setupTextures() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var sourceBuffers = props.sourceBuffers, _props$_sourceTexture = props._sourceTextures, _sourceTextures = _props$_sourceTexture === void 0 ? {} : _props$_sourceTexture, _targetTexture = props._targetTexture;
        var targetTexture = this._createTargetTexture({
          sourceTextures: _sourceTextures,
          textureOrReference: _targetTexture
        });
        this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
        this._updateBindings({
          sourceBuffers,
          sourceTextures: _sourceTextures,
          targetTexture
        });
        if ("elementCount" in props) {
          this._updateElementIDBuffer(props.elementCount);
        }
      }
    }, {
      key: "_updateElementIDBuffer",
      value: function _updateElementIDBuffer(elementCount) {
        if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
          return;
        }
        var elementIds = new Float32Array(elementCount);
        elementIds.forEach(function(_, index, array) {
          array[index] = index;
        });
        if (!this.elementIDBuffer) {
          this.elementIDBuffer = new Buffer2(this.gl, {
            data: elementIds,
            accessor: {
              size: 1
            }
          });
        } else {
          this.elementIDBuffer.setData({
            data: elementIds
          });
        }
        this.elementCount = elementCount;
      }
    }, {
      key: "_updateBindings",
      value: function _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this._swapTexture) {
          var _this$_swapTextures = this._swapTextures(this.bindings[this.currentIndex]), sourceTextures = _this$_swapTextures.sourceTextures, targetTexture = _this$_swapTextures.targetTexture;
          var nextIndex = this._getNextIndex();
          this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
            sourceTextures,
            targetTexture
          });
        }
      }
    }, {
      key: "_updateBinding",
      value: function _updateBinding(binding, opts) {
        var sourceBuffers = opts.sourceBuffers, sourceTextures = opts.sourceTextures, targetTexture = opts.targetTexture;
        if (!binding) {
          binding = {
            sourceBuffers: {},
            sourceTextures: {},
            targetTexture: null
          };
        }
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
          binding.targetTexture = targetTexture;
          var width = targetTexture.width, height = targetTexture.height;
          var _binding = binding, framebuffer2 = _binding.framebuffer;
          if (framebuffer2) {
            framebuffer2.update({
              attachments: _defineProperty({}, 36064, targetTexture),
              resizeAttachments: false
            });
            framebuffer2.resize({
              width,
              height
            });
          } else {
            binding.framebuffer = new Framebuffer(this.gl, {
              id: "transform-framebuffer",
              width,
              height,
              attachments: _defineProperty({}, 36064, targetTexture)
            });
          }
        }
        return binding;
      }
    }, {
      key: "_setSourceTextureParameters",
      value: function _setSourceTextureParameters() {
        var index = this.currentIndex;
        var sourceTextures = this.bindings[index].sourceTextures;
        for (var name in sourceTextures) {
          sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
        }
      }
    }, {
      key: "_swapTextures",
      value: function _swapTextures(opts) {
        if (!this._swapTexture) {
          return null;
        }
        var sourceTextures = Object.assign({}, opts.sourceTextures);
        sourceTextures[this._swapTexture] = opts.targetTexture;
        var targetTexture = opts.sourceTextures[this._swapTexture];
        return {
          sourceTextures,
          targetTexture
        };
      }
    }, {
      key: "_createNewTexture",
      value: function _createNewTexture(refTexture) {
        var _parameters;
        var texture = cloneTextureFrom(refTexture, {
          parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters),
          pixelStore: _defineProperty({}, 37440, false)
        });
        if (this.ownTexture) {
          this.ownTexture["delete"]();
        }
        this.ownTexture = texture;
        return texture;
      }
    }, {
      key: "_getNextIndex",
      value: function _getNextIndex() {
        return (this.currentIndex + 1) % 2;
      }
    }, {
      key: "_processVertexShader",
      value: function _processVertexShader() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$bindings$this$c2 = this.bindings[this.currentIndex], sourceTextures = _this$bindings$this$c2.sourceTextures, targetTexture = _this$bindings$this$c2.targetTexture;
        var _updateForTextures = updateForTextures({
          vs: props.vs,
          sourceTextureMap: sourceTextures,
          targetTextureVarying: this.targetTextureVarying,
          targetTexture
        }), vs7 = _updateForTextures.vs, uniforms = _updateForTextures.uniforms, targetTextureType = _updateForTextures.targetTextureType, inject = _updateForTextures.inject, samplerTextureMap = _updateForTextures.samplerTextureMap;
        var combinedInject = combineInjects([props.inject || {}, inject]);
        this.targetTextureType = targetTextureType;
        this.samplerTextureMap = samplerTextureMap;
        var fs4 = props._fs || getPassthroughFS({
          version: getShaderVersion(vs7),
          input: this.targetTextureVarying,
          inputType: targetTextureType,
          output: FS_OUTPUT_VARIABLE
        });
        var modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
        return {
          vs: vs7,
          fs: fs4,
          modules,
          uniforms,
          inject: combinedInject
        };
      }
    }]);
    return TextureTransform2;
  }();

  // node_modules/@luma.gl/engine/dist/esm/transform/transform.js
  function _createForOfIteratorHelper23(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray24(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray24(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray24(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray24(o, minLen);
  }
  function _arrayLikeToArray24(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var Transform = function() {
    _createClass(Transform2, null, [{
      key: "isSupported",
      value: function isSupported(gl) {
        return isWebGL2(gl);
      }
    }]);
    function Transform2(gl) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Transform2);
      this.gl = gl;
      this.model = null;
      this.elementCount = 0;
      this.bufferTransform = null;
      this.textureTransform = null;
      this.elementIDBuffer = null;
      this._initialize(props);
      Object.seal(this);
    }
    _createClass(Transform2, [{
      key: "delete",
      value: function _delete() {
        var model = this.model, bufferTransform = this.bufferTransform, textureTransform = this.textureTransform;
        if (model) {
          model["delete"]();
        }
        if (bufferTransform) {
          bufferTransform["delete"]();
        }
        if (textureTransform) {
          textureTransform["delete"]();
        }
      }
    }, {
      key: "run",
      value: function run() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _opts$clearRenderTarg = opts.clearRenderTarget, clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;
        var updatedOpts = this._updateDrawOptions(opts);
        if (clearRenderTarget && updatedOpts.framebuffer) {
          updatedOpts.framebuffer.clear({
            color: true
          });
        }
        this.model.transform(updatedOpts);
      }
    }, {
      key: "swap",
      value: function swap() {
        var swapped = false;
        var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        var _iterator = _createForOfIteratorHelper23(resourceTransforms), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var resourceTransform = _step.value;
            swapped = swapped || resourceTransform.swap();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        assert5(swapped, "Nothing to swap");
      }
    }, {
      key: "getBuffer",
      value: function getBuffer() {
        var varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
      }
    }, {
      key: "getData",
      value: function getData() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        var _iterator2 = _createForOfIteratorHelper23(resourceTransforms), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var resourceTransform = _step2.value;
            var data = resourceTransform.getData(opts);
            if (data) {
              return data;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return null;
      }
    }, {
      key: "getFramebuffer",
      value: function getFramebuffer3() {
        return this.textureTransform && this.textureTransform.getFramebuffer();
      }
    }, {
      key: "update",
      value: function update3() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if ("elementCount" in opts) {
          this.model.setVertexCount(opts.elementCount);
        }
        var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        var _iterator3 = _createForOfIteratorHelper23(resourceTransforms), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var resourceTransform = _step3.value;
            resourceTransform.update(opts);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }, {
      key: "_initialize",
      value: function _initialize() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var gl = this.gl;
        this._buildResourceTransforms(gl, props);
        props = this._updateModelProps(props);
        this.model = new Model(gl, Object.assign({}, props, {
          fs: props.fs || getPassthroughFS({
            version: getShaderVersion(props.vs)
          }),
          id: props.id || "transform-model",
          drawMode: props.drawMode || 0,
          vertexCount: props.elementCount
        }));
        this.bufferTransform && this.bufferTransform.setupResources({
          model: this.model
        });
      }
    }, {
      key: "_updateModelProps",
      value: function _updateModelProps(props) {
        var updatedProps = Object.assign({}, props);
        var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        var _iterator4 = _createForOfIteratorHelper23(resourceTransforms), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var resourceTransform = _step4.value;
            updatedProps = resourceTransform.updateModelProps(updatedProps);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return updatedProps;
      }
    }, {
      key: "_buildResourceTransforms",
      value: function _buildResourceTransforms(gl, props) {
        if (canCreateBufferTransform(props)) {
          this.bufferTransform = new BufferTransform(gl, props);
        }
        if (canCreateTextureTransform(props)) {
          this.textureTransform = new TextureTransform(gl, props);
        }
        assert5(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
      }
    }, {
      key: "_updateDrawOptions",
      value: function _updateDrawOptions(opts) {
        var updatedOpts = Object.assign({}, opts);
        var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        var _iterator5 = _createForOfIteratorHelper23(resourceTransforms), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var resourceTransform = _step5.value;
            updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        return updatedOpts;
      }
    }]);
    return Transform2;
  }();
  function canCreateBufferTransform(props) {
    if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
      return true;
    }
    return false;
  }
  function canCreateTextureTransform(props) {
    if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
      return true;
    }
    return false;
  }

  // node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
  function ownKeys9(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys9(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys9(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var DRAW_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var Geometry = function() {
    _createClass(Geometry3, null, [{
      key: "DRAW_MODE",
      get: function get2() {
        return DRAW_MODE;
      }
    }]);
    function Geometry3() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Geometry3);
      var _props$id = props.id, id = _props$id === void 0 ? uid("geometry") : _props$id, _props$drawMode = props.drawMode, drawMode = _props$drawMode === void 0 ? DRAW_MODE.TRIANGLES : _props$drawMode, _props$attributes = props.attributes, attributes = _props$attributes === void 0 ? {} : _props$attributes, _props$indices = props.indices, indices = _props$indices === void 0 ? null : _props$indices, _props$vertexCount = props.vertexCount, vertexCount = _props$vertexCount === void 0 ? null : _props$vertexCount;
      this.id = id;
      this.drawMode = drawMode | 0;
      this.attributes = {};
      this.userData = {};
      this._setAttributes(attributes, indices);
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    _createClass(Geometry3, [{
      key: "getVertexCount",
      value: function getVertexCount() {
        return this.vertexCount;
      }
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        return this.indices ? _objectSpread9({
          indices: this.indices
        }, this.attributes) : this.attributes;
      }
    }, {
      key: "_print",
      value: function _print(attributeName) {
        return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
      }
    }, {
      key: "_setAttributes",
      value: function _setAttributes(attributes, indices) {
        if (indices) {
          this.indices = ArrayBuffer.isView(indices) ? {
            value: indices,
            size: 1
          } : indices;
        }
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          attribute = ArrayBuffer.isView(attribute) ? {
            value: attribute
          } : attribute;
          assert5(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
          if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
            attribute.size = 3;
          }
          if (attributeName === "indices") {
            assert5(!this.indices);
            this.indices = attribute;
          } else {
            this.attributes[attributeName] = attribute;
          }
        }
        if (this.indices && this.indices.isIndexed !== void 0) {
          this.indices = Object.assign({}, this.indices);
          delete this.indices.isIndexed;
        }
        return this;
      }
    }, {
      key: "_calculateVertexCount",
      value: function _calculateVertexCount(attributes, indices) {
        if (indices) {
          return indices.value.length;
        }
        var vertexCount = Infinity;
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var value17 = attribute.value, size = attribute.size, constant = attribute.constant;
          if (!constant && value17 && size >= 1) {
            vertexCount = Math.min(vertexCount, value17.length / size);
          }
        }
        assert5(Number.isFinite(vertexCount));
        return vertexCount;
      }
    }, {
      key: "mode",
      get: function get2() {
        return this.drawMode;
      }
    }]);
    return Geometry3;
  }();

  // node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
  function _createForOfIteratorHelper24(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray25(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray25(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray25(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray25(o, minLen);
  }
  function _arrayLikeToArray25(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = function() {
    function Timeline2() {
      _classCallCheck(this, Timeline2);
      this.time = 0;
      this.channels = new Map();
      this.animations = new Map();
      this.playing = false;
      this.lastEngineTime = -1;
    }
    _createClass(Timeline2, [{
      key: "addChannel",
      value: function addChannel(props) {
        var _props$delay = props.delay, delay = _props$delay === void 0 ? 0 : _props$delay, _props$duration = props.duration, duration = _props$duration === void 0 ? Number.POSITIVE_INFINITY : _props$duration, _props$rate = props.rate, rate = _props$rate === void 0 ? 1 : _props$rate, _props$repeat = props.repeat, repeat = _props$repeat === void 0 ? 1 : _props$repeat;
        var handle = channelHandles++;
        var channel = {
          time: 0,
          delay,
          duration,
          rate,
          repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(handle, channel);
        return handle;
      }
    }, {
      key: "removeChannel",
      value: function removeChannel(handle) {
        this.channels["delete"](handle);
        var _iterator = _createForOfIteratorHelper24(this.animations), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), animationHandle = _step$value[0], animation = _step$value[1];
            if (animation.channel === handle) {
              this.detachAnimation(animationHandle);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "isFinished",
      value: function isFinished(handle) {
        var channel = this.channels.get(handle);
        if (channel === void 0) {
          return false;
        }
        return this.time >= channel.delay + channel.duration * channel.repeat;
      }
    }, {
      key: "getTime",
      value: function getTime(handle) {
        if (handle === void 0) {
          return this.time;
        }
        var channel = this.channels.get(handle);
        if (channel === void 0) {
          return -1;
        }
        return channel.time;
      }
    }, {
      key: "setTime",
      value: function setTime(time) {
        this.time = Math.max(0, time);
        var channels = this.channels.values();
        var _iterator2 = _createForOfIteratorHelper24(channels), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var channel = _step2.value;
            this._setChannelTime(channel, this.time);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var animations = this.animations.values();
        var _iterator3 = _createForOfIteratorHelper24(animations), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var animationData = _step3.value;
            var animation = animationData.animation, _channel = animationData.channel;
            animation.setTime(this.getTime(_channel));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }, {
      key: "play",
      value: function play() {
        this.playing = true;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.playing = false;
        this.lastEngineTime = -1;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setTime(0);
      }
    }, {
      key: "attachAnimation",
      value: function attachAnimation(animation, channelHandle) {
        var animationHandle = animationHandles++;
        this.animations.set(animationHandle, {
          animation,
          channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
      }
    }, {
      key: "detachAnimation",
      value: function detachAnimation(handle) {
        this.animations["delete"](handle);
      }
    }, {
      key: "update",
      value: function update3(engineTime) {
        if (this.playing) {
          if (this.lastEngineTime === -1) {
            this.lastEngineTime = engineTime;
          }
          this.setTime(this.time + (engineTime - this.lastEngineTime));
          this.lastEngineTime = engineTime;
        }
      }
    }, {
      key: "_setChannelTime",
      value: function _setChannelTime(channel, time) {
        var offsetTime = time - channel.delay;
        var totalDuration = channel.duration * channel.repeat;
        if (offsetTime >= totalDuration) {
          channel.time = channel.duration * channel.rate;
        } else {
          channel.time = Math.max(0, offsetTime) % channel.duration;
          channel.time *= channel.rate;
        }
      }
    }]);
    return Timeline2;
  }();

  // node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js
  var vs3 = "\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry;\n";
  var fs2 = "\n#define SMOOTH_EDGE_RADIUS 0.5\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n";
  var geometry_default = {
    name: "geometry",
    vs: vs3,
    fs: fs2
  };

  // node_modules/@deck.gl/core/dist/esm/lib/constants.js
  var COORDINATE_SYSTEM = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
  };
  Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
    get: function get() {
      return log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")() || 0;
    }
  });
  var PROJECTION_MODE = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
  };
  var EVENTS = {
    click: {
      handler: "onClick"
    },
    panstart: {
      handler: "onDragStart"
    },
    panmove: {
      handler: "onDrag"
    },
    panend: {
      handler: "onDragEnd"
    }
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js
  var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map(function(key) {
    return "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(COORDINATE_SYSTEM[key], ";");
  }).join("");
  var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map(function(key) {
    return "const int PROJECTION_MODE_".concat(key, " = ").concat(PROJECTION_MODE[key], ";");
  }).join("");
  var project_glsl_default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z;\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy;\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter;\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    dy = clamp(dy, -1., 1.);\n  }\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  );\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy) * WORLD_SCALE,\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n");

  // node_modules/@deck.gl/core/dist/esm/utils/memoize.js
  function isEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (Array.isArray(a)) {
      var len2 = a.length;
      if (!b || b.length !== len2) {
        return false;
      }
      for (var i = 0; i < len2; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function memoize(compute) {
    var cachedArgs = {};
    var cachedResult;
    return function(args) {
      for (var key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }

  // node_modules/@deck.gl/core/dist/esm/utils/assert.js
  function assert8(condition, message) {
    if (!condition) {
      throw new Error(message || "deck.gl: assertion failed.");
    }
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js
  var ZERO_VECTOR = [0, 0, 0, 0];
  var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
  var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
  var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  function getOffsetOrigin(viewport3, coordinateSystem) {
    var coordinateOrigin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_COORDINATE_ORIGIN;
    var shaderCoordinateOrigin = coordinateOrigin;
    var geospatialOrigin;
    var offsetMode = true;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      geospatialOrigin = coordinateOrigin;
    } else {
      geospatialOrigin = viewport3.isGeospatial ? [Math.fround(viewport3.longitude), Math.fround(viewport3.latitude), 0] : null;
    }
    switch (viewport3.projectionMode) {
      case PROJECTION_MODE.WEB_MERCATOR:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          offsetMode = false;
        }
        break;
      case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          shaderCoordinateOrigin = geospatialOrigin;
        } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          shaderCoordinateOrigin = [Math.fround(viewport3.center[0]), Math.fround(viewport3.center[1]), 0];
          geospatialOrigin = viewport3.unprojectPosition(shaderCoordinateOrigin);
          shaderCoordinateOrigin[0] -= coordinateOrigin[0];
          shaderCoordinateOrigin[1] -= coordinateOrigin[1];
          shaderCoordinateOrigin[2] -= coordinateOrigin[2];
        }
        break;
      case PROJECTION_MODE.IDENTITY:
        shaderCoordinateOrigin = viewport3.position.map(Math.fround);
        break;
      case PROJECTION_MODE.GLOBE:
        offsetMode = false;
        geospatialOrigin = null;
        break;
      default:
        offsetMode = false;
    }
    shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
    return {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    };
  }
  function calculateMatrixAndOffset(viewport3, coordinateSystem, coordinateOrigin) {
    var viewMatrixUncentered = viewport3.viewMatrixUncentered, projectionMatrix = viewport3.projectionMatrix;
    var viewMatrix = viewport3.viewMatrix, viewProjectionMatrix = viewport3.viewProjectionMatrix;
    var projectionCenter = ZERO_VECTOR;
    var cameraPosCommon = viewport3.cameraPosition;
    var _getOffsetOrigin = getOffsetOrigin(viewport3, coordinateSystem, coordinateOrigin), geospatialOrigin = _getOffsetOrigin.geospatialOrigin, shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin, offsetMode = _getOffsetOrigin.offsetMode;
    if (offsetMode) {
      var positionCommonSpace = viewport3.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2] - positionCommonSpace[2]];
      positionCommonSpace[3] = 1;
      projectionCenter = transformMat43([], positionCommonSpace, viewProjectionMatrix);
      viewMatrix = viewMatrixUncentered || viewMatrix;
      viewProjectionMatrix = multiply3([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = multiply3([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    }
    return {
      viewMatrix,
      viewProjectionMatrix,
      projectionCenter,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    };
  }
  function getUniformsFromViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, viewport3 = _ref.viewport, _ref$devicePixelRatio = _ref.devicePixelRatio, devicePixelRatio = _ref$devicePixelRatio === void 0 ? 1 : _ref$devicePixelRatio, _ref$modelMatrix = _ref.modelMatrix, modelMatrix = _ref$modelMatrix === void 0 ? null : _ref$modelMatrix, _ref$coordinateSystem = _ref.coordinateSystem, coordinateSystem = _ref$coordinateSystem === void 0 ? COORDINATE_SYSTEM.DEFAULT : _ref$coordinateSystem, coordinateOrigin = _ref.coordinateOrigin, _ref$autoWrapLongitud = _ref.autoWrapLongitude, autoWrapLongitude = _ref$autoWrapLongitud === void 0 ? false : _ref$autoWrapLongitud, projectionMode = _ref.projectionMode, positionOrigin = _ref.positionOrigin;
    assert8(viewport3);
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport3.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    var uniforms = getMemoizedViewportUniforms({
      viewport: viewport3,
      devicePixelRatio,
      coordinateSystem,
      coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;
    return uniforms;
  }
  function calculateViewportUniforms(_ref2) {
    var viewport3 = _ref2.viewport, devicePixelRatio = _ref2.devicePixelRatio, coordinateSystem = _ref2.coordinateSystem, coordinateOrigin = _ref2.coordinateOrigin;
    var _calculateMatrixAndOf = calculateMatrixAndOffset(viewport3, coordinateSystem, coordinateOrigin), projectionCenter = _calculateMatrixAndOf.projectionCenter, viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix, cameraPosCommon = _calculateMatrixAndOf.cameraPosCommon, shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin, geospatialOrigin = _calculateMatrixAndOf.geospatialOrigin;
    var distanceScales = viewport3.getDistanceScales();
    var viewportSize = [viewport3.width * devicePixelRatio, viewport3.height * devicePixelRatio];
    var uniforms = {
      project_uCoordinateSystem: coordinateSystem,
      project_uProjectionMode: viewport3.projectionMode,
      project_uCoordinateOrigin: shaderCoordinateOrigin,
      project_uCenter: projectionCenter,
      project_uViewportSize: viewportSize,
      project_uDevicePixelRatio: devicePixelRatio,
      project_uFocalDistance: viewport3.focalDistance || 1,
      project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
      project_uScale: viewport3.scale,
      project_uViewProjectionMatrix: viewProjectionMatrix,
      project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
      var distanceScalesAtOrigin = viewport3.getDistanceScales(geospatialOrigin);
      switch (coordinateSystem) {
        case COORDINATE_SYSTEM.METER_OFFSETS:
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
          break;
        case COORDINATE_SYSTEM.LNGLAT:
        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
          break;
        case COORDINATE_SYSTEM.CARTESIAN:
          uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
          uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
          break;
        default:
          break;
      }
    }
    return uniforms;
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js
  var INITIAL_MODULE_OPTIONS3 = {};
  function getUniforms4() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS3;
    if (opts.viewport) {
      return getUniformsFromViewport(opts);
    }
    return {};
  }
  var project_default = {
    name: "project",
    dependencies: [fp32],
    vs: project_glsl_default,
    getUniforms: getUniforms4
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js
  var vs4 = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    mat3 rotation = project_get_orientation_matrix(projectedPosition);\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
  var project32_default = {
    name: "project32",
    dependencies: [project_default],
    vs: vs4
  };

  // node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function transformVector(matrix, vector) {
    var result = transformMat43([], vector, matrix);
    scale3(result, result, 1 / result[3]);
    return result;
  }
  function mod(value17, divisor) {
    var modulus = value17 % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }

  // node_modules/@math.gl/web-mercator/dist/esm/assert.js
  function assert9(condition, message) {
    if (!condition) {
      throw new Error(message || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS2 = PI / 180;
  var RADIANS_TO_DEGREES2 = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  var DEFAULT_ALTITUDE = 1.5;
  function zoomToScale(zoom) {
    return Math.pow(2, zoom);
  }
  function scaleToZoom(scale5) {
    return Math.log2(scale5);
  }
  function lngLatToWorld(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), lng = _ref2[0], lat = _ref2[1];
    assert9(Number.isFinite(lng));
    assert9(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    var lambda2 = lng * DEGREES_TO_RADIANS2;
    var phi2 = lat * DEGREES_TO_RADIANS2;
    var x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    var y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x, y];
  }
  function worldToLngLat(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), x = _ref4[0], y = _ref4[1];
    var lambda2 = x / TILE_SIZE * (2 * PI) - PI;
    var phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
  }
  function getMeterZoom(_ref5) {
    var latitude = _ref5.latitude;
    assert9(Number.isFinite(latitude));
    var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
  }
  function getDistanceScales(_ref6) {
    var latitude = _ref6.latitude, longitude = _ref6.longitude, _ref6$highPrecision = _ref6.highPrecision, highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;
    assert9(Number.isFinite(latitude) && Number.isFinite(longitude));
    var result = {};
    var worldSize = TILE_SIZE;
    var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    var unitsPerDegreeX = worldSize / 360;
    var unitsPerDegreeY = unitsPerDegreeX / latCosine;
    var altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    result.unitsPerMeter = [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter];
    result.metersPerUnit = [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter];
    result.unitsPerDegree = [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter];
    result.degreesPerUnit = [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter];
    if (highPrecision) {
      var latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
      var unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
      var altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
      var altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
      result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
      result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
    }
    return result;
  }
  function addMetersToLngLat(lngLatZ, xyz) {
    var _lngLatZ = _slicedToArray(lngLatZ, 3), longitude = _lngLatZ[0], latitude = _lngLatZ[1], z0 = _lngLatZ[2];
    var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
    var _getDistanceScales = getDistanceScales({
      longitude,
      latitude,
      highPrecision: true
    }), unitsPerMeter = _getDistanceScales.unitsPerMeter, unitsPerMeter2 = _getDistanceScales.unitsPerMeter2;
    var worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);
    worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);
    var newLngLat = worldToLngLat(worldspace);
    var newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
  }
  function getViewMatrix(_ref7) {
    var height = _ref7.height, pitch = _ref7.pitch, bearing = _ref7.bearing, altitude = _ref7.altitude, scale5 = _ref7.scale, _ref7$center = _ref7.center, center = _ref7$center === void 0 ? null : _ref7$center;
    var vm = createMat4();
    translate2(vm, vm, [0, 0, -altitude]);
    rotateX2(vm, vm, -pitch * DEGREES_TO_RADIANS2);
    rotateZ2(vm, vm, bearing * DEGREES_TO_RADIANS2);
    scale5 /= height;
    scale2(vm, vm, [scale5, scale5, scale5]);
    if (center) {
      translate2(vm, vm, negate2([], center));
    }
    return vm;
  }
  function getProjectionParameters(_ref8) {
    var width = _ref8.width, height = _ref8.height, _ref8$altitude = _ref8.altitude, altitude = _ref8$altitude === void 0 ? DEFAULT_ALTITUDE : _ref8$altitude, _ref8$pitch = _ref8.pitch, pitch = _ref8$pitch === void 0 ? 0 : _ref8$pitch, _ref8$nearZMultiplier = _ref8.nearZMultiplier, nearZMultiplier = _ref8$nearZMultiplier === void 0 ? 1 : _ref8$nearZMultiplier, _ref8$farZMultiplier = _ref8.farZMultiplier, farZMultiplier = _ref8$farZMultiplier === void 0 ? 1 : _ref8$farZMultiplier;
    var pitchRadians = pitch * DEGREES_TO_RADIANS2;
    var halfFov = Math.atan(0.5 / altitude);
    var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.min(Math.max(Math.PI / 2 - pitchRadians - halfFov, 0.01), Math.PI - 0.01));
    var farZ = Math.sin(pitchRadians) * topHalfSurfaceDistance + altitude;
    return {
      fov: 2 * halfFov,
      aspect: width / height,
      focalDistance: altitude,
      near: nearZMultiplier,
      far: farZ * farZMultiplier
    };
  }
  function getProjectionMatrix(_ref9) {
    var width = _ref9.width, height = _ref9.height, pitch = _ref9.pitch, altitude = _ref9.altitude, nearZMultiplier = _ref9.nearZMultiplier, farZMultiplier = _ref9.farZMultiplier;
    var _getProjectionParamet = getProjectionParameters({
      width,
      height,
      altitude,
      pitch,
      nearZMultiplier,
      farZMultiplier
    }), fov = _getProjectionParamet.fov, aspect = _getProjectionParamet.aspect, near = _getProjectionParamet.near, far = _getProjectionParamet.far;
    var projectionMatrix = perspective([], fov, aspect, near, far);
    return projectionMatrix;
  }
  function worldToPixels(xyz, pixelProjectionMatrix) {
    var _xyz2 = _slicedToArray(xyz, 3), x = _xyz2[0], y = _xyz2[1], _xyz2$ = _xyz2[2], z = _xyz2$ === void 0 ? 0 : _xyz2$;
    assert9(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
    return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
  }
  function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
    var targetZ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var _xyz3 = _slicedToArray(xyz, 3), x = _xyz3[0], y = _xyz3[1], z = _xyz3[2];
    assert9(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
    if (Number.isFinite(z)) {
      var coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
      return coord;
    }
    var coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
    var coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);
    var z0 = coord0[2];
    var z1 = coord1[2];
    var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return lerp2([], coord0, coord1, t);
  }

  // node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
  function fitBounds(_ref) {
    var width = _ref.width, height = _ref.height, bounds = _ref.bounds, _ref$minExtent = _ref.minExtent, minExtent = _ref$minExtent === void 0 ? 0 : _ref$minExtent, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? 24 : _ref$maxZoom, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 0 : _ref$padding, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;
    var _bounds = _slicedToArray(bounds, 2), _bounds$ = _slicedToArray(_bounds[0], 2), west = _bounds$[0], south = _bounds$[1], _bounds$2 = _slicedToArray(_bounds[1], 2), east = _bounds$2[0], north = _bounds$2[1];
    if (Number.isFinite(padding)) {
      var p = padding;
      padding = {
        top: p,
        bottom: p,
        left: p,
        right: p
      };
    } else {
      assert9(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    }
    var viewport3 = new WebMercatorViewport({
      width,
      height,
      longitude: 0,
      latitude: 0,
      zoom: 0
    });
    var nw = viewport3.project([west, north]);
    var se = viewport3.project([east, south]);
    var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
    var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
    assert9(targetSize[0] > 0 && targetSize[1] > 0);
    var scaleX2 = targetSize[0] / size[0];
    var scaleY2 = targetSize[1] / size[1];
    var offsetX = (padding.right - padding.left) / 2 / scaleX2;
    var offsetY = (padding.bottom - padding.top) / 2 / scaleY2;
    var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
    var centerLngLat = viewport3.unproject(center);
    var zoom = Math.min(maxZoom, viewport3.zoom + Math.log2(Math.abs(Math.min(scaleX2, scaleY2))));
    assert9(Number.isFinite(zoom));
    return {
      longitude: centerLngLat[0],
      latitude: centerLngLat[1],
      zoom
    };
  }

  // node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getBounds(viewport3) {
    var z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var width = viewport3.width, height = viewport3.height, unproject = viewport3.unproject;
    var unprojectOps = {
      targetZ: z
    };
    var bottomLeft = unproject([0, height], unprojectOps);
    var bottomRight = unproject([width, height], unprojectOps);
    var topLeft;
    var topRight;
    var halfFov = Math.atan(0.5 / viewport3.altitude);
    var angleToGround = (90 - viewport3.pitch) * DEGREES_TO_RADIANS3;
    if (halfFov > angleToGround - 0.01) {
      topLeft = unprojectOnFarPlane(viewport3, 0, z);
      topRight = unprojectOnFarPlane(viewport3, width, z);
    } else {
      topLeft = unproject([0, 0], unprojectOps);
      topRight = unproject([width, 0], unprojectOps);
    }
    return [bottomLeft, bottomRight, topRight, topLeft];
  }
  function unprojectOnFarPlane(viewport3, x, targetZ) {
    var pixelUnprojectionMatrix = viewport3.pixelUnprojectionMatrix;
    var coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);
    var coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport3.height, 1, 1]);
    var z = targetZ * viewport3.distanceScales.unitsPerMeter[2];
    var t = (z - coord0[2]) / (coord1[2] - coord0[2]);
    var coord = lerp2([], coord0, coord1, t);
    var result = worldToLngLat(coord);
    result[2] = targetZ;
    return result;
  }

  // node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js
  var WebMercatorViewport = function() {
    function WebMercatorViewport3() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        width: 1,
        height: 1
      }, width = _ref.width, height = _ref.height, _ref$latitude = _ref.latitude, latitude = _ref$latitude === void 0 ? 0 : _ref$latitude, _ref$longitude = _ref.longitude, longitude = _ref$longitude === void 0 ? 0 : _ref$longitude, _ref$zoom = _ref.zoom, zoom = _ref$zoom === void 0 ? 0 : _ref$zoom, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 0 : _ref$pitch, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? 0 : _ref$bearing, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude, _ref$position = _ref.position, position = _ref$position === void 0 ? null : _ref$position, _ref$nearZMultiplier = _ref.nearZMultiplier, nearZMultiplier = _ref$nearZMultiplier === void 0 ? 0.02 : _ref$nearZMultiplier, _ref$farZMultiplier = _ref.farZMultiplier, farZMultiplier = _ref$farZMultiplier === void 0 ? 1.01 : _ref$farZMultiplier;
      _classCallCheck(this, WebMercatorViewport3);
      width = width || 1;
      height = height || 1;
      var scale5 = zoomToScale(zoom);
      altitude = Math.max(0.75, altitude);
      var distanceScales = getDistanceScales({
        longitude,
        latitude
      });
      var center = lngLatToWorld([longitude, latitude]);
      center[2] = 0;
      if (position) {
        add2(center, center, mul([], position, distanceScales.unitsPerMeter));
      }
      this.projectionMatrix = getProjectionMatrix({
        width,
        height,
        pitch,
        altitude,
        nearZMultiplier,
        farZMultiplier
      });
      this.viewMatrix = getViewMatrix({
        height,
        scale: scale5,
        center,
        pitch,
        bearing,
        altitude
      });
      this.width = width;
      this.height = height;
      this.scale = scale5;
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.center = center;
      this.meterOffset = position || [0, 0, 0];
      this.distanceScales = distanceScales;
      this._initMatrices();
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      Object.freeze(this);
    }
    _createClass(WebMercatorViewport3, [{
      key: "_initMatrices",
      value: function _initMatrices() {
        var width = this.width, height = this.height, projectionMatrix = this.projectionMatrix, viewMatrix = this.viewMatrix;
        var vpm = createMat4();
        multiply3(vpm, vpm, projectionMatrix);
        multiply3(vpm, vpm, viewMatrix);
        this.viewProjectionMatrix = vpm;
        var m = createMat4();
        scale2(m, m, [width / 2, -height / 2, 1]);
        translate2(m, m, [1, -1, 0]);
        multiply3(m, m, vpm);
        var mInverse = invert2(createMat4(), m);
        if (!mInverse) {
          throw new Error("Pixel project matrix not invertible");
        }
        this.pixelProjectionMatrix = m;
        this.pixelUnprojectionMatrix = mInverse;
      }
    }, {
      key: "equals",
      value: function equals5(viewport3) {
        if (!(viewport3 instanceof WebMercatorViewport3)) {
          return false;
        }
        return viewport3.width === this.width && viewport3.height === this.height && equals2(viewport3.projectionMatrix, this.projectionMatrix) && equals2(viewport3.viewMatrix, this.viewMatrix);
      }
    }, {
      key: "project",
      value: function project2(xyz) {
        var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$topLeft = _ref2.topLeft, topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;
        var worldPosition = this.projectPosition(xyz);
        var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
        var _coord = _slicedToArray(coord, 2), x = _coord[0], y = _coord[1];
        var y2 = topLeft ? y : this.height - y;
        return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
      }
    }, {
      key: "unproject",
      value: function unproject(xyz) {
        var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref3$topLeft = _ref3.topLeft, topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft, _ref3$targetZ = _ref3.targetZ, targetZ = _ref3$targetZ === void 0 ? void 0 : _ref3$targetZ;
        var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
        var y2 = topLeft ? y : this.height - y;
        var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
        var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
        var _this$unprojectPositi = this.unprojectPosition(coord), _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3), X = _this$unprojectPositi2[0], Y = _this$unprojectPositi2[1], Z = _this$unprojectPositi2[2];
        if (Number.isFinite(z)) {
          return [X, Y, Z];
        }
        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
      }
    }, {
      key: "projectPosition",
      value: function projectPosition2(xyz) {
        var _lngLatToWorld = lngLatToWorld(xyz), _lngLatToWorld2 = _slicedToArray(_lngLatToWorld, 2), X = _lngLatToWorld2[0], Y = _lngLatToWorld2[1];
        var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
        return [X, Y, Z];
      }
    }, {
      key: "unprojectPosition",
      value: function unprojectPosition(xyz) {
        var _worldToLngLat = worldToLngLat(xyz), _worldToLngLat2 = _slicedToArray(_worldToLngLat, 2), X = _worldToLngLat2[0], Y = _worldToLngLat2[1];
        var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
        return [X, Y, Z];
      }
    }, {
      key: "projectFlat",
      value: function projectFlat(lngLat) {
        return lngLatToWorld(lngLat);
      }
    }, {
      key: "unprojectFlat",
      value: function unprojectFlat(xy) {
        return worldToLngLat(xy);
      }
    }, {
      key: "getMapCenterByLngLatPosition",
      value: function getMapCenterByLngLatPosition(_ref4) {
        var lngLat = _ref4.lngLat, pos = _ref4.pos;
        var fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
        var toLocation = lngLatToWorld(lngLat);
        var translate3 = add([], toLocation, negate([], fromLocation));
        var newCenter = add([], this.center, translate3);
        return worldToLngLat(newCenter);
      }
    }, {
      key: "getLocationAtPoint",
      value: function getLocationAtPoint(_ref5) {
        var lngLat = _ref5.lngLat, pos = _ref5.pos;
        return this.getMapCenterByLngLatPosition({
          lngLat,
          pos
        });
      }
    }, {
      key: "fitBounds",
      value: function fitBounds2(bounds) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var width = this.width, height = this.height;
        var _fitBounds2 = fitBounds(Object.assign({
          width,
          height,
          bounds
        }, options)), longitude = _fitBounds2.longitude, latitude = _fitBounds2.latitude, zoom = _fitBounds2.zoom;
        return new WebMercatorViewport3({
          width,
          height,
          longitude,
          latitude,
          zoom
        });
      }
    }, {
      key: "getBounds",
      value: function getBounds2(options) {
        var corners = this.getBoundingRegion(options);
        var west = Math.min.apply(Math, _toConsumableArray(corners.map(function(p) {
          return p[0];
        })));
        var east = Math.max.apply(Math, _toConsumableArray(corners.map(function(p) {
          return p[0];
        })));
        var south = Math.min.apply(Math, _toConsumableArray(corners.map(function(p) {
          return p[1];
        })));
        var north = Math.max.apply(Math, _toConsumableArray(corners.map(function(p) {
          return p[1];
        })));
        return [[west, south], [east, north]];
      }
    }, {
      key: "getBoundingRegion",
      value: function getBoundingRegion() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return getBounds(this, options.z || 0);
      }
    }]);
    return WebMercatorViewport3;
  }();

  // node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
  var MAX_LATITUDE = 85.05113;
  var MIN_LATITUDE = -85.05113;
  function normalizeViewportProps(_ref) {
    var width = _ref.width, height = _ref.height, longitude = _ref.longitude, latitude = _ref.latitude, zoom = _ref.zoom, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 0 : _ref$pitch, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;
    if (longitude < -180 || longitude > 180) {
      longitude = mod(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      bearing = mod(bearing + 180, 360) - 180;
    }
    var flatViewport = new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
    var topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
    var bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
    var shiftY = 0;
    if (bottomY - topY < height) {
      zoom += Math.log2(height / (bottomY - topY));
      flatViewport = new WebMercatorViewport({
        width,
        height,
        longitude,
        latitude,
        zoom
      });
      topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
      bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
    }
    if (topY > 0) {
      shiftY = topY;
    } else if (bottomY < height) {
      shiftY = bottomY - height;
    }
    if (shiftY) {
      latitude = flatViewport.unproject([width / 2, height / 2 + shiftY])[1];
    }
    return {
      width,
      height,
      longitude,
      latitude,
      zoom,
      pitch,
      bearing
    };
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js
  function _createForOfIteratorHelper25(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray26(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray26(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray26(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray26(o, minLen);
  }
  function _arrayLikeToArray26(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var vs5 = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
  var fs3 = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
  var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
  var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
  var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
  var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
    var coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);
    if (Number.isFinite(z)) {
      return coord;
    }
    return [coord[0], coord[1], 0];
  }
  function getViewportCenterPosition(_ref) {
    var viewport3 = _ref.viewport, center = _ref.center;
    return new Matrix4(viewport3.viewProjectionMatrix).invert().transform(center);
  }
  function getViewProjectionMatrices(_ref2) {
    var viewport3 = _ref2.viewport, shadowMatrices = _ref2.shadowMatrices;
    var projectionMatrices = [];
    var pixelUnprojectionMatrix = viewport3.pixelUnprojectionMatrix;
    var farZ = viewport3.isGeospatial ? void 0 : 1;
    var corners = [[0, 0, farZ], [viewport3.width, 0, farZ], [0, viewport3.height, farZ], [viewport3.width, viewport3.height, farZ], [0, 0, -1], [viewport3.width, 0, -1], [0, viewport3.height, -1], [viewport3.width, viewport3.height, -1]].map(function(pixel) {
      return screenToCommonSpace(pixel, pixelUnprojectionMatrix);
    });
    var _iterator = _createForOfIteratorHelper25(shadowMatrices), _step;
    try {
      var _loop = function _loop2() {
        var shadowMatrix = _step.value;
        var viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport3.center).negate());
        var positions = corners.map(function(corner) {
          return viewMatrix.transform(corner);
        });
        var projectionMatrix = new Matrix4().ortho({
          left: Math.min.apply(Math, _toConsumableArray(positions.map(function(position) {
            return position[0];
          }))),
          right: Math.max.apply(Math, _toConsumableArray(positions.map(function(position) {
            return position[0];
          }))),
          bottom: Math.min.apply(Math, _toConsumableArray(positions.map(function(position) {
            return position[1];
          }))),
          top: Math.max.apply(Math, _toConsumableArray(positions.map(function(position) {
            return position[1];
          }))),
          near: Math.min.apply(Math, _toConsumableArray(positions.map(function(position) {
            return -position[2];
          }))),
          far: Math.max.apply(Math, _toConsumableArray(positions.map(function(position) {
            return -position[2];
          })))
        });
        projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return projectionMatrices;
  }
  function createShadowUniforms() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var uniforms = {
      shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
      shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
      shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
      shadow_uLightId: opts.shadowLightId || 0,
      shadow_uLightCount: opts.shadowMatrices.length
    };
    var center = getMemoizedViewportCenterPosition({
      viewport: opts.viewport,
      center: context.project_uCenter
    });
    var projectCenters = [];
    var viewProjectionMatrices = getMemoizedViewProjectionMatrices({
      shadowMatrices: opts.shadowMatrices,
      viewport: opts.viewport
    }).slice();
    for (var i = 0; i < opts.shadowMatrices.length; i++) {
      var viewProjectionMatrix = viewProjectionMatrices[i];
      var viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
      if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
        viewProjectionMatrices[i] = viewProjectionMatrixCentered;
        projectCenters[i] = center;
      } else {
        viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
        projectCenters[i] = viewProjectionMatrixCentered.transform(center);
      }
    }
    for (var _i = 0; _i < viewProjectionMatrices.length; _i++) {
      uniforms["shadow_uViewProjectionMatrices[".concat(_i, "]")] = viewProjectionMatrices[_i];
      uniforms["shadow_uProjectCenters[".concat(_i, "]")] = projectCenters[_i];
      if (opts.shadowMaps && opts.shadowMaps.length > 0) {
        uniforms["shadow_uShadowMap".concat(_i)] = opts.shadowMaps[_i];
      } else {
        uniforms["shadow_uShadowMap".concat(_i)] = opts.dummyShadowMap;
      }
    }
    return uniforms;
  }
  var shadow_default = {
    name: "shadow",
    dependencies: [project_default],
    vs: vs5,
    fs: fs3,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
      "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
    },
    getUniforms: function getUniforms5() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {
        var shadowUniforms = {};
        var _opts$shadowEnabled = opts.shadowEnabled, shadowEnabled = _opts$shadowEnabled === void 0 ? true : _opts$shadowEnabled;
        if (shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0) {
          Object.assign(shadowUniforms, createShadowUniforms(opts, context));
        } else {
          Object.assign(shadowUniforms, {
            shadow_uDrawShadowMap: false,
            shadow_uUseShadowMap: false
          });
        }
        return shadowUniforms;
      }
      return {};
    }
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js
  var picking_default = Object.assign({
    inject: {
      "vs:DECKGL_FILTER_COLOR": "\n    picking_setPickingColor(geometry.pickingColor);\n    // for picking depth values\n    picking_setPickingAttribute(geometry.position.z);\n    ",
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: "\n    // use highlight color if this fragment belongs to the selected object.\n    color = picking_filterHighlightColor(color);\n\n    // use picking color if rendering to picking FBO.\n    color = picking_filterPickingColor(color);\n      "
      }
    }
  }, picking);

  // node_modules/@deck.gl/core/dist/esm/shaderlib/index.js
  function _createForOfIteratorHelper26(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray27(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray27(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray27(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray27(o, minLen);
  }
  function _arrayLikeToArray27(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DEFAULT_MODULES = [geometry_default, project_default];
  var SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  function createProgramManager(gl) {
    var programManager = ProgramManager.getDefaultProgramManager(gl);
    var _iterator = _createForOfIteratorHelper26(DEFAULT_MODULES), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var shaderModule = _step.value;
        programManager.addDefaultModule(shaderModule);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper26(SHADER_HOOKS), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var shaderHook = _step2.value;
        programManager.addShaderHook(shaderHook);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return programManager;
  }

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js
  var DEFAULT_LIGHT_COLOR = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY = 1;
  var idCount = 0;
  var AmbientLight = function AmbientLight2() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, AmbientLight2);
    var _props$color = props.color, color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR : _props$color;
    var _props$intensity = props.intensity, intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY : _props$intensity;
    this.id = props.id || "ambient-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = "ambient";
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js
  var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY2 = 1;
  var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
  var idCount2 = 0;
  var DirectionalLight = function() {
    function DirectionalLight2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, DirectionalLight2);
      var _props$color = props.color, color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR2 : _props$color;
      var _props$intensity = props.intensity, intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY2 : _props$intensity;
      var _props$direction = props.direction, direction = _props$direction === void 0 ? DEFAULT_LIGHT_DIRECTION : _props$direction;
      var _props$_shadow = props._shadow, _shadow = _props$_shadow === void 0 ? false : _props$_shadow;
      this.id = props.id || "directional-".concat(idCount2++);
      this.color = color;
      this.intensity = intensity;
      this.type = "directional";
      this.direction = new Vector3(direction).normalize().toArray();
      this.shadow = _shadow;
    }
    _createClass(DirectionalLight2, [{
      key: "getProjectedLight",
      value: function getProjectedLight() {
        return this;
      }
    }]);
    return DirectionalLight2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/effect.js
  var Effect = function() {
    function Effect2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Effect2);
      var _props$id = props.id, id = _props$id === void 0 ? "effect" : _props$id;
      this.id = id;
      this.props = {};
      Object.assign(this.props, props);
    }
    _createClass(Effect2, [{
      key: "preRender",
      value: function preRender() {
      }
    }, {
      key: "getModuleParameters",
      value: function getModuleParameters() {
      }
    }, {
      key: "cleanup",
      value: function cleanup() {
      }
    }]);
    return Effect2;
  }();

  // node_modules/@deck.gl/core/dist/esm/passes/pass.js
  var Pass = function() {
    function Pass2(gl) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Pass2);
      var _props$id = props.id, id = _props$id === void 0 ? "pass" : _props$id;
      this.id = id;
      this.gl = gl;
      this.props = {};
      Object.assign(this.props, props);
    }
    _createClass(Pass2, [{
      key: "setProps",
      value: function setProps(props) {
        Object.assign(this.props, props);
      }
    }, {
      key: "render",
      value: function render() {
      }
    }, {
      key: "cleanup",
      value: function cleanup() {
      }
    }]);
    return Pass2;
  }();

  // node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js
  function _createForOfIteratorHelper27(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray28(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray28(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray28(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray28(o, minLen);
  }
  function _arrayLikeToArray28(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper20(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct21();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct21() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var LayersPass = function(_Pass) {
    _inherits(LayersPass2, _Pass);
    var _super = _createSuper20(LayersPass2);
    function LayersPass2() {
      _classCallCheck(this, LayersPass2);
      return _super.apply(this, arguments);
    }
    _createClass(LayersPass2, [{
      key: "render",
      value: function render(props) {
        var gl = this.gl;
        setParameters(gl, {
          framebuffer: props.target
        });
        return this._drawLayers(props);
      }
    }, {
      key: "_drawLayers",
      value: function _drawLayers(props) {
        var viewports = props.viewports, views = props.views, onViewportActive = props.onViewportActive, _props$clearCanvas = props.clearCanvas, clearCanvas = _props$clearCanvas === void 0 ? true : _props$clearCanvas;
        var gl = this.gl;
        if (clearCanvas) {
          clearGLCanvas(gl);
        }
        var renderStats = [];
        var _iterator = _createForOfIteratorHelper27(viewports), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var viewportOrDescriptor = _step.value;
            var viewport3 = viewportOrDescriptor.viewport || viewportOrDescriptor;
            var view = views && views[viewport3.id];
            onViewportActive(viewport3);
            var drawLayerParams = this._getDrawLayerParams(viewport3, props);
            props.view = view;
            var subViewports = viewport3.subViewports || [viewport3];
            var _iterator2 = _createForOfIteratorHelper27(subViewports), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var subViewport = _step2.value;
                props.viewport = subViewport;
                var stats = this._drawLayersInViewport(gl, props, drawLayerParams);
                renderStats.push(stats);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return renderStats;
      }
    }, {
      key: "_getDrawLayerParams",
      value: function _getDrawLayerParams(viewport3, _ref) {
        var layers = _ref.layers, _ref$pass = _ref.pass, pass = _ref$pass === void 0 ? "unknown" : _ref$pass, layerFilter = _ref.layerFilter, effects = _ref.effects, moduleParameters = _ref.moduleParameters;
        var drawLayerParams = [];
        var indexResolver = layerIndexResolver();
        for (var layerIndex = 0; layerIndex < layers.length; layerIndex++) {
          var layer = layers[layerIndex];
          var shouldDrawLayer = this._shouldDrawLayer(layer, viewport3, pass, layerFilter);
          var layerRenderIndex = indexResolver(layer, shouldDrawLayer);
          var layerParam = {
            shouldDrawLayer,
            layerRenderIndex
          };
          if (shouldDrawLayer) {
            layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
            layerParam.layerParameters = this.getLayerParameters(layer, layerIndex);
          }
          drawLayerParams[layerIndex] = layerParam;
        }
        return drawLayerParams;
      }
    }, {
      key: "_drawLayersInViewport",
      value: function _drawLayersInViewport(gl, _ref2, drawLayerParams) {
        var layers = _ref2.layers, onError = _ref2.onError, viewport3 = _ref2.viewport, view = _ref2.view;
        var glViewport = getGLViewport(gl, {
          viewport: viewport3
        });
        if (view && view.props.clear) {
          var clearOpts = view.props.clear === true ? {
            color: true,
            depth: true
          } : view.props.clear;
          withParameters(gl, {
            scissorTest: true,
            scissor: glViewport
          }, function() {
            return clear(gl, clearOpts);
          });
        }
        var renderStatus = {
          totalCount: layers.length,
          visibleCount: 0,
          compositeCount: 0,
          pickableCount: 0
        };
        setParameters(gl, {
          viewport: glViewport
        });
        for (var layerIndex = 0; layerIndex < layers.length; layerIndex++) {
          var layer = layers[layerIndex];
          var _drawLayerParams$laye = drawLayerParams[layerIndex], shouldDrawLayer = _drawLayerParams$laye.shouldDrawLayer, layerRenderIndex = _drawLayerParams$laye.layerRenderIndex, moduleParameters = _drawLayerParams$laye.moduleParameters, layerParameters = _drawLayerParams$laye.layerParameters;
          if (shouldDrawLayer && layer.props.pickable) {
            renderStatus.pickableCount++;
          }
          if (layer.isComposite) {
            renderStatus.compositeCount++;
          } else if (shouldDrawLayer) {
            renderStatus.visibleCount++;
            moduleParameters.viewport = viewport3;
            try {
              layer.drawLayer({
                moduleParameters,
                uniforms: {
                  layerIndex: layerRenderIndex
                },
                parameters: layerParameters
              });
            } catch (err) {
              if (onError) {
                onError(err, layer);
              } else {
                log_default.error("error during drawing of ".concat(layer), err)();
              }
            }
          }
        }
        return renderStatus;
      }
    }, {
      key: "shouldDrawLayer",
      value: function shouldDrawLayer(layer) {
        return true;
      }
    }, {
      key: "getModuleParameters",
      value: function getModuleParameters(layer, effects) {
        return null;
      }
    }, {
      key: "getLayerParameters",
      value: function getLayerParameters(layer, layerIndex) {
        return layer.props.parameters;
      }
    }, {
      key: "_shouldDrawLayer",
      value: function _shouldDrawLayer(layer, viewport3, pass, layerFilter) {
        var shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;
        if (shouldDrawLayer && layerFilter) {
          shouldDrawLayer = layerFilter({
            layer,
            viewport: viewport3,
            isPicking: pass.startsWith("picking"),
            renderPass: pass
          });
        }
        if (shouldDrawLayer) {
          layer.activateViewport(viewport3);
        }
        return shouldDrawLayer;
      }
    }, {
      key: "_getModuleParameters",
      value: function _getModuleParameters(layer, effects, pass, overrides) {
        var moduleParameters = Object.assign(Object.create(layer.props), {
          autoWrapLongitude: layer.wrapLongitude,
          viewport: layer.context.viewport,
          mousePosition: layer.context.mousePosition,
          pickingActive: 0,
          devicePixelRatio: cssToDeviceRatio(this.gl)
        });
        if (effects) {
          var _iterator3 = _createForOfIteratorHelper27(effects), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var effect = _step3.value;
              Object.assign(moduleParameters, effect.getModuleParameters(layer));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
        return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
      }
    }]);
    return LayersPass2;
  }(Pass);
  function layerIndexResolver() {
    var startIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var layerIndices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var resolvers = {};
    var resolveLayerIndex = function resolveLayerIndex2(layer, isDrawn) {
      var indexOverride = layer.props._offset;
      var layerId = layer.id;
      var parentId = layer.parent && layer.parent.id;
      var index;
      if (parentId && !(parentId in layerIndices)) {
        resolveLayerIndex2(layer.parent, false);
      }
      if (parentId in resolvers) {
        var resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
        index = resolver(layer, isDrawn);
        resolvers[layerId] = resolver;
      } else if (Number.isFinite(indexOverride)) {
        index = indexOverride + (layerIndices[parentId] || 0);
        resolvers[layerId] = null;
      } else {
        index = startIndex;
      }
      if (isDrawn && index >= startIndex) {
        startIndex = index + 1;
      }
      layerIndices[layerId] = index;
      return index;
    };
    return resolveLayerIndex;
  }
  function getGLViewport(gl, _ref3) {
    var viewport3 = _ref3.viewport;
    var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;
    var dimensions = viewport3;
    var pixelRatio = cssToDeviceRatio(gl);
    return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
  }
  function clearGLCanvas(gl) {
    var width = gl.drawingBufferWidth;
    var height = gl.drawingBufferHeight;
    setParameters(gl, {
      viewport: [0, 0, width, height]
    });
    gl.clear(16384 | 256);
  }

  // node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js
  function ownKeys10(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread10(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys10(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys10(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper21(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct22();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct22() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var ShadowPass = function(_LayersPass) {
    _inherits(ShadowPass2, _LayersPass);
    var _super = _createSuper21(ShadowPass2);
    function ShadowPass2(gl, props) {
      var _parameters, _attachments;
      var _this;
      _classCallCheck(this, ShadowPass2);
      _this = _super.call(this, gl, props);
      _this.shadowMap = new Texture2D(gl, {
        width: 1,
        height: 1,
        parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9729), _defineProperty(_parameters, 10240, 9729), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters)
      });
      _this.depthBuffer = new Renderbuffer(gl, {
        format: 33189,
        width: 1,
        height: 1
      });
      _this.fbo = new Framebuffer(gl, {
        id: "shadowmap",
        width: 1,
        height: 1,
        attachments: (_attachments = {}, _defineProperty(_attachments, 36064, _this.shadowMap), _defineProperty(_attachments, 36096, _this.depthBuffer), _attachments)
      });
      return _this;
    }
    _createClass(ShadowPass2, [{
      key: "render",
      value: function render(params) {
        var _this2 = this;
        var target = this.fbo;
        withParameters(this.gl, {
          depthRange: [0, 1],
          depthTest: true,
          blend: false,
          clearColor: [1, 1, 1, 1]
        }, function() {
          var viewport3 = params.viewports[0];
          var pixelRatio = cssToDeviceRatio(_this2.gl);
          var width = viewport3.width * pixelRatio;
          var height = viewport3.height * pixelRatio;
          if (width !== target.width || height !== target.height) {
            target.resize({
              width,
              height
            });
          }
          _get(_getPrototypeOf(ShadowPass2.prototype), "render", _this2).call(_this2, _objectSpread10(_objectSpread10({}, params), {}, {
            target,
            pass: "shadow"
          }));
        });
      }
    }, {
      key: "shouldDrawLayer",
      value: function shouldDrawLayer(layer) {
        return layer.props.shadowEnabled !== false;
      }
    }, {
      key: "getModuleParameters",
      value: function getModuleParameters() {
        return {
          drawToShadowMap: true
        };
      }
    }, {
      key: "delete",
      value: function _delete() {
        if (this.fbo) {
          this.fbo["delete"]();
          this.fbo = null;
        }
        if (this.shadowMap) {
          this.shadowMap["delete"]();
          this.shadowMap = null;
        }
        if (this.depthBuffer) {
          this.depthBuffer["delete"]();
          this.depthBuffer = null;
        }
      }
    }]);
    return ShadowPass2;
  }(LayersPass);

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js
  function _createForOfIteratorHelper28(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray29(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray29(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray29(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray29(o, minLen);
  }
  function _arrayLikeToArray29(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper22(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct23();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct23() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [255, 255, 255],
    intensity: 1
  };
  var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  }, {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }];
  var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
  var LightingEffect = function(_Effect) {
    _inherits(LightingEffect2, _Effect);
    var _super = _createSuper22(LightingEffect2);
    function LightingEffect2(props) {
      var _this;
      _classCallCheck(this, LightingEffect2);
      _this = _super.call(this, props);
      _this.ambientLight = null;
      _this.directionalLights = [];
      _this.pointLights = [];
      _this.shadowColor = DEFAULT_SHADOW_COLOR2;
      _this.shadowPasses = [];
      _this.shadowMaps = [];
      _this.dummyShadowMap = null;
      _this.shadow = false;
      _this.programManager = null;
      for (var key in props) {
        var lightSource = props[key];
        switch (lightSource.type) {
          case "ambient":
            _this.ambientLight = lightSource;
            break;
          case "directional":
            _this.directionalLights.push(lightSource);
            break;
          case "point":
            _this.pointLights.push(lightSource);
            break;
          default:
        }
      }
      _this._applyDefaultLights();
      _this.shadow = _this.directionalLights.some(function(light) {
        return light.shadow;
      });
      return _this;
    }
    _createClass(LightingEffect2, [{
      key: "preRender",
      value: function preRender(gl, _ref) {
        var layers = _ref.layers, layerFilter = _ref.layerFilter, viewports = _ref.viewports, onViewportActive = _ref.onViewportActive, views = _ref.views;
        if (!this.shadow)
          return;
        this.shadowMatrices = this._createLightMatrix();
        if (this.shadowPasses.length === 0) {
          this._createShadowPasses(gl);
        }
        if (!this.programManager) {
          this.programManager = ProgramManager.getDefaultProgramManager(gl);
          if (shadow_default) {
            this.programManager.addDefaultModule(shadow_default);
          }
        }
        if (!this.dummyShadowMap) {
          this.dummyShadowMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        for (var i = 0; i < this.shadowPasses.length; i++) {
          var shadowPass = this.shadowPasses[i];
          shadowPass.render({
            layers,
            layerFilter,
            viewports,
            onViewportActive,
            views,
            moduleParameters: {
              shadowLightId: i,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          });
        }
      }
    }, {
      key: "getModuleParameters",
      value: function getModuleParameters(layer) {
        var parameters = this.shadow ? {
          shadowMaps: this.shadowMaps,
          dummyShadowMap: this.dummyShadowMap,
          shadowColor: this.shadowColor,
          shadowMatrices: this.shadowMatrices
        } : {};
        parameters.lightSources = {
          ambientLight: this.ambientLight,
          directionalLights: this.directionalLights.map(function(directionalLight) {
            return directionalLight.getProjectedLight({
              layer
            });
          }),
          pointLights: this.pointLights.map(function(pointLight) {
            return pointLight.getProjectedLight({
              layer
            });
          })
        };
        return parameters;
      }
    }, {
      key: "cleanup",
      value: function cleanup() {
        var _iterator = _createForOfIteratorHelper28(this.shadowPasses), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var shadowPass = _step.value;
            shadowPass["delete"]();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.shadowPasses.length = 0;
        this.shadowMaps.length = 0;
        if (this.dummyShadowMap) {
          this.dummyShadowMap["delete"]();
          this.dummyShadowMap = null;
        }
        if (this.shadow && this.programManager) {
          this.programManager.removeDefaultModule(shadow_default);
          this.programManager = null;
        }
      }
    }, {
      key: "_createLightMatrix",
      value: function _createLightMatrix() {
        var lightMatrices = [];
        var _iterator2 = _createForOfIteratorHelper28(this.directionalLights), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var light = _step2.value;
            var viewMatrix = new Matrix4().lookAt({
              eye: new Vector3(light.direction).negate()
            });
            lightMatrices.push(viewMatrix);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return lightMatrices;
      }
    }, {
      key: "_createShadowPasses",
      value: function _createShadowPasses(gl) {
        for (var i = 0; i < this.directionalLights.length; i++) {
          var shadowPass = new ShadowPass(gl);
          this.shadowPasses[i] = shadowPass;
          this.shadowMaps[i] = shadowPass.shadowMap;
        }
      }
    }, {
      key: "_applyDefaultLights",
      value: function _applyDefaultLights() {
        var ambientLight = this.ambientLight, pointLights = this.pointLights, directionalLights = this.directionalLights;
        if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
          this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
          this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
        }
      }
    }]);
    return LightingEffect2;
  }(Effect);

  // node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js
  var TypedArrayManager = function() {
    function TypedArrayManager2(props) {
      _classCallCheck(this, TypedArrayManager2);
      this._pool = [];
      this.props = {
        overAlloc: 2,
        poolSize: 100
      };
      this.setProps(props);
    }
    _createClass(TypedArrayManager2, [{
      key: "setProps",
      value: function setProps(props) {
        Object.assign(this.props, props);
      }
    }, {
      key: "allocate",
      value: function allocate(typedArray, count3, _ref) {
        var _ref$size = _ref.size, size = _ref$size === void 0 ? 1 : _ref$size, type = _ref.type, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 0 : _ref$padding, _ref$copy = _ref.copy, copy3 = _ref$copy === void 0 ? false : _ref$copy, _ref$initialize = _ref.initialize, initialize = _ref$initialize === void 0 ? false : _ref$initialize, maxCount = _ref.maxCount;
        var Type = type || typedArray && typedArray.constructor || Float32Array;
        var newSize = count3 * size + padding;
        if (ArrayBuffer.isView(typedArray)) {
          if (newSize <= typedArray.length) {
            return typedArray;
          }
          if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
            return new Type(typedArray.buffer, 0, newSize);
          }
        }
        var maxSize;
        if (maxCount) {
          maxSize = maxCount * size + padding;
        }
        var newArray = this._allocate(Type, newSize, initialize, maxSize);
        if (typedArray && copy3) {
          newArray.set(typedArray);
        } else if (!initialize) {
          newArray.fill(0, 0, 4);
        }
        this._release(typedArray);
        return newArray;
      }
    }, {
      key: "release",
      value: function release2(typedArray) {
        this._release(typedArray);
      }
    }, {
      key: "_allocate",
      value: function _allocate(Type, size, initialize, maxSize) {
        var sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);
        if (sizeToAllocate > maxSize) {
          sizeToAllocate = maxSize;
        }
        var pool = this._pool;
        var byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
        var i = pool.findIndex(function(b) {
          return b.byteLength >= byteLength;
        });
        if (i >= 0) {
          var array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
          if (initialize) {
            array.fill(0);
          }
          return array;
        }
        return new Type(sizeToAllocate);
      }
    }, {
      key: "_release",
      value: function _release(typedArray) {
        if (!ArrayBuffer.isView(typedArray)) {
          return;
        }
        var pool = this._pool;
        var buffer = typedArray.buffer;
        var byteLength = buffer.byteLength;
        var i = pool.findIndex(function(b) {
          return b.byteLength >= byteLength;
        });
        if (i < 0) {
          pool.push(buffer);
        } else if (i > 0 || pool.length < this.props.poolSize) {
          pool.splice(i, 0, buffer);
        }
        if (pool.length > this.props.poolSize) {
          pool.shift();
        }
      }
    }]);
    return TypedArrayManager2;
  }();
  var typed_array_manager_default = new TypedArrayManager();

  // node_modules/@deck.gl/core/dist/esm/utils/math-utils.js
  function createMat42() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function mod2(value17, divisor) {
    var modulus = value17 % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function getCameraPosition(viewMatrixInverse) {
    return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
  }
  function getFrustumPlanes(viewProjectionMatrix) {
    var planes = {};
    planes.left = getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]);
    planes.right = getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]);
    planes.bottom = getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]);
    planes.top = getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]);
    planes.near = getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]);
    planes.far = getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14]);
    return planes;
  }
  var scratchVector = new Vector3();
  function getFrustumPlane(a, b, c, d) {
    scratchVector.set(a, b, c);
    var L = scratchVector.len();
    return {
      distance: d / L,
      normal: new Vector3(-a / L, -b / L, -c / L)
    };
  }
  function fp64LowPart(x) {
    return x - Math.fround(x);
  }
  var scratchArray;
  function toDoublePrecisionArray(typedArray, _ref) {
    var _ref$size = _ref.size, size = _ref$size === void 0 ? 1 : _ref$size, _ref$startIndex = _ref.startIndex, startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex, endIndex = _ref.endIndex;
    if (!Number.isFinite(endIndex)) {
      endIndex = typedArray.length;
    }
    var count3 = (endIndex - startIndex) / size;
    scratchArray = typed_array_manager_default.allocate(scratchArray, count3, {
      type: Float32Array,
      size: size * 2
    });
    var sourceIndex = startIndex;
    var targetIndex = 0;
    while (sourceIndex < endIndex) {
      for (var j = 0; j < size; j++) {
        var value17 = typedArray[sourceIndex++];
        scratchArray[targetIndex + j] = value17;
        scratchArray[targetIndex + j + size] = fp64LowPart(value17);
      }
      targetIndex += size * 2;
    }
    return scratchArray.subarray(0, count3 * size * 2);
  }

  // node_modules/@deck.gl/core/dist/esm/viewports/viewport.js
  var DEGREES_TO_RADIANS4 = Math.PI / 180;
  var IDENTITY3 = createMat42();
  var ZERO_VECTOR2 = [0, 0, 0];
  var DEFAULT_ZOOM = 0;
  var DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [1, 1, 1],
    metersPerUnit: [1, 1, 1]
  };
  var Viewport = function() {
    function Viewport2() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Viewport2);
      var _opts$id = opts.id, id = _opts$id === void 0 ? null : _opts$id, _opts$x = opts.x, x = _opts$x === void 0 ? 0 : _opts$x, _opts$y = opts.y, y = _opts$y === void 0 ? 0 : _opts$y, _opts$width = opts.width, width = _opts$width === void 0 ? 1 : _opts$width, _opts$height = opts.height, height = _opts$height === void 0 ? 1 : _opts$height;
      this.id = id || this.constructor.displayName || "viewport";
      this.x = x;
      this.y = y;
      this.width = width || 1;
      this.height = height || 1;
      this._frustumPlanes = {};
      this._initViewMatrix(opts);
      this._initProjectionMatrix(opts);
      this._initPixelMatrices();
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      this.projectFlat = this.projectFlat.bind(this);
      this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    _createClass(Viewport2, [{
      key: "equals",
      value: function equals5(viewport3) {
        if (!(viewport3 instanceof Viewport2)) {
          return false;
        }
        if (this === viewport3) {
          return true;
        }
        return viewport3.width === this.width && viewport3.height === this.height && viewport3.scale === this.scale && equals(viewport3.projectionMatrix, this.projectionMatrix) && equals(viewport3.viewMatrix, this.viewMatrix);
      }
    }, {
      key: "project",
      value: function project2(xyz) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$topLeft = _ref.topLeft, topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;
        var worldPosition = this.projectPosition(xyz);
        var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
        var _coord = _slicedToArray(coord, 2), x = _coord[0], y = _coord[1];
        var y2 = topLeft ? y : this.height - y;
        return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
      }
    }, {
      key: "unproject",
      value: function unproject(xyz) {
        var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$topLeft = _ref2.topLeft, topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft, targetZ = _ref2.targetZ;
        var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
        var y2 = topLeft ? y : this.height - y;
        var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
        var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
        var _this$unprojectPositi = this.unprojectPosition(coord), _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3), X = _this$unprojectPositi2[0], Y = _this$unprojectPositi2[1], Z = _this$unprojectPositi2[2];
        if (Number.isFinite(z)) {
          return [X, Y, Z];
        }
        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
      }
    }, {
      key: "projectPosition",
      value: function projectPosition2(xyz) {
        var _this$projectFlat = this.projectFlat(xyz), _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2), X = _this$projectFlat2[0], Y = _this$projectFlat2[1];
        var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
        return [X, Y, Z];
      }
    }, {
      key: "unprojectPosition",
      value: function unprojectPosition(xyz) {
        var _this$unprojectFlat = this.unprojectFlat(xyz), _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2), X = _this$unprojectFlat2[0], Y = _this$unprojectFlat2[1];
        var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
        return [X, Y, Z];
      }
    }, {
      key: "projectFlat",
      value: function projectFlat(xyz) {
        if (this.isGeospatial) {
          return lngLatToWorld(xyz);
        }
        return xyz;
      }
    }, {
      key: "unprojectFlat",
      value: function unprojectFlat(xyz) {
        if (this.isGeospatial) {
          return worldToLngLat(xyz);
        }
        return xyz;
      }
    }, {
      key: "getBounds",
      value: function getBounds2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var unprojectOption = {
          targetZ: options.z || 0
        };
        var topLeft = this.unproject([0, 0], unprojectOption);
        var topRight = this.unproject([this.width, 0], unprojectOption);
        var bottomLeft = this.unproject([0, this.height], unprojectOption);
        var bottomRight = this.unproject([this.width, this.height], unprojectOption);
        return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
      }
    }, {
      key: "getDistanceScales",
      value: function getDistanceScales3() {
        var coordinateOrigin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        if (coordinateOrigin) {
          return getDistanceScales({
            longitude: coordinateOrigin[0],
            latitude: coordinateOrigin[1],
            highPrecision: true
          });
        }
        return this.distanceScales;
      }
    }, {
      key: "containsPixel",
      value: function containsPixel(_ref3) {
        var x = _ref3.x, y = _ref3.y, _ref3$width = _ref3.width, width = _ref3$width === void 0 ? 1 : _ref3$width, _ref3$height = _ref3.height, height = _ref3$height === void 0 ? 1 : _ref3$height;
        return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
      }
    }, {
      key: "getFrustumPlanes",
      value: function getFrustumPlanes2() {
        if (this._frustumPlanes.near) {
          return this._frustumPlanes;
        }
        Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
        return this._frustumPlanes;
      }
    }, {
      key: "getCameraPosition",
      value: function getCameraPosition2() {
        return this.cameraPosition;
      }
    }, {
      key: "getCameraDirection",
      value: function getCameraDirection() {
        return this.cameraDirection;
      }
    }, {
      key: "getCameraUp",
      value: function getCameraUp() {
        return this.cameraUp;
      }
    }, {
      key: "_createProjectionMatrix",
      value: function _createProjectionMatrix(_ref4) {
        var orthographic = _ref4.orthographic, fovyRadians = _ref4.fovyRadians, aspect = _ref4.aspect, focalDistance = _ref4.focalDistance, near = _ref4.near, far = _ref4.far;
        return orthographic ? new Matrix4().orthographic({
          fovy: fovyRadians,
          aspect,
          focalDistance,
          near,
          far
        }) : new Matrix4().perspective({
          fovy: fovyRadians,
          aspect,
          near,
          far
        });
      }
    }, {
      key: "_initViewMatrix",
      value: function _initViewMatrix(opts) {
        var _opts$viewMatrix = opts.viewMatrix, viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY3 : _opts$viewMatrix, _opts$longitude = opts.longitude, longitude = _opts$longitude === void 0 ? null : _opts$longitude, _opts$latitude = opts.latitude, latitude = _opts$latitude === void 0 ? null : _opts$latitude, _opts$zoom = opts.zoom, zoom = _opts$zoom === void 0 ? null : _opts$zoom, _opts$position = opts.position, position = _opts$position === void 0 ? null : _opts$position, _opts$modelMatrix = opts.modelMatrix, modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix, _opts$focalDistance = opts.focalDistance, focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance, _opts$distanceScales = opts.distanceScales, distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales;
        this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
        this.zoom = zoom;
        if (!Number.isFinite(this.zoom)) {
          this.zoom = this.isGeospatial ? getMeterZoom({
            latitude
          }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
        }
        var scale5 = Math.pow(2, this.zoom);
        this.scale = scale5;
        this.distanceScales = this.isGeospatial ? getDistanceScales({
          latitude,
          longitude
        }) : distanceScales || DEFAULT_DISTANCE_SCALES;
        this.focalDistance = focalDistance;
        this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);
        this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);
        this.position = ZERO_VECTOR2;
        this.meterOffset = ZERO_VECTOR2;
        if (position) {
          this.position = position;
          this.modelMatrix = modelMatrix;
          this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
        }
        if (this.isGeospatial) {
          this.longitude = longitude;
          this.latitude = latitude;
          this.center = this._getCenterInWorld({
            longitude,
            latitude
          });
        } else {
          this.center = position ? this.projectPosition(position) : [0, 0, 0];
        }
        this.viewMatrixUncentered = viewMatrix;
        this.viewMatrix = new Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new Vector3(this.center || ZERO_VECTOR2).negate());
      }
    }, {
      key: "_getCenterInWorld",
      value: function _getCenterInWorld(_ref5) {
        var longitude = _ref5.longitude, latitude = _ref5.latitude;
        var meterOffset = this.meterOffset, distanceScales = this.distanceScales;
        var center = new Vector3(this.projectPosition([longitude, latitude, 0]));
        if (meterOffset) {
          var commonPosition = new Vector3(meterOffset).scale(distanceScales.unitsPerMeter);
          center.add(commonPosition);
        }
        return center;
      }
    }, {
      key: "_initProjectionMatrix",
      value: function _initProjectionMatrix(opts) {
        var _opts$projectionMatri = opts.projectionMatrix, projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri, _opts$orthographic = opts.orthographic, orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic, fovyRadians = opts.fovyRadians, _opts$fovy = opts.fovy, fovy = _opts$fovy === void 0 ? 75 : _opts$fovy, _opts$near = opts.near, near = _opts$near === void 0 ? 0.1 : _opts$near, _opts$far = opts.far, far = _opts$far === void 0 ? 1e3 : _opts$far, _opts$focalDistance2 = opts.focalDistance, focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2;
        this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({
          orthographic,
          fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
          aspect: this.width / this.height,
          focalDistance,
          near,
          far
        });
      }
    }, {
      key: "_initPixelMatrices",
      value: function _initPixelMatrices() {
        var vpm = createMat42();
        multiply3(vpm, vpm, this.projectionMatrix);
        multiply3(vpm, vpm, this.viewMatrix);
        this.viewProjectionMatrix = vpm;
        this.viewMatrixInverse = invert2([], this.viewMatrix) || this.viewMatrix;
        this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
        var viewportMatrix = createMat42();
        var pixelProjectionMatrix = createMat42();
        scale2(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
        translate2(viewportMatrix, viewportMatrix, [1, -1, 0]);
        multiply3(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
        this.pixelProjectionMatrix = pixelProjectionMatrix;
        this.viewportMatrix = viewportMatrix;
        this.pixelUnprojectionMatrix = invert2(createMat42(), this.pixelProjectionMatrix);
        if (!this.pixelUnprojectionMatrix) {
          log_default.warn("Pixel project matrix not invertible")();
        }
      }
    }, {
      key: "metersPerPixel",
      get: function get2() {
        return this.distanceScales.metersPerUnit[2] / this.scale;
      }
    }, {
      key: "projectionMode",
      get: function get2() {
        if (this.isGeospatial) {
          return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
        }
        return PROJECTION_MODE.IDENTITY;
      }
    }]);
    return Viewport2;
  }();
  Viewport.displayName = "Viewport";

  // node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js
  function ownKeys11(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread11(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys11(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys11(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper23(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct24();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct24() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var WebMercatorViewport2 = function(_Viewport) {
    _inherits(WebMercatorViewport3, _Viewport);
    var _super = _createSuper23(WebMercatorViewport3);
    function WebMercatorViewport3() {
      var _this;
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, WebMercatorViewport3);
      var _opts$latitude = opts.latitude, latitude = _opts$latitude === void 0 ? 0 : _opts$latitude, _opts$longitude = opts.longitude, longitude = _opts$longitude === void 0 ? 0 : _opts$longitude, _opts$zoom = opts.zoom, zoom = _opts$zoom === void 0 ? 11 : _opts$zoom, _opts$pitch = opts.pitch, pitch = _opts$pitch === void 0 ? 0 : _opts$pitch, _opts$bearing = opts.bearing, bearing = _opts$bearing === void 0 ? 0 : _opts$bearing, _opts$nearZMultiplier = opts.nearZMultiplier, nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier, _opts$farZMultiplier = opts.farZMultiplier, farZMultiplier = _opts$farZMultiplier === void 0 ? 1.01 : _opts$farZMultiplier, _opts$orthographic = opts.orthographic, orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic, _opts$repeat = opts.repeat, repeat = _opts$repeat === void 0 ? false : _opts$repeat, _opts$worldOffset = opts.worldOffset, worldOffset = _opts$worldOffset === void 0 ? 0 : _opts$worldOffset;
      var width = opts.width, height = opts.height, _opts$altitude = opts.altitude, altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;
      var scale5 = Math.pow(2, zoom);
      width = width || 1;
      height = height || 1;
      altitude = Math.max(0.75, altitude);
      var _getProjectionParamet = getProjectionParameters({
        width,
        height,
        pitch,
        altitude,
        nearZMultiplier,
        farZMultiplier
      }), fov = _getProjectionParamet.fov, aspect = _getProjectionParamet.aspect, focalDistance = _getProjectionParamet.focalDistance, near = _getProjectionParamet.near, far = _getProjectionParamet.far;
      var viewMatrixUncentered = getViewMatrix({
        height,
        pitch,
        bearing,
        scale: scale5,
        altitude
      });
      if (worldOffset) {
        var viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
        viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
      }
      var viewportOpts = Object.assign({}, opts, {
        width,
        height,
        viewMatrix: viewMatrixUncentered,
        longitude,
        latitude,
        zoom,
        orthographic,
        fovyRadians: fov,
        aspect,
        focalDistance: orthographic ? focalDistance : 1,
        near,
        far
      });
      _this = _super.call(this, viewportOpts);
      _this.latitude = latitude;
      _this.longitude = longitude;
      _this.zoom = zoom;
      _this.pitch = pitch;
      _this.bearing = bearing;
      _this.altitude = altitude;
      _this.orthographic = orthographic;
      _this._subViewports = repeat ? [] : null;
      Object.freeze(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(WebMercatorViewport3, [{
      key: "addMetersToLngLat",
      value: function addMetersToLngLat2(lngLatZ, xyz) {
        return addMetersToLngLat(lngLatZ, xyz);
      }
    }, {
      key: "getMapCenterByLngLatPosition",
      value: function getMapCenterByLngLatPosition(_ref) {
        var lngLat = _ref.lngLat, pos = _ref.pos;
        var fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
        var toLocation = this.projectFlat(lngLat);
        var translate3 = add([], toLocation, negate([], fromLocation));
        var newCenter = add([], this.center, translate3);
        return this.unprojectFlat(newCenter);
      }
    }, {
      key: "getBounds",
      value: function getBounds2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var corners = getBounds(this, options.z || 0);
        return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
      }
    }, {
      key: "fitBounds",
      value: function fitBounds2(bounds) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var width = this.width, height = this.height;
        var _fitBounds2 = fitBounds(Object.assign({
          width,
          height,
          bounds
        }, options)), longitude = _fitBounds2.longitude, latitude = _fitBounds2.latitude, zoom = _fitBounds2.zoom;
        return new WebMercatorViewport3({
          width,
          height,
          longitude,
          latitude,
          zoom
        });
      }
    }, {
      key: "subViewports",
      get: function get2() {
        if (this._subViewports && !this._subViewports.length) {
          var bounds = this.getBounds();
          var minOffset = Math.floor((bounds[0] + 180) / 360);
          var maxOffset = Math.ceil((bounds[2] - 180) / 360);
          for (var x = minOffset; x <= maxOffset; x++) {
            var offsetViewport = x ? new WebMercatorViewport3(_objectSpread11(_objectSpread11({}, this), {}, {
              worldOffset: x
            })) : this;
            this._subViewports.push(offsetViewport);
          }
        }
        return this._subViewports;
      }
    }]);
    return WebMercatorViewport3;
  }(Viewport);
  WebMercatorViewport2.displayName = "WebMercatorViewport";

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js
  function lngLatZToWorldPosition(lngLatZ, viewport3) {
    var offsetMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var p = viewport3.projectPosition(lngLatZ);
    if (offsetMode && viewport3 instanceof WebMercatorViewport2) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3), longitude = _lngLatZ[0], latitude = _lngLatZ[1], _lngLatZ$ = _lngLatZ[2], z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;
      var distanceScales = viewport3.getDistanceScales([longitude, latitude]);
      p[2] = z * distanceScales.unitsPerMeter[2];
    }
    return p;
  }
  function normalizeParameters(opts) {
    var normalizedParams = Object.assign({}, opts);
    var coordinateSystem = opts.coordinateSystem;
    var viewport3 = opts.viewport, coordinateOrigin = opts.coordinateOrigin, fromCoordinateSystem = opts.fromCoordinateSystem, fromCoordinateOrigin = opts.fromCoordinateOrigin;
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport3.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    if (fromCoordinateSystem === void 0) {
      normalizedParams.fromCoordinateSystem = coordinateSystem;
    }
    if (fromCoordinateOrigin === void 0) {
      normalizedParams.fromCoordinateOrigin = coordinateOrigin;
    }
    normalizedParams.coordinateSystem = coordinateSystem;
    return normalizedParams;
  }
  function getWorldPosition(position, _ref) {
    var viewport3 = _ref.viewport, modelMatrix = _ref.modelMatrix, coordinateSystem = _ref.coordinateSystem, coordinateOrigin = _ref.coordinateOrigin, offsetMode = _ref.offsetMode;
    var _position = _slicedToArray(position, 3), x = _position[0], y = _position[1], _position$ = _position[2], z = _position$ === void 0 ? 0 : _position$;
    if (modelMatrix) {
      var _vec4$transformMat = transformMat43([], [x, y, z, 1], modelMatrix);
      var _vec4$transformMat2 = _slicedToArray(_vec4$transformMat, 3);
      x = _vec4$transformMat2[0];
      y = _vec4$transformMat2[1];
      z = _vec4$transformMat2[2];
    }
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.LNGLAT:
        return lngLatZToWorldPosition([x, y, z], viewport3, offsetMode);
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport3, offsetMode);
      case COORDINATE_SYSTEM.METER_OFFSETS:
        return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport3, offsetMode);
      case COORDINATE_SYSTEM.CARTESIAN:
      default:
        return viewport3.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport3.projectPosition([x, y, z]);
    }
  }
  function projectPosition(position, params) {
    var _normalizeParameters = normalizeParameters(params), viewport3 = _normalizeParameters.viewport, coordinateSystem = _normalizeParameters.coordinateSystem, coordinateOrigin = _normalizeParameters.coordinateOrigin, modelMatrix = _normalizeParameters.modelMatrix, fromCoordinateSystem = _normalizeParameters.fromCoordinateSystem, fromCoordinateOrigin = _normalizeParameters.fromCoordinateOrigin;
    var _getOffsetOrigin = getOffsetOrigin(viewport3, coordinateSystem, coordinateOrigin), geospatialOrigin = _getOffsetOrigin.geospatialOrigin, shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin, offsetMode = _getOffsetOrigin.offsetMode;
    var worldPosition = getWorldPosition(position, {
      viewport: viewport3,
      modelMatrix,
      coordinateSystem: fromCoordinateSystem,
      coordinateOrigin: fromCoordinateOrigin,
      offsetMode
    });
    if (offsetMode) {
      var positionCommonSpace = viewport3.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      sub(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js
  function ownKeys12(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread12(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys12(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys12(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var ShaderAttribute = function() {
    function ShaderAttribute2(dataColumn, opts) {
      _classCallCheck(this, ShaderAttribute2);
      this.opts = opts;
      this.source = dataColumn;
    }
    _createClass(ShaderAttribute2, [{
      key: "getValue",
      value: function getValue2() {
        var buffer = this.source.getBuffer();
        var accessor = this.getAccessor();
        if (buffer) {
          return [buffer, accessor];
        }
        var value17 = this.source.value;
        var size = accessor.size;
        var constantValue = value17;
        if (value17 && value17.length !== size) {
          constantValue = new Float32Array(size);
          var index = accessor.elementOffset || 0;
          for (var i = 0; i < size; ++i) {
            constantValue[i] = value17[index + i];
          }
        }
        return constantValue;
      }
    }, {
      key: "getAccessor",
      value: function getAccessor() {
        return _objectSpread12(_objectSpread12({}, this.source.getAccessor()), this.opts);
      }
    }, {
      key: "value",
      get: function get2() {
        return this.source.value;
      }
    }]);
    return ShaderAttribute2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js
  function glArrayFromType(glType) {
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5130:
        return Float64Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return Uint8ClampedArray;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Unknown GL type");
    }
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js
  function ownKeys13(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread13(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys13(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys13(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
  }
  function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) {
      log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    }
    var stride = getStride(baseAccessor);
    var vertexOffset = "vertexOffset" in shaderAttributeOptions ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    var elementOffset = shaderAttributeOptions.elementOffset || 0;
    var offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return _objectSpread13(_objectSpread13({}, shaderAttributeOptions), {}, {
      offset,
      stride
    });
  }
  function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    var resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
      high: resolvedOptions,
      low: _objectSpread13(_objectSpread13({}, resolvedOptions), {}, {
        offset: resolvedOptions.offset + baseAccessor.size * 4
      })
    };
  }
  var DataColumn = function() {
    function DataColumn2(gl, opts) {
      _classCallCheck(this, DataColumn2);
      this.gl = gl;
      this.id = opts.id;
      this.size = opts.size;
      var logicalType = opts.logicalType || opts.type;
      var doublePrecision = logicalType === 5130;
      var defaultValue = opts.defaultValue;
      defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
      opts.defaultValue = defaultValue;
      var bufferType = logicalType;
      if (doublePrecision) {
        bufferType = 5126;
      } else if (!bufferType && opts.isIndexed) {
        bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
      } else if (!bufferType) {
        bufferType = 5126;
      }
      opts.logicalType = logicalType;
      opts.type = bufferType;
      var defaultType = glArrayFromType(logicalType || bufferType || 5126);
      this.shaderAttributes = {};
      this.doublePrecision = doublePrecision;
      if (doublePrecision && opts.fp64 === false) {
        defaultType = Float32Array;
      }
      opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;
      this.defaultType = defaultType;
      this.value = null;
      this.settings = opts;
      this.state = {
        externalBuffer: null,
        bufferAccessor: opts,
        allocatedValue: null,
        constant: false
      };
      this._buffer = null;
      this.setData(opts);
    }
    _createClass(DataColumn2, [{
      key: "delete",
      value: function _delete() {
        if (this._buffer) {
          this._buffer["delete"]();
          this._buffer = null;
        }
        typed_array_manager_default.release(this.state.allocatedValue);
      }
    }, {
      key: "getShaderAttributes",
      value: function getShaderAttributes(id, options) {
        if (this.doublePrecision) {
          var shaderAttributes = {};
          var isBuffer64Bit = this.value instanceof Float64Array;
          var doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
          shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
          shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
          return shaderAttributes;
        }
        if (options) {
          var shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
          return _defineProperty({}, id, new ShaderAttribute(this, shaderAttributeDef));
        }
        return _defineProperty({}, id, this);
      }
    }, {
      key: "getBuffer",
      value: function getBuffer() {
        if (this.state.constant) {
          return null;
        }
        return this.state.externalBuffer || this._buffer;
      }
    }, {
      key: "getValue",
      value: function getValue2() {
        if (this.state.constant) {
          return this.value;
        }
        return [this.getBuffer(), this.getAccessor()];
      }
    }, {
      key: "getAccessor",
      value: function getAccessor() {
        return this.state.bufferAccessor;
      }
    }, {
      key: "setData",
      value: function setData(opts) {
        var state = this.state;
        if (ArrayBuffer.isView(opts)) {
          opts = {
            value: opts
          };
        } else if (opts instanceof Buffer2) {
          opts = {
            buffer: opts
          };
        }
        var accessor = _objectSpread13(_objectSpread13({}, this.settings), opts);
        state.bufferAccessor = accessor;
        if (opts.constant) {
          var value17 = opts.value;
          value17 = this._normalizeValue(value17, [], 0);
          if (this.settings.normalized) {
            value17 = this._normalizeConstant(value17);
          }
          var hasChanged = !state.constant || !this._areValuesEqual(value17, this.value);
          if (!hasChanged) {
            return false;
          }
          state.externalBuffer = null;
          state.constant = true;
          this.value = value17;
        } else if (opts.buffer) {
          var buffer = opts.buffer;
          state.externalBuffer = buffer;
          state.constant = false;
          this.value = opts.value;
          var isBuffer64Bit = opts.value instanceof Float64Array;
          accessor.type = opts.type || buffer.accessor.type;
          accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
          accessor.stride = getStride(accessor);
        } else if (opts.value) {
          this._checkExternalBuffer(opts);
          var _value = opts.value;
          state.externalBuffer = null;
          state.constant = false;
          this.value = _value;
          accessor.bytesPerElement = _value.BYTES_PER_ELEMENT;
          accessor.stride = getStride(accessor);
          var _buffer = this.buffer, byteOffset = this.byteOffset;
          if (this.doublePrecision && _value instanceof Float64Array) {
            _value = toDoublePrecisionArray(_value, accessor);
          }
          var requiredBufferSize = _value.byteLength + byteOffset + accessor.stride * 2;
          if (_buffer.byteLength < requiredBufferSize) {
            _buffer.reallocate(requiredBufferSize);
          }
          _buffer.setAccessor(null);
          _buffer.subData({
            data: _value,
            offset: byteOffset
          });
          accessor.type = opts.type || _buffer.accessor.type;
        }
        return true;
      }
    }, {
      key: "updateSubBuffer",
      value: function updateSubBuffer() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var value17 = this.value;
        var _opts$startOffset = opts.startOffset, startOffset = _opts$startOffset === void 0 ? 0 : _opts$startOffset, endOffset = opts.endOffset;
        this.buffer.subData({
          data: this.doublePrecision && value17 instanceof Float64Array ? toDoublePrecisionArray(value17, {
            size: this.size,
            startIndex: startOffset,
            endIndex: endOffset
          }) : value17.subarray(startOffset, endOffset),
          offset: startOffset * value17.BYTES_PER_ELEMENT + this.byteOffset
        });
      }
    }, {
      key: "allocate",
      value: function allocate(_ref3) {
        var numInstances = _ref3.numInstances, _ref3$copy = _ref3.copy, copy3 = _ref3$copy === void 0 ? false : _ref3$copy;
        var state = this.state;
        var oldValue = state.allocatedValue;
        var value17 = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
          size: this.size,
          type: this.defaultType,
          copy: copy3
        });
        this.value = value17;
        var buffer = this.buffer, byteOffset = this.byteOffset;
        if (buffer.byteLength < value17.byteLength + byteOffset) {
          buffer.reallocate(value17.byteLength + byteOffset);
          if (copy3 && oldValue) {
            buffer.subData({
              data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
              offset: byteOffset
            });
          }
        }
        state.allocatedValue = value17;
        state.constant = false;
        state.externalBuffer = null;
        state.bufferAccessor = this.settings;
        return true;
      }
    }, {
      key: "_checkExternalBuffer",
      value: function _checkExternalBuffer(opts) {
        var value17 = opts.value;
        if (!opts.constant && value17) {
          var ArrayType = this.defaultType;
          var illegalArrayType = false;
          if (this.doublePrecision) {
            illegalArrayType = value17.BYTES_PER_ELEMENT < 4;
          }
          if (illegalArrayType) {
            throw new Error("Attribute ".concat(this.id, " does not support ").concat(value17.constructor.name));
          }
          if (!(value17 instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
            log_default.warn("Attribute ".concat(this.id, " is normalized"))();
          }
        }
      }
    }, {
      key: "_normalizeConstant",
      value: function _normalizeConstant(value17) {
        switch (this.settings.type) {
          case 5120:
            return new Float32Array(value17).map(function(x) {
              return (x + 128) / 255 * 2 - 1;
            });
          case 5122:
            return new Float32Array(value17).map(function(x) {
              return (x + 32768) / 65535 * 2 - 1;
            });
          case 5121:
            return new Float32Array(value17).map(function(x) {
              return x / 255;
            });
          case 5123:
            return new Float32Array(value17).map(function(x) {
              return x / 65535;
            });
          default:
            return value17;
        }
      }
    }, {
      key: "_normalizeValue",
      value: function _normalizeValue(value17, out, start2) {
        var _this$settings = this.settings, defaultValue = _this$settings.defaultValue, size = _this$settings.size;
        if (Number.isFinite(value17)) {
          out[start2] = value17;
          return out;
        }
        if (!value17) {
          out[start2] = defaultValue[0];
          return out;
        }
        switch (size) {
          case 4:
            out[start2 + 3] = Number.isFinite(value17[3]) ? value17[3] : defaultValue[3];
          case 3:
            out[start2 + 2] = Number.isFinite(value17[2]) ? value17[2] : defaultValue[2];
          case 2:
            out[start2 + 1] = Number.isFinite(value17[1]) ? value17[1] : defaultValue[1];
          case 1:
            out[start2 + 0] = Number.isFinite(value17[0]) ? value17[0] : defaultValue[0];
            break;
          default:
            var i = size;
            while (--i >= 0) {
              out[start2 + i] = Number.isFinite(value17[i]) ? value17[i] : defaultValue[i];
            }
        }
        return out;
      }
    }, {
      key: "_areValuesEqual",
      value: function _areValuesEqual(value1, value22) {
        if (!value1 || !value22) {
          return false;
        }
        var size = this.size;
        for (var i = 0; i < size; i++) {
          if (value1[i] !== value22[i]) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "buffer",
      get: function get2() {
        if (!this._buffer) {
          var _this$settings2 = this.settings, isIndexed = _this$settings2.isIndexed, type = _this$settings2.type;
          this._buffer = new Buffer2(this.gl, {
            id: this.id,
            target: isIndexed ? 34963 : 34962,
            accessor: {
              type
            }
          });
        }
        return this._buffer;
      }
    }, {
      key: "byteOffset",
      get: function get2() {
        var accessor = this.getAccessor();
        if (accessor.vertexOffset) {
          return accessor.vertexOffset * getStride(accessor);
        }
        return 0;
      }
    }]);
    return DataColumn2;
  }();

  // node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js
  var EMPTY_ARRAY = [];
  var placeholderArray = [];
  function createIterable(data) {
    var startRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var endRow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    var iterable = EMPTY_ARRAY;
    var objectInfo = {
      index: -1,
      data,
      target: []
    };
    if (!data) {
      iterable = EMPTY_ARRAY;
    } else if (typeof data[Symbol.iterator] === "function") {
      iterable = data;
    } else if (data.length > 0) {
      placeholderArray.length = data.length;
      iterable = placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
      iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
      objectInfo.index = startRow - 1;
    }
    return {
      iterable,
      objectInfo
    };
  }
  function isAsyncIterable3(data) {
    return data && data[Symbol.asyncIterator];
  }
  function getAccessorFromBuffer(typedArray, _ref) {
    var size = _ref.size, stride = _ref.stride, offset = _ref.offset, startIndices = _ref.startIndices, nested = _ref.nested;
    var bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    var elementStride = stride ? stride / bytesPerElement : size;
    var elementOffset = offset ? offset / bytesPerElement : 0;
    var vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return function(_, _ref2) {
      var index = _ref2.index, target = _ref2.target;
      if (!startIndices) {
        var sourceIndex = index * elementStride + elementOffset;
        for (var j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        return target;
      }
      var startIndex = startIndices[index];
      var endIndex = startIndices[index + 1] || vertexCount;
      var result;
      if (nested) {
        result = new Array(endIndex - startIndex);
        for (var i = startIndex; i < endIndex; i++) {
          var _sourceIndex = i * elementStride + elementOffset;
          target = new Array(size);
          for (var _j = 0; _j < size; _j++) {
            target[_j] = typedArray[_sourceIndex + _j];
          }
          result[i - startIndex] = target;
        }
      } else if (elementStride === size) {
        result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
      } else {
        result = new typedArray.constructor((endIndex - startIndex) * size);
        var targetIndex = 0;
        for (var _i = startIndex; _i < endIndex; _i++) {
          var _sourceIndex2 = _i * elementStride + elementOffset;
          for (var _j2 = 0; _j2 < size; _j2++) {
            result[targetIndex++] = typedArray[_sourceIndex2 + _j2];
          }
        }
      }
      return result;
    };
  }

  // node_modules/@deck.gl/core/dist/esm/utils/flatten.js
  function flatten(array) {
    var filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
      return true;
    };
    if (!Array.isArray(array)) {
      return filter(array) ? [array] : [];
    }
    return flattenArray(array, filter, []);
  }
  function flattenArray(array, filter, result) {
    var index = -1;
    while (++index < array.length) {
      var value17 = array[index];
      if (Array.isArray(value17)) {
        flattenArray(value17, filter, result);
      } else if (filter(value17)) {
        result.push(value17);
      }
    }
    return result;
  }
  function fillArray2(_ref) {
    var target = _ref.target, source = _ref.source, _ref$start = _ref.start, start2 = _ref$start === void 0 ? 0 : _ref$start, _ref$count = _ref.count, count3 = _ref$count === void 0 ? 1 : _ref$count;
    var length4 = source.length;
    var total = count3 * length4;
    var copied = 0;
    for (var i = start2; copied < length4; copied++) {
      target[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start2 + copied, start2, start2 + copied);
        copied *= 2;
      } else {
        target.copyWithin(start2 + copied, start2, start2 + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/range.js
  var EMPTY = [];
  var FULL = [[0, Infinity]];
  function add5(rangeList, range2) {
    if (rangeList === FULL) {
      return rangeList;
    }
    if (range2[0] < 0) {
      range2[0] = 0;
    }
    if (range2[0] >= range2[1]) {
      return rangeList;
    }
    var newRangeList = [];
    var len2 = rangeList.length;
    var insertPosition = 0;
    for (var i = 0; i < len2; i++) {
      var range0 = rangeList[i];
      if (range0[1] < range2[0]) {
        newRangeList.push(range0);
        insertPosition = i + 1;
      } else if (range0[0] > range2[1]) {
        newRangeList.push(range0);
      } else {
        range2 = [Math.min(range0[0], range2[0]), Math.max(range0[1], range2[1])];
      }
    }
    newRangeList.splice(insertPosition, 0, range2);
    return newRangeList;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/array-utils.js
  function padArrayChunk(_ref) {
    var source = _ref.source, target = _ref.target, _ref$start = _ref.start, start2 = _ref$start === void 0 ? 0 : _ref$start, end = _ref.end, size = _ref.size, getData = _ref.getData;
    end = end || target.length;
    var sourceLength = source.length;
    var targetLength = end - start2;
    if (sourceLength > targetLength) {
      target.set(source.subarray(0, targetLength), start2);
      return;
    }
    target.set(source, start2);
    if (!getData) {
      return;
    }
    var i = sourceLength;
    while (i < targetLength) {
      var datum = getData(i, source);
      for (var j = 0; j < size; j++) {
        target[start2 + i] = datum[j] || 0;
        i++;
      }
    }
  }
  function padArray(_ref2) {
    var source = _ref2.source, target = _ref2.target, size = _ref2.size, getData = _ref2.getData, sourceStartIndices = _ref2.sourceStartIndices, targetStartIndices = _ref2.targetStartIndices;
    if (!Array.isArray(targetStartIndices)) {
      padArrayChunk({
        source,
        target,
        size,
        getData
      });
      return target;
    }
    var sourceIndex = 0;
    var targetIndex = 0;
    var getChunkData = getData && function(i2, chunk) {
      return getData(i2 + targetIndex, chunk);
    };
    var n = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for (var i = 1; i < n; i++) {
      var nextSourceIndex = sourceStartIndices[i] * size;
      var nextTargetIndex = targetStartIndices[i] * size;
      padArrayChunk({
        source: source.subarray(sourceIndex, nextSourceIndex),
        target,
        start: targetIndex,
        end: nextTargetIndex,
        size,
        getData: getChunkData
      });
      sourceIndex = nextSourceIndex;
      targetIndex = nextTargetIndex;
    }
    if (targetIndex < target.length) {
      padArrayChunk({
        source: [],
        target,
        start: targetIndex,
        size,
        getData: getChunkData
      });
    }
    return target;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js
  var DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
      duration: 0,
      easing: function easing(t) {
        return t;
      }
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function normalizeTransitionSettings(userSettings, layerSettings) {
    if (!userSettings) {
      return null;
    }
    if (Number.isFinite(userSettings)) {
      userSettings = {
        duration: userSettings
      };
    }
    userSettings.type = userSettings.type || "interpolation";
    return Object.assign({}, DEFAULT_TRANSITION_SETTINGS[userSettings.type], layerSettings, userSettings);
  }
  function getSourceBufferAttribute(gl, attribute) {
    var buffer = attribute.getBuffer();
    if (buffer) {
      return [attribute.getBuffer(), {
        divisor: 0,
        size: attribute.size,
        normalized: attribute.settings.normalized
      }];
    }
    return attribute.value;
  }
  function getAttributeTypeFromSize(size) {
    switch (size) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error('No defined attribute type for size "'.concat(size, '"'));
    }
  }
  function cycleBuffers(buffers) {
    buffers.push(buffers.shift());
  }
  function getAttributeBufferLength(attribute, numInstances) {
    var doublePrecision = attribute.doublePrecision, settings = attribute.settings, value17 = attribute.value, size = attribute.size;
    var multiplier = doublePrecision && value17 instanceof Float64Array ? 2 : 1;
    return (settings.noAlloc ? value17.length : numInstances * size) * multiplier;
  }
  function padBuffer(_ref) {
    var buffer = _ref.buffer, numInstances = _ref.numInstances, attribute = _ref.attribute, fromLength = _ref.fromLength, fromStartIndices = _ref.fromStartIndices, _ref$getData = _ref.getData, getData = _ref$getData === void 0 ? function(x) {
      return x;
    } : _ref$getData;
    var precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    var size = attribute.size * precisionMultiplier;
    var byteOffset = attribute.byteOffset;
    var toStartIndices = attribute.startIndices;
    var hasStartIndices = fromStartIndices && toStartIndices;
    var toLength = getAttributeBufferLength(attribute, numInstances);
    var isConstant = attribute.state.constant;
    if (!hasStartIndices && fromLength >= toLength) {
      return;
    }
    var toData = isConstant ? attribute.value : attribute.getBuffer().getData({
      srcByteOffset: byteOffset
    });
    if (attribute.settings.normalized && !isConstant) {
      var getter = getData;
      getData = function getData2(value17, chunk) {
        return attribute._normalizeConstant(getter(value17, chunk));
      };
    }
    var getMissingData = isConstant ? function(i, chunk) {
      return getData(toData, chunk);
    } : function(i, chunk) {
      return getData(toData.subarray(i, i + size), chunk);
    };
    var source = buffer.getData({
      length: fromLength
    });
    var data = new Float32Array(toLength);
    padArray({
      source,
      target: data,
      sourceStartIndices: fromStartIndices,
      targetStartIndices: toStartIndices,
      size,
      getData: getMissingData
    });
    if (buffer.byteLength < data.byteLength + byteOffset) {
      buffer.reallocate(data.byteLength + byteOffset);
    }
    buffer.subData({
      data,
      offset: byteOffset
    });
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js
  function _createForOfIteratorHelper29(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray30(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray30(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray30(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray30(o, minLen);
  }
  function _arrayLikeToArray30(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper24(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct25();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct25() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Attribute = function(_DataColumn) {
    _inherits(Attribute2, _DataColumn);
    var _super = _createSuper24(Attribute2);
    function Attribute2(gl) {
      var _this;
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Attribute2);
      _this = _super.call(this, gl, opts);
      var _opts$transition = opts.transition, transition = _opts$transition === void 0 ? false : _opts$transition, _opts$noAlloc = opts.noAlloc, noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc, _opts$update = opts.update, update3 = _opts$update === void 0 ? null : _opts$update, _opts$accessor = opts.accessor, accessor = _opts$accessor === void 0 ? null : _opts$accessor, _opts$transform = opts.transform, transform4 = _opts$transform === void 0 ? null : _opts$transform, _opts$startIndices = opts.startIndices, startIndices = _opts$startIndices === void 0 ? null : _opts$startIndices;
      Object.assign(_this.settings, {
        transition,
        noAlloc,
        update: update3 || accessor && _this._autoUpdater,
        accessor,
        transform: transform4
      });
      Object.assign(_this.state, {
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        updateRanges: FULL,
        startIndices
      });
      Object.seal(_this.settings);
      Object.seal(_this.state);
      _this._validateAttributeUpdaters();
      return _this;
    }
    _createClass(Attribute2, [{
      key: "needsUpdate",
      value: function needsUpdate() {
        return this.state.needsUpdate;
      }
    }, {
      key: "needsRedraw",
      value: function needsRedraw() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$clearChangedFlag = _ref.clearChangedFlags, clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;
        var needsRedraw2 = this.state.needsRedraw;
        this.state.needsRedraw = needsRedraw2 && !clearChangedFlags;
        return needsRedraw2;
      }
    }, {
      key: "getUpdateTriggers",
      value: function getUpdateTriggers() {
        var accessor = this.settings.accessor;
        return [this.id].concat(typeof accessor !== "function" && accessor || []);
      }
    }, {
      key: "supportsTransition",
      value: function supportsTransition() {
        return Boolean(this.settings.transition);
      }
    }, {
      key: "getTransitionSetting",
      value: function getTransitionSetting(opts) {
        if (!opts || !this.supportsTransition()) {
          return null;
        }
        var accessor = this.settings.accessor;
        var layerSettings = this.settings.transition;
        var userSettings = Array.isArray(accessor) ? opts[accessor.find(function(a) {
          return opts[a];
        })] : opts[accessor];
        return normalizeTransitionSettings(userSettings, layerSettings);
      }
    }, {
      key: "setNeedsUpdate",
      value: function setNeedsUpdate() {
        var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
        var dataRange = arguments.length > 1 ? arguments[1] : void 0;
        this.state.needsUpdate = this.state.needsUpdate || reason;
        this.setNeedsRedraw(reason);
        if (dataRange) {
          var _dataRange$startRow = dataRange.startRow, startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow, _dataRange$endRow = dataRange.endRow, endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
          this.state.updateRanges = add5(this.state.updateRanges, [startRow, endRow]);
        } else {
          this.state.updateRanges = FULL;
        }
      }
    }, {
      key: "clearNeedsUpdate",
      value: function clearNeedsUpdate() {
        this.state.needsUpdate = false;
        this.state.updateRanges = EMPTY;
      }
    }, {
      key: "setNeedsRedraw",
      value: function setNeedsRedraw() {
        var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
        this.state.needsRedraw = this.state.needsRedraw || reason;
      }
    }, {
      key: "update",
      value: function update3(opts) {
        this.setData(opts);
      }
    }, {
      key: "allocate",
      value: function allocate(numInstances) {
        var state = this.state, settings = this.settings;
        if (settings.noAlloc) {
          return false;
        }
        if (settings.update) {
          assert8(Number.isFinite(numInstances));
          _get(_getPrototypeOf(Attribute2.prototype), "allocate", this).call(this, {
            numInstances,
            copy: state.updateRanges !== FULL
          });
          return true;
        }
        return false;
      }
    }, {
      key: "updateBuffer",
      value: function updateBuffer(_ref2) {
        var numInstances = _ref2.numInstances, data = _ref2.data, props = _ref2.props, context = _ref2.context;
        if (!this.needsUpdate()) {
          return false;
        }
        var updateRanges = this.state.updateRanges, _this$settings = this.settings, update3 = _this$settings.update, noAlloc = _this$settings.noAlloc;
        var updated = true;
        if (update3) {
          var _iterator = _createForOfIteratorHelper29(updateRanges), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), _startRow = _step$value[0], _endRow = _step$value[1];
              update3.call(context, this, {
                data,
                startRow: _startRow,
                endRow: _endRow,
                props,
                numInstances
              });
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!this.value) {
          } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
            this.setData({
              value: this.value,
              constant: this.constant
            });
          } else {
            var _iterator2 = _createForOfIteratorHelper29(updateRanges), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _step2$value = _slicedToArray(_step2.value, 2), startRow = _step2$value[0], endRow = _step2$value[1];
                var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
                var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
                _get(_getPrototypeOf(Attribute2.prototype), "updateSubBuffer", this).call(this, {
                  startOffset,
                  endOffset
                });
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          this._checkAttributeArray();
        } else {
          updated = false;
        }
        this.clearNeedsUpdate();
        this.setNeedsRedraw();
        return updated;
      }
    }, {
      key: "setConstantValue",
      value: function setConstantValue(value17) {
        if (value17 === void 0 || typeof value17 === "function") {
          return false;
        }
        var hasChanged = this.setData({
          constant: true,
          value: value17
        });
        if (hasChanged) {
          this.setNeedsRedraw();
        }
        this.clearNeedsUpdate();
        return true;
      }
    }, {
      key: "setExternalBuffer",
      value: function setExternalBuffer(buffer) {
        var state = this.state;
        if (!buffer) {
          state.lastExternalBuffer = null;
          return false;
        }
        this.clearNeedsUpdate();
        if (state.lastExternalBuffer === buffer) {
          return true;
        }
        state.lastExternalBuffer = buffer;
        this.setNeedsRedraw();
        this.setData(buffer);
        return true;
      }
    }, {
      key: "setBinaryValue",
      value: function setBinaryValue(buffer) {
        var startIndices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var state = this.state, settings = this.settings;
        if (!buffer) {
          state.binaryValue = null;
          state.binaryAccessor = null;
          return false;
        }
        if (settings.noAlloc) {
          return false;
        }
        if (state.binaryValue === buffer) {
          this.clearNeedsUpdate();
          return true;
        }
        state.binaryValue = buffer;
        this.setNeedsRedraw();
        if (ArrayBuffer.isView(buffer)) {
          buffer = {
            value: buffer
          };
        }
        var needsUpdate = settings.transform || startIndices !== this.startIndices;
        if (needsUpdate) {
          assert8(ArrayBuffer.isView(buffer.value), "invalid ".concat(settings.accessor));
          var needsNormalize = buffer.size && buffer.size !== this.size;
          state.binaryAccessor = getAccessorFromBuffer(buffer.value, {
            size: buffer.size || this.size,
            stride: buffer.stride,
            offset: buffer.offset,
            startIndices,
            nested: needsNormalize
          });
          return false;
        }
        this.clearNeedsUpdate();
        this.setData(buffer);
        return true;
      }
    }, {
      key: "getVertexOffset",
      value: function getVertexOffset(row) {
        var startIndices = this.startIndices;
        var vertexIndex = startIndices ? startIndices[row] : row;
        return vertexIndex * this.size;
      }
    }, {
      key: "getShaderAttributes",
      value: function getShaderAttributes() {
        var shaderAttributeDefs = this.settings.shaderAttributes || _defineProperty({}, this.id, null);
        var shaderAttributes = {};
        for (var shaderAttributeName in shaderAttributeDefs) {
          Object.assign(shaderAttributes, _get(_getPrototypeOf(Attribute2.prototype), "getShaderAttributes", this).call(this, shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
        }
        return shaderAttributes;
      }
    }, {
      key: "_autoUpdater",
      value: function _autoUpdater(attribute, _ref4) {
        var data = _ref4.data, startRow = _ref4.startRow, endRow = _ref4.endRow, props = _ref4.props, numInstances = _ref4.numInstances;
        if (attribute.constant) {
          return;
        }
        var settings = attribute.settings, state = attribute.state, value17 = attribute.value, size = attribute.size, startIndices = attribute.startIndices;
        var accessor = settings.accessor, transform4 = settings.transform;
        var accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
        assert8(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
        var i = attribute.getVertexOffset(startRow);
        var _createIterable = createIterable(data, startRow, endRow), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
        var _iterator3 = _createForOfIteratorHelper29(iterable), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var object = _step3.value;
            objectInfo.index++;
            var objectValue = accessorFunc(object, objectInfo);
            if (transform4) {
              objectValue = transform4.call(this, objectValue);
            }
            if (startIndices) {
              var numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
              if (objectValue && Array.isArray(objectValue[0])) {
                var startIndex = i;
                var _iterator4 = _createForOfIteratorHelper29(objectValue), _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                    var item = _step4.value;
                    attribute._normalizeValue(item, value17, startIndex);
                    startIndex += size;
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              } else if (objectValue && objectValue.length > size) {
                value17.set(objectValue, i);
              } else {
                attribute._normalizeValue(objectValue, objectInfo.target, 0);
                fillArray2({
                  target: value17,
                  source: objectInfo.target,
                  start: i,
                  count: numVertices
                });
              }
              i += numVertices * size;
            } else {
              attribute._normalizeValue(objectValue, value17, i);
              i += size;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }, {
      key: "_validateAttributeUpdaters",
      value: function _validateAttributeUpdaters() {
        var settings = this.settings;
        var hasUpdater = settings.noAlloc || typeof settings.update === "function";
        if (!hasUpdater) {
          throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
        }
      }
    }, {
      key: "_checkAttributeArray",
      value: function _checkAttributeArray() {
        var value17 = this.value;
        var limit = Math.min(4, this.size);
        if (value17 && value17.length >= limit) {
          var valid = true;
          switch (limit) {
            case 4:
              valid = valid && Number.isFinite(value17[3]);
            case 3:
              valid = valid && Number.isFinite(value17[2]);
            case 2:
              valid = valid && Number.isFinite(value17[1]);
            case 1:
              valid = valid && Number.isFinite(value17[0]);
              break;
            default:
              valid = false;
          }
          if (!valid) {
            throw new Error("Illegal attribute generated for ".concat(this.id));
          }
        }
      }
    }, {
      key: "startIndices",
      get: function get2() {
        return this.state.startIndices;
      },
      set: function set2(layout) {
        this.state.startIndices = layout;
      }
    }]);
    return Attribute2;
  }(DataColumn);

  // node_modules/@deck.gl/core/dist/esm/transitions/transition.js
  function noop2() {
  }
  var DEFAULT_SETTINGS2 = {
    onStart: noop2,
    onUpdate: noop2,
    onInterrupt: noop2,
    onEnd: noop2
  };
  var Transition = function() {
    function Transition2(timeline) {
      _classCallCheck(this, Transition2);
      this._inProgress = false;
      this._handle = null;
      this.timeline = timeline;
      this.settings = {};
    }
    _createClass(Transition2, [{
      key: "start",
      value: function start2(props) {
        this.cancel();
        this.settings = Object.assign({}, DEFAULT_SETTINGS2, props);
        this._inProgress = true;
        this.settings.onStart(this);
      }
    }, {
      key: "end",
      value: function end() {
        if (this._inProgress) {
          this.timeline.removeChannel(this._handle);
          this._handle = null;
          this._inProgress = false;
          this.settings.onEnd(this);
        }
      }
    }, {
      key: "cancel",
      value: function cancel() {
        if (this._inProgress) {
          this.settings.onInterrupt(this);
          this.timeline.removeChannel(this._handle);
          this._handle = null;
          this._inProgress = false;
        }
      }
    }, {
      key: "update",
      value: function update3() {
        if (!this._inProgress) {
          return false;
        }
        if (this._handle === null) {
          var timeline = this.timeline, settings = this.settings;
          this._handle = timeline.addChannel({
            delay: timeline.getTime(),
            duration: settings.duration
          });
        }
        this.time = this.timeline.getTime(this._handle);
        this._onUpdate();
        this.settings.onUpdate(this);
        if (this.timeline.isFinished(this._handle)) {
          this.end();
        }
        return true;
      }
    }, {
      key: "_onUpdate",
      value: function _onUpdate() {
      }
    }, {
      key: "inProgress",
      get: function get2() {
        return this._inProgress;
      }
    }]);
    return Transition2;
  }();

  // node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js
  function ownKeys14(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread14(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys14(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys14(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper30(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray31(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray31(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray31(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray31(o, minLen);
  }
  function _arrayLikeToArray31(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var GPUInterpolationTransition = function() {
    function GPUInterpolationTransition2(_ref) {
      var gl = _ref.gl, attribute = _ref.attribute, timeline = _ref.timeline;
      _classCallCheck(this, GPUInterpolationTransition2);
      this.gl = gl;
      this.type = "interpolation";
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, attribute.settings);
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.transform = getTransform(gl, attribute);
      var bufferOpts = {
        byteLength: 0,
        usage: 35050
      };
      this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
    }
    _createClass(GPUInterpolationTransition2, [{
      key: "start",
      value: function start2(transitionSettings, numInstances) {
        if (transitionSettings.duration <= 0) {
          this.transition.cancel();
          return;
        }
        var gl = this.gl, buffers = this.buffers, attribute = this.attribute;
        cycleBuffers(buffers);
        var padBufferOpts = {
          numInstances,
          attribute,
          fromLength: this.currentLength,
          fromStartIndices: this.currentStartIndices,
          getData: transitionSettings.enter
        };
        var _iterator = _createForOfIteratorHelper30(buffers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var buffer = _step.value;
            padBuffer(_objectSpread14({
              buffer
            }, padBufferOpts));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = getAttributeBufferLength(attribute, numInstances);
        this.attributeInTransition.update({
          buffer: buffers[1],
          value: attribute.value
        });
        this.transition.start(transitionSettings);
        this.transform.update({
          elementCount: Math.floor(this.currentLength / attribute.size),
          sourceBuffers: {
            aFrom: buffers[0],
            aTo: getSourceBufferAttribute(gl, attribute)
          },
          feedbackBuffers: {
            vCurrent: buffers[1]
          }
        });
      }
    }, {
      key: "update",
      value: function update3() {
        var updated = this.transition.update();
        if (updated) {
          var _this$transition = this.transition, time = _this$transition.time, _this$transition$sett = _this$transition.settings, duration = _this$transition$sett.duration, easing2 = _this$transition$sett.easing;
          var t = easing2(time / duration);
          this.transform.run({
            uniforms: {
              time: t
            }
          });
        }
        return updated;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.transition.cancel();
        this.transform["delete"]();
        while (this.buffers.length) {
          this.buffers.pop()["delete"]();
        }
      }
    }, {
      key: "inProgress",
      get: function get2() {
        return this.transition.inProgress;
      }
    }]);
    return GPUInterpolationTransition2;
  }();
  var vs6 = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
  function getTransform(gl, attribute) {
    var attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      vs: vs6,
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vCurrent"]
    });
  }

  // node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js
  function ownKeys15(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread15(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys15(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys15(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper31(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray32(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray32(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray32(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray32(o, minLen);
  }
  function _arrayLikeToArray32(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var GPUSpringTransition = function() {
    function GPUSpringTransition2(_ref) {
      var gl = _ref.gl, attribute = _ref.attribute, timeline = _ref.timeline;
      _classCallCheck(this, GPUSpringTransition2);
      this.gl = gl;
      this.type = "spring";
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, Object.assign({}, attribute.settings, {
        normalized: false
      }));
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.texture = getTexture(gl);
      this.framebuffer = getFramebuffer2(gl, this.texture);
      this.transform = getTransform2(gl, attribute, this.framebuffer);
      var bufferOpts = {
        byteLength: 0,
        usage: 35050
      };
      this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
    }
    _createClass(GPUSpringTransition2, [{
      key: "start",
      value: function start2(transitionSettings, numInstances) {
        var gl = this.gl, buffers = this.buffers, attribute = this.attribute;
        var padBufferOpts = {
          numInstances,
          attribute,
          fromLength: this.currentLength,
          fromStartIndices: this.currentStartIndices,
          getData: transitionSettings.enter
        };
        var _iterator = _createForOfIteratorHelper31(buffers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var buffer = _step.value;
            padBuffer(_objectSpread15({
              buffer
            }, padBufferOpts));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = getAttributeBufferLength(attribute, numInstances);
        this.attributeInTransition.update({
          buffer: buffers[1],
          value: attribute.value
        });
        this.transition.start(transitionSettings);
        this.transform.update({
          elementCount: Math.floor(this.currentLength / attribute.size),
          sourceBuffers: {
            aTo: getSourceBufferAttribute(gl, attribute)
          }
        });
      }
    }, {
      key: "update",
      value: function update3() {
        var buffers = this.buffers, transform4 = this.transform, framebuffer2 = this.framebuffer, transition = this.transition;
        var updated = transition.update();
        if (!updated) {
          return false;
        }
        transform4.update({
          sourceBuffers: {
            aPrev: buffers[0],
            aCur: buffers[1]
          },
          feedbackBuffers: {
            vNext: buffers[2]
          }
        });
        transform4.run({
          framebuffer: framebuffer2,
          discard: false,
          clearRenderTarget: true,
          uniforms: {
            stiffness: transition.settings.stiffness,
            damping: transition.settings.damping
          },
          parameters: {
            depthTest: false,
            blend: true,
            viewport: [0, 0, 1, 1],
            blendFunc: [1, 1],
            blendEquation: [32776, 32776]
          }
        });
        cycleBuffers(buffers);
        this.attributeInTransition.update({
          buffer: buffers[1],
          value: this.attribute.value
        });
        var isTransitioning = readPixelsToArray(framebuffer2)[0] > 0;
        if (!isTransitioning) {
          transition.end();
        }
        return true;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.transition.cancel();
        this.transform["delete"]();
        while (this.buffers.length) {
          this.buffers.pop()["delete"]();
        }
        this.texture["delete"]();
        this.texture = null;
        this.framebuffer["delete"]();
        this.framebuffer = null;
      }
    }, {
      key: "inProgress",
      get: function get2() {
        return this.transition.inProgress;
      }
    }]);
    return GPUSpringTransition2;
  }();
  function getTransform2(gl, attribute, framebuffer2) {
    var attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      framebuffer: framebuffer2,
      vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
      fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vNext"]
    });
  }
  function getTexture(gl) {
    return new Texture2D(gl, {
      data: new Uint8Array(4),
      format: 6408,
      type: 5121,
      border: 0,
      mipmaps: false,
      dataFormat: 6408,
      width: 1,
      height: 1
    });
  }
  function getFramebuffer2(gl, texture) {
    return new Framebuffer(gl, {
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      attachments: _defineProperty({}, 36064, texture)
    });
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js
  var TRANSITION_TYPES = {
    interpolation: GPUInterpolationTransition,
    spring: GPUSpringTransition
  };
  var AttributeTransitionManager = function() {
    function AttributeTransitionManager2(gl, _ref) {
      var id = _ref.id, timeline = _ref.timeline;
      _classCallCheck(this, AttributeTransitionManager2);
      this.id = id;
      this.gl = gl;
      this.timeline = timeline;
      this.transitions = {};
      this.needsRedraw = false;
      this.numInstances = 1;
      this.isSupported = Transform.isSupported(gl);
    }
    _createClass(AttributeTransitionManager2, [{
      key: "finalize",
      value: function finalize() {
        for (var attributeName in this.transitions) {
          this._removeTransition(attributeName);
        }
      }
    }, {
      key: "update",
      value: function update3(_ref2) {
        var attributes = _ref2.attributes, transitions = _ref2.transitions, numInstances = _ref2.numInstances;
        this.numInstances = numInstances || 1;
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var settings = attribute.getTransitionSetting(transitions);
          if (!settings)
            continue;
          this._updateAttribute(attributeName, attribute, settings);
        }
        for (var _attributeName in this.transitions) {
          var _attribute = attributes[_attributeName];
          if (!_attribute || !_attribute.getTransitionSetting(transitions)) {
            this._removeTransition(_attributeName);
          }
        }
      }
    }, {
      key: "hasAttribute",
      value: function hasAttribute(attributeName) {
        var transition = this.transitions[attributeName];
        return transition && transition.inProgress;
      }
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        var animatedAttributes = {};
        for (var attributeName in this.transitions) {
          var transition = this.transitions[attributeName];
          if (transition.inProgress) {
            animatedAttributes[attributeName] = transition.attributeInTransition;
          }
        }
        return animatedAttributes;
      }
    }, {
      key: "run",
      value: function run() {
        if (!this.isSupported || this.numInstances === 0) {
          return false;
        }
        for (var attributeName in this.transitions) {
          var updated = this.transitions[attributeName].update();
          if (updated) {
            this.needsRedraw = true;
          }
        }
        var needsRedraw = this.needsRedraw;
        this.needsRedraw = false;
        return needsRedraw;
      }
    }, {
      key: "_removeTransition",
      value: function _removeTransition(attributeName) {
        this.transitions[attributeName].cancel();
        delete this.transitions[attributeName];
      }
    }, {
      key: "_updateAttribute",
      value: function _updateAttribute(attributeName, attribute, settings) {
        var transition = this.transitions[attributeName];
        var isNew = !transition || transition.type !== settings.type;
        if (isNew) {
          if (!this.isSupported) {
            log_default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
            return;
          }
          if (transition) {
            this._removeTransition(attributeName);
          }
          var TransitionType = TRANSITION_TYPES[settings.type];
          if (TransitionType) {
            this.transitions[attributeName] = new TransitionType({
              attribute,
              timeline: this.timeline,
              gl: this.gl
            });
          } else {
            log_default.error("unsupported transition type '".concat(settings.type, "'"))();
            isNew = false;
          }
        }
        if (isNew || attribute.needsRedraw()) {
          this.needsRedraw = true;
          this.transitions[attributeName].start(settings, this.numInstances);
        }
      }
    }]);
    return AttributeTransitionManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js
  var TRACE_INVALIDATE = "attributeManager.invalidate";
  var TRACE_UPDATE_START = "attributeManager.updateStart";
  var TRACE_UPDATE_END = "attributeManager.updateEnd";
  var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
  var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
  var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
  var AttributeManager = function() {
    function AttributeManager2(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$id = _ref.id, id = _ref$id === void 0 ? "attribute-manager" : _ref$id, stats = _ref.stats, timeline = _ref.timeline;
      _classCallCheck(this, AttributeManager2);
      this.id = id;
      this.gl = gl;
      this.attributes = {};
      this.updateTriggers = {};
      this.accessors = {};
      this.needsRedraw = true;
      this.userData = {};
      this.stats = stats;
      this.attributeTransitionManager = new AttributeTransitionManager(gl, {
        id: "".concat(id, "-transitions"),
        timeline
      });
      Object.seal(this);
    }
    _createClass(AttributeManager2, [{
      key: "finalize",
      value: function finalize() {
        for (var attributeName in this.attributes) {
          this.attributes[attributeName]["delete"]();
        }
        this.attributeTransitionManager.finalize();
      }
    }, {
      key: "getNeedsRedraw",
      value: function getNeedsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        var redraw = this.needsRedraw;
        this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
        return redraw && this.id;
      }
    }, {
      key: "setNeedsRedraw",
      value: function setNeedsRedraw() {
        var redraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.needsRedraw = true;
        return this;
      }
    }, {
      key: "add",
      value: function add6(attributes, updaters) {
        this._add(attributes, updaters);
      }
    }, {
      key: "addInstanced",
      value: function addInstanced(attributes, updaters) {
        this._add(attributes, updaters, {
          instanced: 1
        });
      }
    }, {
      key: "remove",
      value: function remove(attributeNameArray) {
        for (var i = 0; i < attributeNameArray.length; i++) {
          var name = attributeNameArray[i];
          if (this.attributes[name] !== void 0) {
            this.attributes[name]["delete"]();
            delete this.attributes[name];
          }
        }
      }
    }, {
      key: "invalidate",
      value: function invalidate(triggerName, dataRange) {
        var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
        debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
      }
    }, {
      key: "invalidateAll",
      value: function invalidateAll(dataRange) {
        for (var attributeName in this.attributes) {
          this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
        }
        debug(TRACE_INVALIDATE, this, "all");
      }
    }, {
      key: "update",
      value: function update3() {
        var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, data = _ref2.data, numInstances = _ref2.numInstances, _ref2$startIndices = _ref2.startIndices, startIndices = _ref2$startIndices === void 0 ? null : _ref2$startIndices, transitions = _ref2.transitions, _ref2$props = _ref2.props, props = _ref2$props === void 0 ? {} : _ref2$props, _ref2$buffers = _ref2.buffers, buffers = _ref2$buffers === void 0 ? {} : _ref2$buffers, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? {} : _ref2$context;
        var updated = false;
        debug(TRACE_UPDATE_START, this);
        if (this.stats) {
          this.stats.get("Update Attributes").timeStart();
        }
        for (var attributeName in this.attributes) {
          var attribute = this.attributes[attributeName];
          var accessorName = attribute.settings.accessor;
          attribute.startIndices = startIndices;
          if (props[attributeName]) {
            log_default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
          }
          if (attribute.setExternalBuffer(buffers[attributeName])) {
          } else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {
          } else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
          } else if (attribute.needsUpdate()) {
            updated = true;
            this._updateAttribute({
              attribute,
              numInstances,
              data,
              props,
              context
            });
          }
          this.needsRedraw |= attribute.needsRedraw();
        }
        if (updated) {
          debug(TRACE_UPDATE_END, this, numInstances);
        }
        if (this.stats) {
          this.stats.get("Update Attributes").timeEnd();
        }
        this.attributeTransitionManager.update({
          attributes: this.attributes,
          numInstances,
          transitions
        });
      }
    }, {
      key: "updateTransition",
      value: function updateTransition() {
        var attributeTransitionManager = this.attributeTransitionManager;
        var transitionUpdated = attributeTransitionManager.run();
        this.needsRedraw = this.needsRedraw || transitionUpdated;
        return transitionUpdated;
      }
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        return this.attributes;
      }
    }, {
      key: "getChangedAttributes",
      value: function getChangedAttributes() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearChangedFlags: false
        };
        var attributes = this.attributes, attributeTransitionManager = this.attributeTransitionManager;
        var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
            changedAttributes[attributeName] = attribute;
          }
        }
        return changedAttributes;
      }
    }, {
      key: "getShaderAttributes",
      value: function getShaderAttributes(attributes) {
        var excludeAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!attributes) {
          attributes = this.getAttributes();
        }
        var shaderAttributes = {};
        for (var attributeName in attributes) {
          if (!excludeAttributes[attributeName]) {
            Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
          }
        }
        return shaderAttributes;
      }
    }, {
      key: "getAccessors",
      value: function getAccessors() {
        return this.updateTriggers;
      }
    }, {
      key: "_add",
      value: function _add(attributes, updaters) {
        var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (updaters) {
          log_default.warn("AttributeManager.add({updaters}) - updater map no longer supported")();
        }
        var newAttributes = {};
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var newAttribute = this._createAttribute(attributeName, attribute, extraProps);
          newAttributes[attributeName] = newAttribute;
        }
        Object.assign(this.attributes, newAttributes);
        this._mapUpdateTriggersToAttributes();
      }
    }, {
      key: "_createAttribute",
      value: function _createAttribute(name, attribute, extraProps) {
        var props = {
          id: name,
          constant: attribute.constant || false,
          isIndexed: attribute.isIndexed || attribute.elements,
          size: attribute.elements && 1 || attribute.size,
          value: attribute.value || null,
          divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor
        };
        return new Attribute(this.gl, Object.assign({}, attribute, props));
      }
    }, {
      key: "_mapUpdateTriggersToAttributes",
      value: function _mapUpdateTriggersToAttributes() {
        var _this = this;
        var triggers = {};
        var _loop = function _loop2(attributeName2) {
          var attribute = _this.attributes[attributeName2];
          attribute.getUpdateTriggers().forEach(function(triggerName) {
            if (!triggers[triggerName]) {
              triggers[triggerName] = [];
            }
            triggers[triggerName].push(attributeName2);
          });
        };
        for (var attributeName in this.attributes) {
          _loop(attributeName);
        }
        this.updateTriggers = triggers;
      }
    }, {
      key: "_invalidateTrigger",
      value: function _invalidateTrigger(triggerName, dataRange) {
        var attributes = this.attributes, updateTriggers = this.updateTriggers;
        var invalidatedAttributes = updateTriggers[triggerName];
        if (invalidatedAttributes) {
          invalidatedAttributes.forEach(function(name) {
            var attribute = attributes[name];
            if (attribute) {
              attribute.setNeedsUpdate(attribute.id, dataRange);
            }
          });
        }
        return invalidatedAttributes;
      }
    }, {
      key: "_updateAttribute",
      value: function _updateAttribute(opts) {
        var attribute = opts.attribute, numInstances = opts.numInstances;
        debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
        if (attribute.allocate(numInstances)) {
          debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
        }
        var updated = attribute.updateBuffer(opts);
        if (updated) {
          this.needsRedraw = true;
          debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
        }
      }
    }]);
    return AttributeManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js
  function _createSuper25(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct26();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct26() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var CPUInterpolationTransition = function(_Transition) {
    _inherits(CPUInterpolationTransition2, _Transition);
    var _super = _createSuper25(CPUInterpolationTransition2);
    function CPUInterpolationTransition2() {
      _classCallCheck(this, CPUInterpolationTransition2);
      return _super.apply(this, arguments);
    }
    _createClass(CPUInterpolationTransition2, [{
      key: "_onUpdate",
      value: function _onUpdate() {
        var time = this.time, _this$settings = this.settings, fromValue = _this$settings.fromValue, toValue = _this$settings.toValue, duration = _this$settings.duration, easing2 = _this$settings.easing;
        var t = easing2(time / duration);
        this._value = lerp(fromValue, toValue, t);
      }
    }, {
      key: "value",
      get: function get2() {
        return this._value;
      }
    }]);
    return CPUInterpolationTransition2;
  }(Transition);

  // node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js
  function _createSuper26(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct27();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct27() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var EPSILON2 = 1e-5;
  function updateSpringElement(prev, cur, dest, damping, stiffness) {
    var velocity = cur - prev;
    var delta = dest - cur;
    var spring = delta * stiffness;
    var damper = -velocity * damping;
    return spring + damper + velocity + cur;
  }
  function updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
      var next = [];
      for (var i = 0; i < dest.length; i++) {
        next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
      }
      return next;
    }
    return updateSpringElement(prev, cur, dest, damping, stiffness);
  }
  function distance(value1, value22) {
    if (Array.isArray(value1)) {
      var distanceSquare = 0;
      for (var i = 0; i < value1.length; i++) {
        var d = value1[i] - value22[i];
        distanceSquare += d * d;
      }
      return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value22);
  }
  var CPUSpringTransition = function(_Transition) {
    _inherits(CPUSpringTransition2, _Transition);
    var _super = _createSuper26(CPUSpringTransition2);
    function CPUSpringTransition2() {
      _classCallCheck(this, CPUSpringTransition2);
      return _super.apply(this, arguments);
    }
    _createClass(CPUSpringTransition2, [{
      key: "_onUpdate",
      value: function _onUpdate() {
        var _this$settings = this.settings, fromValue = _this$settings.fromValue, toValue = _this$settings.toValue, damping = _this$settings.damping, stiffness = _this$settings.stiffness;
        var _this$_prevValue = this._prevValue, _prevValue = _this$_prevValue === void 0 ? fromValue : _this$_prevValue, _this$_currValue = this._currValue, _currValue = _this$_currValue === void 0 ? fromValue : _this$_currValue;
        var nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
        var delta = distance(nextValue, toValue);
        var velocity = distance(nextValue, _currValue);
        if (delta < EPSILON2 && velocity < EPSILON2) {
          nextValue = toValue;
          this.end();
        }
        this._prevValue = _currValue;
        this._currValue = nextValue;
      }
    }, {
      key: "value",
      get: function get2() {
        return this._currValue;
      }
    }]);
    return CPUSpringTransition2;
  }(Transition);

  // node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js
  function _createForOfIteratorHelper32(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray33(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray33(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray33(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray33(o, minLen);
  }
  function _arrayLikeToArray33(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys16(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread16(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys16(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys16(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var TRANSITION_TYPES2 = {
    interpolation: CPUInterpolationTransition,
    spring: CPUSpringTransition
  };
  var UniformTransitionManager = function() {
    function UniformTransitionManager2(timeline) {
      _classCallCheck(this, UniformTransitionManager2);
      this.transitions = new Map();
      this.timeline = timeline;
    }
    _createClass(UniformTransitionManager2, [{
      key: "add",
      value: function add6(key, fromValue, toValue, settings) {
        var transitions = this.transitions;
        if (transitions.has(key)) {
          var _transition = transitions.get(key);
          var _transition$value = _transition.value, value17 = _transition$value === void 0 ? _transition.settings.fromValue : _transition$value;
          fromValue = value17;
          this.remove(key);
        }
        settings = normalizeTransitionSettings(settings);
        if (!settings) {
          return;
        }
        var TransitionType = TRANSITION_TYPES2[settings.type];
        if (!TransitionType) {
          log_default.error("unsupported transition type '".concat(settings.type, "'"))();
          return;
        }
        var transition = new TransitionType(this.timeline);
        transition.start(_objectSpread16(_objectSpread16({}, settings), {}, {
          fromValue,
          toValue
        }));
        transitions.set(key, transition);
      }
    }, {
      key: "remove",
      value: function remove(key) {
        var transitions = this.transitions;
        if (transitions.has(key)) {
          transitions.get(key).cancel();
          transitions["delete"](key);
        }
      }
    }, {
      key: "update",
      value: function update3() {
        var propsInTransition = {};
        var _iterator = _createForOfIteratorHelper32(this.transitions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], transition = _step$value[1];
            transition.update();
            propsInTransition[key] = transition.value;
            if (!transition.inProgress) {
              this.remove(key);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return propsInTransition;
      }
    }, {
      key: "clear",
      value: function clear2() {
        var _iterator2 = _createForOfIteratorHelper32(this.transitions.keys()), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var key = _step2.value;
            this.remove(key);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "active",
      get: function get2() {
        return this.transitions.size > 0;
      }
    }]);
    return UniformTransitionManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js
  var LIFECYCLE = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  };
  var PROP_SYMBOLS = {
    COMPONENT: Symbol["for"]("component"),
    ASYNC_DEFAULTS: Symbol["for"]("asyncPropDefaults"),
    ASYNC_ORIGINAL: Symbol["for"]("asyncPropOriginal"),
    ASYNC_RESOLVED: Symbol["for"]("asyncPropResolved")
  };

  // node_modules/@deck.gl/core/dist/esm/lifecycle/props.js
  var COMPONENT = PROP_SYMBOLS.COMPONENT;
  function validateProps(props) {
    var propTypes = getPropTypes(props);
    for (var propName in propTypes) {
      var propType = propTypes[propName];
      var validate11 = propType.validate;
      if (validate11 && !validate11(props[propName], propType)) {
        throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
      }
    }
  }
  function diffProps(props, oldProps) {
    var propsChangedReason = compareProps({
      newProps: props,
      oldProps,
      propTypes: getPropTypes(props),
      ignoreProps: {
        data: null,
        updateTriggers: null,
        extensions: null,
        transitions: null
      }
    });
    var dataChangedReason = diffDataProps(props, oldProps);
    var updateTriggersChangedReason = false;
    if (!dataChangedReason) {
      updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
    }
    return {
      dataChanged: dataChangedReason,
      propsChanged: propsChangedReason,
      updateTriggersChanged: updateTriggersChangedReason,
      extensionsChanged: diffExtensions(props, oldProps),
      transitionsChanged: diffTransitions(props, oldProps)
    };
  }
  function diffTransitions(props, oldProps) {
    if (!props.transitions) {
      return null;
    }
    var result = {};
    var propTypes = getPropTypes(props);
    for (var key in props.transitions) {
      var propType = propTypes[key];
      var type = propType && propType.type;
      var isTransitionable = type === "number" || type === "color" || type === "array";
      if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
        result[key] = true;
      }
    }
    return result;
  }
  function compareProps() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, newProps = _ref.newProps, oldProps = _ref.oldProps, _ref$ignoreProps = _ref.ignoreProps, ignoreProps = _ref$ignoreProps === void 0 ? {} : _ref$ignoreProps, _ref$propTypes = _ref.propTypes, propTypes = _ref$propTypes === void 0 ? {} : _ref$propTypes, _ref$triggerName = _ref.triggerName, triggerName = _ref$triggerName === void 0 ? "props" : _ref$triggerName;
    if (oldProps === newProps) {
      return null;
    }
    if (_typeof(newProps) !== "object" || newProps === null) {
      return "".concat(triggerName, " changed shallowly");
    }
    if (_typeof(oldProps) !== "object" || oldProps === null) {
      return "".concat(triggerName, " changed shallowly");
    }
    for (var _i = 0, _Object$keys = Object.keys(newProps); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (!(key in ignoreProps)) {
        if (!(key in oldProps)) {
          return "".concat(triggerName, ".").concat(key, " added");
        }
        var changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
    for (var _i2 = 0, _Object$keys2 = Object.keys(oldProps); _i2 < _Object$keys2.length; _i2++) {
      var _key = _Object$keys2[_i2];
      if (!(_key in ignoreProps)) {
        if (!(_key in newProps)) {
          return "".concat(triggerName, ".").concat(_key, " dropped");
        }
        if (!Object.hasOwnProperty.call(newProps, _key)) {
          var _changed = comparePropValues(newProps[_key], oldProps[_key], propTypes[_key]);
          if (_changed) {
            return "".concat(triggerName, ".").concat(_key, " ").concat(_changed);
          }
        }
      }
    }
    return null;
  }
  function comparePropValues(newProp, oldProp, propType) {
    var equal6 = propType && propType.equal;
    if (equal6 && !equal6(newProp, oldProp, propType)) {
      return "changed deeply";
    }
    if (!equal6) {
      equal6 = newProp && oldProp && newProp.equals;
      if (equal6 && !equal6.call(newProp, oldProp)) {
        return "changed deeply";
      }
    }
    if (!equal6 && oldProp !== newProp) {
      return "changed shallowly";
    }
    return null;
  }
  function diffDataProps(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    var dataChanged = null;
    var dataComparator = props.dataComparator, _dataDiff = props._dataDiff;
    if (dataComparator) {
      if (!dataComparator(props.data, oldProps.data)) {
        dataChanged = "Data comparator detected a change";
      }
    } else if (props.data !== oldProps.data) {
      dataChanged = "A new data container was supplied";
    }
    if (dataChanged && _dataDiff) {
      dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    }
    return dataChanged;
  }
  function diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    if ("all" in props.updateTriggers) {
      var diffReason = diffUpdateTrigger(props, oldProps, "all");
      if (diffReason) {
        return {
          all: true
        };
      }
    }
    var triggerChanged = {};
    var reason = false;
    for (var triggerName in props.updateTriggers) {
      if (triggerName !== "all") {
        var _diffReason = diffUpdateTrigger(props, oldProps, triggerName);
        if (_diffReason) {
          triggerChanged[triggerName] = true;
          reason = triggerChanged;
        }
      }
    }
    return reason;
  }
  function diffExtensions(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    var oldExtensions = oldProps.extensions;
    var extensions = props.extensions;
    if (extensions === oldExtensions) {
      return false;
    }
    if (extensions.length !== oldExtensions.length) {
      return true;
    }
    for (var i = 0; i < extensions.length; i++) {
      if (!extensions[i].equals(oldExtensions[i])) {
        return true;
      }
    }
    return false;
  }
  function diffUpdateTrigger(props, oldProps, triggerName) {
    var newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
    var oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
    var diffReason = compareProps({
      oldProps: oldTriggers,
      newProps: newTriggers,
      triggerName
    });
    return diffReason;
  }
  function getPropTypes(props) {
    var layer = props[COMPONENT];
    var LayerType = layer && layer.constructor;
    return LayerType ? LayerType._propTypes : {};
  }

  // node_modules/@deck.gl/core/dist/esm/utils/count.js
  var ERR_NOT_OBJECT = "count(): argument not an object";
  var ERR_NOT_CONTAINER = "count(): argument not a container";
  function count2(container) {
    if (!isObject5(container)) {
      throw new Error(ERR_NOT_OBJECT);
    }
    if (typeof container.count === "function") {
      return container.count();
    }
    if (Number.isFinite(container.size)) {
      return container.size;
    }
    if (Number.isFinite(container.length)) {
      return container.length;
    }
    if (isPlainObject(container)) {
      return Object.keys(container).length;
    }
    throw new Error(ERR_NOT_CONTAINER);
  }
  function isPlainObject(value17) {
    return value17 !== null && _typeof(value17) === "object" && value17.constructor === Object;
  }
  function isObject5(value17) {
    return value17 !== null && _typeof(value17) === "object";
  }

  // node_modules/@deck.gl/core/dist/esm/utils/shader.js
  function ownKeys17(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread17(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys17(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys17(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function mergeShaders(target, source) {
    if (!source) {
      return target;
    }
    var result = Object.assign({}, target, source);
    if ("defines" in source) {
      result.defines = Object.assign({}, target.defines, source.defines);
    }
    if ("modules" in source) {
      result.modules = (target.modules || []).concat(source.modules);
      if (source.modules.some(function(module2) {
        return module2.name === "project64";
      })) {
        var index = result.modules.findIndex(function(module2) {
          return module2.name === "project32";
        });
        if (index >= 0) {
          result.modules.splice(index, 1);
        }
      }
    }
    if ("inject" in source) {
      if (!target.inject) {
        result.inject = source.inject;
      } else {
        var mergedInjection = _objectSpread17({}, target.inject);
        for (var key in source.inject) {
          mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
        }
        result.inject = mergedInjection;
      }
    }
    return result;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/texture.js
  var _DEFAULT_TEXTURE_PARA;
  function ownKeys18(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread18(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys18(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys18(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);
  var internalTextures = {};
  function createTexture(layer, image) {
    var gl = layer.context && layer.context.gl;
    if (!gl || !image) {
      return null;
    }
    if (image instanceof Texture2D) {
      return image;
    } else if (image.constructor && image.constructor.name !== "Object") {
      image = {
        data: image
      };
    }
    var specialTextureParameters = null;
    if (image.compressed) {
      specialTextureParameters = _defineProperty({}, 10241, image.data.length > 1 ? 9985 : 9729);
    }
    var texture = new Texture2D(gl, _objectSpread18(_objectSpread18({}, image), {}, {
      parameters: _objectSpread18(_objectSpread18(_objectSpread18({}, DEFAULT_TEXTURE_PARAMETERS), specialTextureParameters), layer.props.textureParameters)
    }));
    internalTextures[texture.id] = true;
    return texture;
  }
  function destroyTexture(texture) {
    if (!texture || !(texture instanceof Texture2D)) {
      return;
    }
    if (internalTextures[texture.id]) {
      texture["delete"]();
      delete internalTextures[texture.id];
    }
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js
  var TYPE_DEFINITIONS2 = {
    "boolean": {
      validate: function validate3(value17, propType) {
        return true;
      },
      equal: function equal(value1, value22, propType) {
        return Boolean(value1) === Boolean(value22);
      }
    },
    number: {
      validate: function validate4(value17, propType) {
        return Number.isFinite(value17) && (!("max" in propType) || value17 <= propType.max) && (!("min" in propType) || value17 >= propType.min);
      }
    },
    color: {
      validate: function validate5(value17, propType) {
        return propType.optional && !value17 || isArray3(value17) && (value17.length === 3 || value17.length === 4);
      },
      equal: function equal2(value1, value22, propType) {
        return arrayEqual(value1, value22);
      }
    },
    accessor: {
      validate: function validate6(value17, propType) {
        var valueType = getTypeOf2(value17);
        return valueType === "function" || valueType === getTypeOf2(propType.value);
      },
      equal: function equal3(value1, value22, propType) {
        if (typeof value22 === "function") {
          return true;
        }
        return arrayEqual(value1, value22);
      }
    },
    array: {
      validate: function validate7(value17, propType) {
        return propType.optional && !value17 || isArray3(value17);
      },
      equal: function equal4(value1, value22, propType) {
        return propType.compare ? arrayEqual(value1, value22) : value1 === value22;
      }
    },
    "function": {
      validate: function validate8(value17, propType) {
        return propType.optional && !value17 || typeof value17 === "function";
      },
      equal: function equal5(value1, value22, propType) {
        return !propType.compare || value1 === value22;
      }
    },
    data: {
      transform: function transform2(value17, propType, component) {
        var _ref = component ? component.props : {}, dataTransform = _ref.dataTransform;
        return dataTransform && value17 ? dataTransform(value17) : value17;
      }
    },
    image: {
      transform: function transform3(value17, propType, component) {
        return createTexture(component, value17);
      },
      release: function release(value17) {
        destroyTexture(value17);
      }
    }
  };
  function arrayEqual(array12, array2) {
    if (array12 === array2) {
      return true;
    }
    if (!isArray3(array12) || !isArray3(array2)) {
      return false;
    }
    var len2 = array12.length;
    if (len2 !== array2.length) {
      return false;
    }
    for (var i = 0; i < len2; i++) {
      if (array12[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function parsePropTypes2(propDefs) {
    var propTypes = {};
    var defaultProps13 = {};
    var deprecatedProps = {};
    for (var _i = 0, _Object$entries = Object.entries(propDefs); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), propName = _Object$entries$_i[0], propDef = _Object$entries$_i[1];
      if (propDef && propDef.deprecatedFor) {
        deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor) ? propDef.deprecatedFor : [propDef.deprecatedFor];
      } else {
        var propType = parsePropType2(propName, propDef);
        propTypes[propName] = propType;
        defaultProps13[propName] = propType.value;
      }
    }
    return {
      propTypes,
      defaultProps: defaultProps13,
      deprecatedProps
    };
  }
  function parsePropType2(name, propDef) {
    switch (getTypeOf2(propDef)) {
      case "object":
        return normalizePropDefinition(name, propDef);
      case "array":
        return normalizePropDefinition(name, {
          type: "array",
          value: propDef,
          compare: false
        });
      case "boolean":
        return normalizePropDefinition(name, {
          type: "boolean",
          value: propDef
        });
      case "number":
        return normalizePropDefinition(name, {
          type: "number",
          value: propDef
        });
      case "function":
        return normalizePropDefinition(name, {
          type: "function",
          value: propDef,
          compare: true
        });
      default:
        return {
          name,
          type: "unknown",
          value: propDef
        };
    }
  }
  function normalizePropDefinition(name, propDef) {
    if (!("type" in propDef)) {
      if (!("value" in propDef)) {
        return {
          name,
          type: "object",
          value: propDef
        };
      }
      return Object.assign({
        name,
        type: getTypeOf2(propDef.value)
      }, propDef);
    }
    return Object.assign({
      name
    }, TYPE_DEFINITIONS2[propDef.type], propDef);
  }
  function isArray3(value17) {
    return Array.isArray(value17) || ArrayBuffer.isView(value17);
  }
  function getTypeOf2(value17) {
    if (isArray3(value17)) {
      return "array";
    }
    if (value17 === null) {
      return "null";
    }
    return _typeof(value17);
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js
  function _createForOfIteratorHelper33(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray34(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray34(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray34(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray34(o, minLen);
  }
  function _arrayLikeToArray34(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var COMPONENT2 = PROP_SYMBOLS.COMPONENT;
  var ASYNC_ORIGINAL = PROP_SYMBOLS.ASYNC_ORIGINAL;
  var ASYNC_RESOLVED = PROP_SYMBOLS.ASYNC_RESOLVED;
  var ASYNC_DEFAULTS = PROP_SYMBOLS.ASYNC_DEFAULTS;
  function createProps() {
    var component = this;
    var propsPrototype = getPropsPrototype(component.constructor);
    var propsInstance = Object.create(propsPrototype);
    propsInstance[COMPONENT2] = component;
    propsInstance[ASYNC_ORIGINAL] = {};
    propsInstance[ASYNC_RESOLVED] = {};
    for (var i = 0; i < arguments.length; ++i) {
      var props = arguments[i];
      for (var key in props) {
        propsInstance[key] = props[key];
      }
    }
    Object.freeze(propsInstance);
    return propsInstance;
  }
  function getPropsPrototype(componentClass) {
    var defaultProps13 = getOwnProperty(componentClass, "_mergedDefaultProps");
    if (!defaultProps13) {
      createPropsPrototypeAndTypes(componentClass);
      return componentClass._mergedDefaultProps;
    }
    return defaultProps13;
  }
  function createPropsPrototypeAndTypes(componentClass) {
    var parent = componentClass.prototype;
    if (!parent) {
      return;
    }
    var parentClass = Object.getPrototypeOf(componentClass);
    var parentDefaultProps = getPropsPrototype(parentClass);
    var componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
    var componentPropDefs = parsePropTypes2(componentDefaultProps);
    var defaultProps13 = createPropsPrototype(componentPropDefs.defaultProps, parentDefaultProps, componentClass);
    var propTypes = Object.assign({}, parentClass._propTypes, componentPropDefs.propTypes);
    addAsyncPropsToPropPrototype(defaultProps13, propTypes);
    var deprecatedProps = Object.assign({}, parentClass._deprecatedProps, componentPropDefs.deprecatedProps);
    addDeprecatedPropsToPropPrototype(defaultProps13, deprecatedProps);
    componentClass._mergedDefaultProps = defaultProps13;
    componentClass._propTypes = propTypes;
    componentClass._deprecatedProps = deprecatedProps;
  }
  function createPropsPrototype(props, parentProps, componentClass) {
    var defaultProps13 = Object.create(null);
    Object.assign(defaultProps13, parentProps, props);
    var id = getComponentName(componentClass);
    delete props.id;
    Object.defineProperties(defaultProps13, {
      id: {
        writable: true,
        value: id
      }
    });
    return defaultProps13;
  }
  function addDeprecatedPropsToPropPrototype(defaultProps13, deprecatedProps) {
    var _loop = function _loop2(propName2) {
      Object.defineProperty(defaultProps13, propName2, {
        enumerable: false,
        set: function set2(newValue) {
          var nameStr = "".concat(this.id, ": ").concat(propName2);
          var _iterator = _createForOfIteratorHelper33(deprecatedProps[propName2]), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var newPropName = _step.value;
              if (!hasOwnProperty(this, newPropName)) {
                this[newPropName] = newValue;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          log_default.deprecated(nameStr, deprecatedProps[propName2].join("/"))();
        }
      });
    };
    for (var propName in deprecatedProps) {
      _loop(propName);
    }
  }
  function addAsyncPropsToPropPrototype(defaultProps13, propTypes) {
    var defaultValues = {};
    var descriptors = {};
    for (var propName in propTypes) {
      var propType = propTypes[propName];
      var name = propType.name, value17 = propType.value;
      if (propType.async) {
        defaultValues[name] = value17;
        descriptors[name] = getDescriptorForAsyncProp(name, value17);
      }
    }
    defaultProps13[ASYNC_DEFAULTS] = defaultValues;
    defaultProps13[ASYNC_ORIGINAL] = {};
    Object.defineProperties(defaultProps13, descriptors);
  }
  function getDescriptorForAsyncProp(name) {
    return {
      enumerable: true,
      set: function set2(newValue) {
        if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable3(newValue)) {
          this[ASYNC_ORIGINAL][name] = newValue;
        } else {
          this[ASYNC_RESOLVED][name] = newValue;
        }
      },
      get: function get2() {
        if (this[ASYNC_RESOLVED]) {
          if (name in this[ASYNC_RESOLVED]) {
            var value17 = this[ASYNC_RESOLVED][name];
            return value17 || this[ASYNC_DEFAULTS][name];
          }
          if (name in this[ASYNC_ORIGINAL]) {
            var state = this[COMPONENT2] && this[COMPONENT2].internalState;
            if (state && state.hasAsyncProp(name)) {
              return state.getAsyncProp(name) || this[ASYNC_DEFAULTS][name];
            }
          }
        }
        return this[ASYNC_DEFAULTS][name];
      }
    };
  }
  function hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
  }
  function getOwnProperty(object, prop) {
    return hasOwnProperty(object, prop) && object[prop];
  }
  function getComponentName(componentClass) {
    var componentName = getOwnProperty(componentClass, "layerName") || getOwnProperty(componentClass, "componentName");
    if (!componentName) {
      log_default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
    }
    return componentName || componentClass.name;
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js
  var import_regenerator25 = __toModule(require_regenerator());
  var ASYNC_ORIGINAL2 = PROP_SYMBOLS.ASYNC_ORIGINAL;
  var ASYNC_RESOLVED2 = PROP_SYMBOLS.ASYNC_RESOLVED;
  var ASYNC_DEFAULTS2 = PROP_SYMBOLS.ASYNC_DEFAULTS;
  var EMPTY_PROPS = Object.freeze({});
  var ComponentState = function() {
    function ComponentState2() {
      var component = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      _classCallCheck(this, ComponentState2);
      this.component = component;
      this.asyncProps = {};
      this.onAsyncPropUpdated = function() {
      };
      this.oldProps = EMPTY_PROPS;
      this.oldAsyncProps = null;
    }
    _createClass(ComponentState2, [{
      key: "finalize",
      value: function finalize() {
        for (var propName in this.asyncProps) {
          var asyncProp = this.asyncProps[propName];
          if (asyncProp.type && asyncProp.type.release) {
            asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
          }
        }
      }
    }, {
      key: "getOldProps",
      value: function getOldProps() {
        return this.oldAsyncProps || this.oldProps;
      }
    }, {
      key: "resetOldProps",
      value: function resetOldProps() {
        this.oldAsyncProps = null;
        this.oldProps = this.component.props;
      }
    }, {
      key: "freezeAsyncOldProps",
      value: function freezeAsyncOldProps() {
        if (!this.oldAsyncProps) {
          this.oldProps = this.oldProps || this.component.props;
          this.oldAsyncProps = Object.create(this.oldProps);
          for (var propName in this.asyncProps) {
            Object.defineProperty(this.oldAsyncProps, propName, {
              enumerable: true,
              value: this.oldProps[propName]
            });
          }
        }
      }
    }, {
      key: "hasAsyncProp",
      value: function hasAsyncProp(propName) {
        return propName in this.asyncProps;
      }
    }, {
      key: "getAsyncProp",
      value: function getAsyncProp(propName) {
        var asyncProp = this.asyncProps[propName];
        return asyncProp && asyncProp.resolvedValue;
      }
    }, {
      key: "isAsyncPropLoading",
      value: function isAsyncPropLoading(propName) {
        if (propName) {
          var asyncProp = this.asyncProps[propName];
          return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
        }
        for (var key in this.asyncProps) {
          if (this.isAsyncPropLoading(key)) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "reloadAsyncProp",
      value: function reloadAsyncProp(propName, value17) {
        this._watchPromise(propName, Promise.resolve(value17));
      }
    }, {
      key: "setAsyncProps",
      value: function setAsyncProps(props) {
        var resolvedValues = props[ASYNC_RESOLVED2] || {};
        var originalValues = props[ASYNC_ORIGINAL2] || props;
        var defaultValues = props[ASYNC_DEFAULTS2] || {};
        for (var propName in resolvedValues) {
          var value17 = resolvedValues[propName];
          this._createAsyncPropData(propName, defaultValues[propName]);
          this._updateAsyncProp(propName, value17);
          resolvedValues[propName] = this.getAsyncProp(propName);
        }
        for (var _propName in originalValues) {
          var _value2 = originalValues[_propName];
          this._createAsyncPropData(_propName, defaultValues[_propName]);
          this._updateAsyncProp(_propName, _value2);
        }
      }
    }, {
      key: "_updateAsyncProp",
      value: function _updateAsyncProp(propName, value17) {
        if (!this._didAsyncInputValueChange(propName, value17)) {
          return;
        }
        if (typeof value17 === "string") {
          var fetch2 = this.layer && this.layer.props.fetch;
          var url = value17;
          if (fetch2) {
            value17 = fetch2(url, {
              propName,
              layer: this.layer
            });
          }
        }
        if (value17 instanceof Promise) {
          this._watchPromise(propName, value17);
          return;
        }
        if (isAsyncIterable3(value17)) {
          this._resolveAsyncIterable(propName, value17);
          return;
        }
        this._setPropValue(propName, value17);
      }
    }, {
      key: "_didAsyncInputValueChange",
      value: function _didAsyncInputValueChange(propName, value17) {
        var asyncProp = this.asyncProps[propName];
        if (value17 === asyncProp.resolvedValue || value17 === asyncProp.lastValue) {
          return false;
        }
        asyncProp.lastValue = value17;
        return true;
      }
    }, {
      key: "_setPropValue",
      value: function _setPropValue(propName, value17) {
        var asyncProp = this.asyncProps[propName];
        value17 = this._postProcessValue(asyncProp, value17);
        asyncProp.resolvedValue = value17;
        asyncProp.pendingLoadCount++;
        asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
      }
    }, {
      key: "_setAsyncPropValue",
      value: function _setAsyncPropValue(propName, value17, loadCount) {
        var asyncProp = this.asyncProps[propName];
        if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value17 !== void 0) {
          this.freezeAsyncOldProps();
          asyncProp.resolvedValue = value17;
          asyncProp.resolvedLoadCount = loadCount;
          this.onAsyncPropUpdated(propName, value17);
        }
      }
    }, {
      key: "_watchPromise",
      value: function _watchPromise(propName, promise) {
        var _this = this;
        var asyncProp = this.asyncProps[propName];
        asyncProp.pendingLoadCount++;
        var loadCount = asyncProp.pendingLoadCount;
        promise.then(function(data) {
          data = _this._postProcessValue(asyncProp, data);
          _this._setAsyncPropValue(propName, data, loadCount);
          var onDataLoad = _this.layer && _this.layer.props.onDataLoad;
          if (propName === "data" && onDataLoad) {
            onDataLoad(data, {
              propName,
              layer: _this.layer
            });
          }
        })["catch"](function(error2) {
          return log_default.error(error2)();
        });
      }
    }, {
      key: "_resolveAsyncIterable",
      value: function() {
        var _resolveAsyncIterable2 = _asyncToGenerator(import_regenerator25.default.mark(function _callee(propName, iterable) {
          var asyncProp, loadCount, data, count3, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, _ref, dataTransform, onDataLoad;
          return import_regenerator25.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (propName !== "data") {
                    this._setPropValue(propName, iterable);
                  }
                  asyncProp = this.asyncProps[propName];
                  asyncProp.pendingLoadCount++;
                  loadCount = asyncProp.pendingLoadCount;
                  data = [];
                  count3 = 0;
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _context.prev = 8;
                  _iterator = _asyncIterator(iterable);
                case 10:
                  _context.next = 12;
                  return _iterator.next();
                case 12:
                  _step = _context.sent;
                  _iteratorNormalCompletion = _step.done;
                  _context.next = 16;
                  return _step.value;
                case 16:
                  _value = _context.sent;
                  if (_iteratorNormalCompletion) {
                    _context.next = 27;
                    break;
                  }
                  chunk = _value;
                  _ref = this.component ? this.component.props : {}, dataTransform = _ref.dataTransform;
                  if (dataTransform) {
                    data = dataTransform(chunk, data);
                  } else {
                    data = data.concat(chunk);
                  }
                  Object.defineProperty(data, "__diff", {
                    enumerable: false,
                    value: [{
                      startRow: count3,
                      endRow: data.length
                    }]
                  });
                  count3 = data.length;
                  this._setAsyncPropValue(propName, data, loadCount);
                case 24:
                  _iteratorNormalCompletion = true;
                  _context.next = 10;
                  break;
                case 27:
                  _context.next = 33;
                  break;
                case 29:
                  _context.prev = 29;
                  _context.t0 = _context["catch"](8);
                  _didIteratorError = true;
                  _iteratorError = _context.t0;
                case 33:
                  _context.prev = 33;
                  _context.prev = 34;
                  if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
                    _context.next = 38;
                    break;
                  }
                  _context.next = 38;
                  return _iterator["return"]();
                case 38:
                  _context.prev = 38;
                  if (!_didIteratorError) {
                    _context.next = 41;
                    break;
                  }
                  throw _iteratorError;
                case 41:
                  return _context.finish(38);
                case 42:
                  return _context.finish(33);
                case 43:
                  onDataLoad = this.layer && this.layer.props.onDataLoad;
                  if (onDataLoad) {
                    onDataLoad(data, {
                      propName,
                      layer: this.layer
                    });
                  }
                case 45:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[8, 29, 33, 43], [34, , 38, 42]]);
        }));
        function _resolveAsyncIterable(_x, _x2) {
          return _resolveAsyncIterable2.apply(this, arguments);
        }
        return _resolveAsyncIterable;
      }()
    }, {
      key: "_postProcessValue",
      value: function _postProcessValue(asyncProp, value17) {
        var propType = asyncProp.type;
        if (propType) {
          if (propType.release) {
            propType.release(asyncProp.resolvedValue, propType, this.component);
          }
          if (propType.transform) {
            return propType.transform(value17, propType, this.component);
          }
        }
        return value17;
      }
    }, {
      key: "_createAsyncPropData",
      value: function _createAsyncPropData(propName, defaultValue) {
        var asyncProp = this.asyncProps[propName];
        if (!asyncProp) {
          var propTypes = this.component && this.component.constructor._propTypes;
          this.asyncProps[propName] = {
            type: propTypes && propTypes[propName],
            lastValue: null,
            resolvedValue: defaultValue,
            pendingLoadCount: 0,
            resolvedLoadCount: 0
          };
        }
      }
    }]);
    return ComponentState2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lifecycle/component.js
  var ASYNC_ORIGINAL3 = PROP_SYMBOLS.ASYNC_ORIGINAL;
  var ASYNC_RESOLVED3 = PROP_SYMBOLS.ASYNC_RESOLVED;
  var ASYNC_DEFAULTS3 = PROP_SYMBOLS.ASYNC_DEFAULTS;
  var defaultProps = {};
  var counter = 0;
  var Component = function() {
    function Component2() {
      _classCallCheck(this, Component2);
      this.props = createProps.apply(this, arguments);
      this.id = this.props.id;
      this.count = counter++;
      this.lifecycle = LIFECYCLE.NO_STATE;
      this.parent = null;
      this.context = null;
      this.state = null;
      this.internalState = null;
      Object.seal(this);
    }
    _createClass(Component2, [{
      key: "clone",
      value: function clone3(newProps) {
        var props = this.props;
        var asyncProps = {};
        for (var key in props[ASYNC_DEFAULTS3]) {
          if (key in props[ASYNC_RESOLVED3]) {
            asyncProps[key] = props[ASYNC_RESOLVED3][key];
          } else if (key in props[ASYNC_ORIGINAL3]) {
            asyncProps[key] = props[ASYNC_ORIGINAL3][key];
          }
        }
        return new this.constructor(Object.assign({}, props, asyncProps, newProps));
      }
    }, {
      key: "_initState",
      value: function _initState() {
        this.internalState = new ComponentState({});
      }
    }, {
      key: "stats",
      get: function get2() {
        return this.internalState.stats;
      }
    }]);
    return Component2;
  }();
  Component.componentName = "Component";
  Component.defaultProps = defaultProps;

  // node_modules/@deck.gl/core/dist/esm/lib/layer-state.js
  function _createSuper27(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct28();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct28() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var LayerState = function(_ComponentState) {
    _inherits(LayerState2, _ComponentState);
    var _super = _createSuper27(LayerState2);
    function LayerState2(_ref) {
      var _this;
      var attributeManager = _ref.attributeManager, layer = _ref.layer;
      _classCallCheck(this, LayerState2);
      _this = _super.call(this, layer);
      _this.attributeManager = attributeManager;
      _this.model = null;
      _this.needsRedraw = true;
      _this.subLayers = null;
      _this.usesPickingColorCache = false;
      return _this;
    }
    _createClass(LayerState2, [{
      key: "layer",
      get: function get2() {
        return this.component;
      },
      set: function set2(layer) {
        this.component = layer;
      }
    }]);
    return LayerState2;
  }(ComponentState);

  // node_modules/@deck.gl/core/dist/esm/lib/layer.js
  function _createForOfIteratorHelper34(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray35(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray35(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray35(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray35(o, minLen);
  }
  function _arrayLikeToArray35(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper28(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct29();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct29() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var TRACE_CHANGE_FLAG = "layer.changeFlag";
  var TRACE_INITIALIZE = "layer.initialize";
  var TRACE_UPDATE = "layer.update";
  var TRACE_FINALIZE = "layer.finalize";
  var TRACE_MATCHED = "layer.matched";
  var MAX_PICKING_COLOR_CACHE_SIZE = Math.pow(2, 24) - 1;
  var EMPTY_ARRAY2 = Object.freeze([]);
  var areViewportsEqual = memoize(function(_ref) {
    var oldViewport = _ref.oldViewport, viewport3 = _ref.viewport;
    return oldViewport.equals(viewport3);
  });
  var pickingColorCache = new Uint8ClampedArray(0);
  var defaultProps2 = {
    data: {
      type: "data",
      value: EMPTY_ARRAY2,
      async: true
    },
    dataComparator: null,
    _dataDiff: {
      type: "function",
      value: function value(data) {
        return data && data.__diff;
      },
      compare: false,
      optional: true
    },
    dataTransform: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    onDataLoad: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    fetch: {
      type: "function",
      value: function value2(url, _ref2) {
        var propName = _ref2.propName, layer = _ref2.layer;
        var resourceManager = layer.context.resourceManager;
        var loadOptions = layer.getLoadOptions();
        var loaders = layer.props.loaders;
        var inResourceManager = resourceManager.contains(url);
        if (!inResourceManager && !loadOptions) {
          resourceManager.add({
            resourceId: url,
            data: load(url, loaders),
            persistent: false
          });
          inResourceManager = true;
        }
        if (inResourceManager) {
          return resourceManager.subscribe({
            resourceId: url,
            onChange: function onChange(data) {
              return layer.internalState.reloadAsyncProp(propName, data);
            },
            consumerId: layer.id,
            requestId: propName
          });
        }
        return load(url, loaders, loadOptions);
      },
      compare: false
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    onHover: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    onClick: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    onDragStart: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    onDrag: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    onDragEnd: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    },
    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin: {
      type: "array",
      value: [0, 0, 0],
      compare: true
    },
    modelMatrix: {
      type: "array",
      value: null,
      compare: true,
      optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {},
    transitions: null,
    extensions: [],
    loaders: {
      type: "array",
      value: [],
      optional: true,
      compare: true
    },
    getPolygonOffset: {
      type: "function",
      value: function value3(_ref3) {
        var layerIndex = _ref3.layerIndex;
        return [0, -layerIndex * 100];
      },
      compare: false
    },
    highlightedObjectIndex: -1,
    autoHighlight: false,
    highlightColor: {
      type: "accessor",
      value: [0, 0, 128, 128]
    }
  };
  var Layer = function(_Component) {
    _inherits(Layer2, _Component);
    var _super = _createSuper28(Layer2);
    function Layer2() {
      _classCallCheck(this, Layer2);
      return _super.apply(this, arguments);
    }
    _createClass(Layer2, [{
      key: "toString",
      value: function toString() {
        var className = this.constructor.layerName || this.constructor.name;
        return "".concat(className, "({id: '").concat(this.props.id, "'})");
      }
    }, {
      key: "setState",
      value: function setState(updateObject) {
        this.setChangeFlags({
          stateChanged: true
        });
        Object.assign(this.state, updateObject);
        this.setNeedsRedraw();
      }
    }, {
      key: "setNeedsRedraw",
      value: function setNeedsRedraw() {
        var redraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (this.internalState) {
          this.internalState.needsRedraw = redraw;
        }
      }
    }, {
      key: "setNeedsUpdate",
      value: function setNeedsUpdate() {
        this.context.layerManager.setNeedsUpdate(String(this));
        this.internalState.needsUpdate = true;
      }
    }, {
      key: "getNeedsRedraw",
      value: function getNeedsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        return this._getNeedsRedraw(opts);
      }
    }, {
      key: "needsUpdate",
      value: function needsUpdate() {
        return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
      }
    }, {
      key: "hasUniformTransition",
      value: function hasUniformTransition() {
        return this.internalState.uniformTransitions.active;
      }
    }, {
      key: "isPickable",
      value: function isPickable() {
        return this.props.pickable && this.props.visible;
      }
    }, {
      key: "getModels",
      value: function getModels() {
        return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
      }
    }, {
      key: "getAttributeManager",
      value: function getAttributeManager() {
        return this.internalState && this.internalState.attributeManager;
      }
    }, {
      key: "getCurrentLayer",
      value: function getCurrentLayer() {
        return this.internalState && this.internalState.layer;
      }
    }, {
      key: "getLoadOptions",
      value: function getLoadOptions() {
        return this.props.loadOptions;
      }
    }, {
      key: "project",
      value: function project2(xyz) {
        var viewport3 = this.context.viewport;
        var worldPosition = getWorldPosition(xyz, {
          viewport: viewport3,
          modelMatrix: this.props.modelMatrix,
          coordinateOrigin: this.props.coordinateOrigin,
          coordinateSystem: this.props.coordinateSystem
        });
        var _worldToPixels = worldToPixels(worldPosition, viewport3.pixelProjectionMatrix), _worldToPixels2 = _slicedToArray(_worldToPixels, 3), x = _worldToPixels2[0], y = _worldToPixels2[1], z = _worldToPixels2[2];
        return xyz.length === 2 ? [x, y] : [x, y, z];
      }
    }, {
      key: "unproject",
      value: function unproject(xy) {
        var viewport3 = this.context.viewport;
        return viewport3.unproject(xy);
      }
    }, {
      key: "projectPosition",
      value: function projectPosition2(xyz) {
        return projectPosition(xyz, {
          viewport: this.context.viewport,
          modelMatrix: this.props.modelMatrix,
          coordinateOrigin: this.props.coordinateOrigin,
          coordinateSystem: this.props.coordinateSystem
        });
      }
    }, {
      key: "use64bitPositions",
      value: function use64bitPositions() {
        var coordinateSystem = this.props.coordinateSystem;
        return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
      }
    }, {
      key: "onHover",
      value: function onHover(info, pickingEvent) {
        if (this.props.onHover) {
          return this.props.onHover(info, pickingEvent);
        }
        return false;
      }
    }, {
      key: "onClick",
      value: function onClick(info, pickingEvent) {
        if (this.props.onClick) {
          return this.props.onClick(info, pickingEvent);
        }
        return false;
      }
    }, {
      key: "nullPickingColor",
      value: function nullPickingColor() {
        return [0, 0, 0];
      }
    }, {
      key: "encodePickingColor",
      value: function encodePickingColor(i) {
        var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        target[0] = i + 1 & 255;
        target[1] = i + 1 >> 8 & 255;
        target[2] = i + 1 >> 8 >> 8 & 255;
        return target;
      }
    }, {
      key: "decodePickingColor",
      value: function decodePickingColor(color) {
        assert8(color instanceof Uint8Array);
        var _color = _slicedToArray(color, 3), i1 = _color[0], i2 = _color[1], i3 = _color[2];
        var index = i1 + i2 * 256 + i3 * 65536 - 1;
        return index;
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        throw new Error("Layer ".concat(this, " has not defined initializeState"));
      }
    }, {
      key: "getShaders",
      value: function getShaders(shaders) {
        var _iterator = _createForOfIteratorHelper34(this.props.extensions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var extension = _step.value;
            shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return shaders;
      }
    }, {
      key: "shouldUpdateState",
      value: function shouldUpdateState(_ref4) {
        var oldProps = _ref4.oldProps, props = _ref4.props, context = _ref4.context, changeFlags = _ref4.changeFlags;
        return changeFlags.propsOrDataChanged;
      }
    }, {
      key: "updateState",
      value: function updateState(_ref5) {
        var oldProps = _ref5.oldProps, props = _ref5.props, context = _ref5.context, changeFlags = _ref5.changeFlags;
        var attributeManager = this.getAttributeManager();
        if (changeFlags.dataChanged && attributeManager) {
          var dataChanged = changeFlags.dataChanged;
          if (Array.isArray(dataChanged)) {
            var _iterator2 = _createForOfIteratorHelper34(dataChanged), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var dataRange = _step2.value;
                attributeManager.invalidateAll(dataRange);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          } else {
            attributeManager.invalidateAll();
          }
        }
        var neededPickingBuffer = oldProps.highlightedObjectIndex >= 0 || oldProps.pickable;
        var needPickingBuffer = props.highlightedObjectIndex >= 0 || props.pickable;
        if (neededPickingBuffer !== needPickingBuffer && attributeManager) {
          var _attributeManager$att = attributeManager.attributes, pickingColors = _attributeManager$att.pickingColors, instancePickingColors = _attributeManager$att.instancePickingColors;
          var pickingColorsAttribute = pickingColors || instancePickingColors;
          if (pickingColorsAttribute) {
            if (needPickingBuffer && pickingColorsAttribute.constant) {
              pickingColorsAttribute.constant = false;
              attributeManager.invalidate(pickingColorsAttribute.id);
            }
            if (!pickingColorsAttribute.value && !needPickingBuffer) {
              pickingColorsAttribute.constant = true;
              pickingColorsAttribute.value = [0, 0, 0];
            }
          }
        }
      }
    }, {
      key: "finalizeState",
      value: function finalizeState() {
        var _iterator3 = _createForOfIteratorHelper34(this.getModels()), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var model = _step3.value;
            model["delete"]();
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        var attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.finalize();
        }
        this.context.resourceManager.unsubscribe({
          consumerId: this.id
        });
        this.internalState.uniformTransitions.clear();
        this.internalState.finalize();
      }
    }, {
      key: "draw",
      value: function draw(opts) {
        var _iterator4 = _createForOfIteratorHelper34(this.getModels()), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var model = _step4.value;
            model.draw(opts);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(_ref6) {
        var info = _ref6.info, mode = _ref6.mode;
        var index = info.index;
        if (index >= 0) {
          if (Array.isArray(this.props.data)) {
            info.object = this.props.data[index];
          }
        }
        return info;
      }
    }, {
      key: "activateViewport",
      value: function activateViewport(viewport3) {
        var oldViewport = this.internalState.viewport;
        this.internalState.viewport = viewport3;
        if (!oldViewport || !areViewportsEqual({
          oldViewport,
          viewport: viewport3
        })) {
          this.setChangeFlags({
            viewportChanged: true
          });
          if (this.isComposite) {
            if (this.needsUpdate()) {
              this.setNeedsUpdate();
            }
          } else {
            this._update();
          }
        }
      }
    }, {
      key: "invalidateAttribute",
      value: function invalidateAttribute() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
        var diffReason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        var attributeManager = this.getAttributeManager();
        if (!attributeManager) {
          return;
        }
        if (name === "all") {
          attributeManager.invalidateAll();
        } else {
          attributeManager.invalidate(name);
        }
      }
    }, {
      key: "updateAttributes",
      value: function updateAttributes(changedAttributes) {
        var _iterator5 = _createForOfIteratorHelper34(this.getModels()), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var model = _step5.value;
            this._setModelAttributes(model, changedAttributes);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    }, {
      key: "_updateAttributes",
      value: function _updateAttributes(props) {
        var attributeManager = this.getAttributeManager();
        if (!attributeManager) {
          return;
        }
        var numInstances = this.getNumInstances(props);
        var startIndices = this.getStartIndices(props);
        attributeManager.update({
          data: props.data,
          numInstances,
          startIndices,
          props,
          transitions: props.transitions,
          buffers: props.data.attributes,
          context: this,
          ignoreUnknownAttributes: true
        });
        var changedAttributes = attributeManager.getChangedAttributes({
          clearChangedFlags: true
        });
        this.updateAttributes(changedAttributes);
      }
    }, {
      key: "_updateAttributeTransition",
      value: function _updateAttributeTransition() {
        var attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.updateTransition();
        }
      }
    }, {
      key: "_updateUniformTransition",
      value: function _updateUniformTransition() {
        var uniformTransitions = this.internalState.uniformTransitions;
        if (uniformTransitions.active) {
          var propsInTransition = uniformTransitions.update();
          var props = Object.create(this.props);
          for (var key in propsInTransition) {
            Object.defineProperty(props, key, {
              value: propsInTransition[key]
            });
          }
          return props;
        }
        return this.props;
      }
    }, {
      key: "calculateInstancePickingColors",
      value: function calculateInstancePickingColors(attribute, _ref7) {
        var numInstances = _ref7.numInstances;
        if (attribute.constant) {
          return;
        }
        var cacheSize = Math.floor(pickingColorCache.length / 3);
        this.internalState.usesPickingColorCache = true;
        if (cacheSize < numInstances) {
          if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
            log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
          }
          pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
            size: 3,
            copy: true,
            maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
          });
          var newCacheSize = Math.floor(pickingColorCache.length / 3);
          var pickingColor = [];
          for (var i = cacheSize; i < newCacheSize; i++) {
            this.encodePickingColor(i, pickingColor);
            pickingColorCache[i * 3 + 0] = pickingColor[0];
            pickingColorCache[i * 3 + 1] = pickingColor[1];
            pickingColorCache[i * 3 + 2] = pickingColor[2];
          }
        }
        attribute.value = pickingColorCache.subarray(0, numInstances * 3);
      }
    }, {
      key: "_setModelAttributes",
      value: function _setModelAttributes(model, changedAttributes) {
        var attributeManager = this.getAttributeManager();
        var excludeAttributes = model.userData.excludeAttributes || {};
        var shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
        model.setAttributes(shaderAttributes);
      }
    }, {
      key: "disablePickingIndex",
      value: function disablePickingIndex(objectIndex) {
        this._disablePickingIndex(objectIndex);
      }
    }, {
      key: "_disablePickingIndex",
      value: function _disablePickingIndex(objectIndex) {
        var _this$getAttributeMan = this.getAttributeManager().attributes, pickingColors = _this$getAttributeMan.pickingColors, instancePickingColors = _this$getAttributeMan.instancePickingColors;
        var colors = pickingColors || instancePickingColors;
        var start2 = colors.getVertexOffset(objectIndex);
        var end = colors.getVertexOffset(objectIndex + 1);
        colors.buffer.subData({
          data: new Uint8Array(end - start2),
          offset: start2
        });
      }
    }, {
      key: "restorePickingColors",
      value: function restorePickingColors() {
        var _this$getAttributeMan2 = this.getAttributeManager().attributes, pickingColors = _this$getAttributeMan2.pickingColors, instancePickingColors = _this$getAttributeMan2.instancePickingColors;
        var colors = pickingColors || instancePickingColors;
        if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
          colors.value = pickingColorCache.subarray(0, colors.value.length);
        }
        colors.updateSubBuffer({
          startOffset: 0
        });
      }
    }, {
      key: "getNumInstances",
      value: function getNumInstances(props) {
        props = props || this.props;
        if (props.numInstances !== void 0) {
          return props.numInstances;
        }
        if (this.state && this.state.numInstances !== void 0) {
          return this.state.numInstances;
        }
        return count2(props.data);
      }
    }, {
      key: "getStartIndices",
      value: function getStartIndices(props) {
        props = props || this.props;
        if (props.startIndices !== void 0) {
          return props.startIndices;
        }
        if (this.state && this.state.startIndices) {
          return this.state.startIndices;
        }
        return null;
      }
    }, {
      key: "_initialize",
      value: function _initialize() {
        debug(TRACE_INITIALIZE, this);
        this._initState();
        this.initializeState(this.context);
        var _iterator6 = _createForOfIteratorHelper34(this.props.extensions), _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
            var extension = _step6.value;
            extension.initializeState.call(this, this.context, extension);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        this.setChangeFlags({
          dataChanged: true,
          propsChanged: true,
          viewportChanged: true,
          extensionsChanged: true
        });
        this._updateState();
      }
    }, {
      key: "_update",
      value: function _update() {
        var stateNeedsUpdate = this.needsUpdate();
        debug(TRACE_UPDATE, this, stateNeedsUpdate);
        if (stateNeedsUpdate) {
          this._updateState();
        }
      }
    }, {
      key: "_updateState",
      value: function _updateState() {
        var currentProps = this.props;
        var currentViewport = this.context.viewport;
        var propsInTransition = this._updateUniformTransition();
        this.internalState.propsInTransition = propsInTransition;
        this.context.viewport = this.internalState.viewport || currentViewport;
        this.props = propsInTransition;
        try {
          var updateParams = this._getUpdateParams();
          var oldModels = this.getModels();
          if (this.context.gl) {
            this.updateState(updateParams);
          } else {
            try {
              this.updateState(updateParams);
            } catch (error2) {
            }
          }
          var _iterator7 = _createForOfIteratorHelper34(this.props.extensions), _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
              var extension = _step7.value;
              extension.updateState.call(this, updateParams, extension);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          var modelChanged = this.getModels()[0] !== oldModels[0];
          this._updateModules(updateParams, modelChanged);
          if (this.isComposite) {
            this._renderLayers(updateParams);
          } else {
            this.setNeedsRedraw();
            this._updateAttributes(this.props);
            if (this.state.model) {
              this.state.model.setInstanceCount(this.getNumInstances());
            }
          }
        } finally {
          this.context.viewport = currentViewport;
          this.props = currentProps;
          this.clearChangeFlags();
          this.internalState.needsUpdate = false;
          this.internalState.resetOldProps();
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        debug(TRACE_FINALIZE, this);
        assert8(this.internalState && this.state);
        this.finalizeState(this.context);
        var _iterator8 = _createForOfIteratorHelper34(this.props.extensions), _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
            var extension = _step8.value;
            extension.finalizeState.call(this, extension);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }
    }, {
      key: "drawLayer",
      value: function drawLayer(_ref8) {
        var _this = this;
        var _ref8$moduleParameter = _ref8.moduleParameters, moduleParameters = _ref8$moduleParameter === void 0 ? null : _ref8$moduleParameter, _ref8$uniforms = _ref8.uniforms, uniforms = _ref8$uniforms === void 0 ? {} : _ref8$uniforms, _ref8$parameters = _ref8.parameters, parameters = _ref8$parameters === void 0 ? {} : _ref8$parameters;
        this._updateAttributeTransition();
        var currentProps = this.props;
        this.props = this.internalState.propsInTransition || currentProps;
        var opacity = this.props.opacity;
        uniforms.opacity = Math.pow(opacity, 1 / 2.2);
        try {
          if (moduleParameters) {
            this.setModuleParameters(moduleParameters);
          }
          var getPolygonOffset = this.props.getPolygonOffset;
          var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
          setParameters(this.context.gl, {
            polygonOffset: offsets
          });
          withParameters(this.context.gl, parameters, function() {
            var opts = {
              moduleParameters,
              uniforms,
              parameters,
              context: _this.context
            };
            var _iterator9 = _createForOfIteratorHelper34(_this.props.extensions), _step9;
            try {
              for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                var extension = _step9.value;
                extension.draw.call(_this, opts, extension);
              }
            } catch (err) {
              _iterator9.e(err);
            } finally {
              _iterator9.f();
            }
            _this.draw(opts);
          });
        } finally {
          this.props = currentProps;
        }
      }
    }, {
      key: "getChangeFlags",
      value: function getChangeFlags() {
        return this.internalState.changeFlags;
      }
    }, {
      key: "setChangeFlags",
      value: function setChangeFlags(flags) {
        var changeFlags = this.internalState.changeFlags;
        for (var key in flags) {
          if (flags[key]) {
            var flagChanged = false;
            switch (key) {
              case "dataChanged":
                if (Array.isArray(changeFlags[key])) {
                  changeFlags[key] = Array.isArray(flags[key]) ? changeFlags[key].concat(flags[key]) : flags[key];
                  flagChanged = true;
                }
              default:
                if (!changeFlags[key]) {
                  changeFlags[key] = flags[key];
                  flagChanged = true;
                }
            }
            if (flagChanged) {
              debug(TRACE_CHANGE_FLAG, this, key, flags);
            }
          }
        }
        var propsOrDataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged;
        changeFlags.propsOrDataChanged = propsOrDataChanged;
        changeFlags.somethingChanged = propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
      }
    }, {
      key: "clearChangeFlags",
      value: function clearChangeFlags() {
        this.internalState.changeFlags = {
          dataChanged: false,
          propsChanged: false,
          updateTriggersChanged: false,
          viewportChanged: false,
          stateChanged: false,
          extensionsChanged: false,
          propsOrDataChanged: false,
          somethingChanged: false
        };
      }
    }, {
      key: "diffProps",
      value: function diffProps2(newProps, oldProps) {
        var changeFlags = diffProps(newProps, oldProps);
        if (changeFlags.updateTriggersChanged) {
          for (var key in changeFlags.updateTriggersChanged) {
            if (changeFlags.updateTriggersChanged[key]) {
              this.invalidateAttribute(key);
            }
          }
        }
        if (changeFlags.transitionsChanged) {
          for (var _key in changeFlags.transitionsChanged) {
            this.internalState.uniformTransitions.add(_key, oldProps[_key], newProps[_key], newProps.transitions[_key]);
          }
        }
        return this.setChangeFlags(changeFlags);
      }
    }, {
      key: "validateProps",
      value: function validateProps2() {
        validateProps(this.props);
      }
    }, {
      key: "setModuleParameters",
      value: function setModuleParameters(moduleParameters) {
        var _iterator10 = _createForOfIteratorHelper34(this.getModels()), _step10;
        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
            var model = _step10.value;
            model.updateModuleSettings(moduleParameters);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      }
    }, {
      key: "_updateModules",
      value: function _updateModules(_ref9, forceUpdate) {
        var props = _ref9.props, oldProps = _ref9.oldProps;
        var autoHighlight = props.autoHighlight, highlightedObjectIndex = props.highlightedObjectIndex, highlightColor = props.highlightColor;
        if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
          var parameters = {};
          if (!autoHighlight) {
            parameters.pickingSelectedColor = null;
          }
          if (Array.isArray(highlightColor)) {
            parameters.pickingHighlightColor = highlightColor;
          }
          if (Number.isInteger(highlightedObjectIndex)) {
            parameters.pickingSelectedColor = highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
          }
          this.setModuleParameters(parameters);
        }
      }
    }, {
      key: "_getUpdateParams",
      value: function _getUpdateParams() {
        return {
          props: this.props,
          oldProps: this.internalState.getOldProps(),
          context: this.context,
          changeFlags: this.internalState.changeFlags
        };
      }
    }, {
      key: "_getNeedsRedraw",
      value: function _getNeedsRedraw(opts) {
        if (!this.internalState) {
          return false;
        }
        var redraw = false;
        redraw = redraw || this.internalState.needsRedraw && this.id;
        this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
        var attributeManager = this.getAttributeManager();
        var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);
        redraw = redraw || attributeManagerNeedsRedraw;
        return redraw;
      }
    }, {
      key: "_getAttributeManager",
      value: function _getAttributeManager() {
        return new AttributeManager(this.context.gl, {
          id: this.props.id,
          stats: this.context.stats,
          timeline: this.context.timeline
        });
      }
    }, {
      key: "_initState",
      value: function _initState() {
        assert8(!this.internalState && !this.state);
        assert8(isFinite(this.props.coordinateSystem), "".concat(this.id, ": invalid coordinateSystem"));
        var attributeManager = this._getAttributeManager();
        if (attributeManager) {
          attributeManager.addInstanced({
            instancePickingColors: {
              type: 5121,
              size: 3,
              noAlloc: true,
              update: this.calculateInstancePickingColors
            }
          });
        }
        this.internalState = new LayerState({
          attributeManager,
          layer: this
        });
        this.clearChangeFlags();
        this.state = {};
        Object.defineProperty(this.state, "attributeManager", {
          get: function get2() {
            log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()");
            return attributeManager;
          }
        });
        this.internalState.layer = this;
        this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
        this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
        this.internalState.setAsyncProps(this.props);
      }
    }, {
      key: "_transferState",
      value: function _transferState(oldLayer) {
        debug(TRACE_MATCHED, this, this === oldLayer);
        var state = oldLayer.state, internalState = oldLayer.internalState;
        assert8(state && internalState);
        if (this === oldLayer) {
          return;
        }
        this.internalState = internalState;
        this.internalState.layer = this;
        this.state = state;
        this.internalState.setAsyncProps(this.props);
        this.diffProps(this.props, this.internalState.getOldProps());
      }
    }, {
      key: "_onAsyncPropUpdated",
      value: function _onAsyncPropUpdated() {
        this.diffProps(this.props, this.internalState.getOldProps());
        this.setNeedsUpdate();
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        return this.internalState && !this.internalState.isAsyncPropLoading();
      }
    }, {
      key: "wrapLongitude",
      get: function get2() {
        return this.props.wrapLongitude;
      }
    }]);
    return Layer2;
  }(Component);
  Layer.layerName = "Layer";
  Layer.defaultProps = defaultProps2;

  // node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js
  function _createForOfIteratorHelper35(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray36(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray36(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray36(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray36(o, minLen);
  }
  function _arrayLikeToArray36(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var Resource2 = function() {
    function Resource3(id, data, context) {
      _classCallCheck(this, Resource3);
      this.id = id;
      this.context = context;
      this._loadCount = 0;
      this._subscribers = new Set();
      this.setData(data);
    }
    _createClass(Resource3, [{
      key: "subscribe",
      value: function subscribe(consumer) {
        this._subscribers.add(consumer);
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(consumer) {
        this._subscribers["delete"](consumer);
      }
    }, {
      key: "inUse",
      value: function inUse() {
        return this._subscribers.size > 0;
      }
    }, {
      key: "delete",
      value: function _delete() {
      }
    }, {
      key: "getData",
      value: function getData() {
        var _this = this;
        return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(function() {
          return _this.getData();
        });
      }
    }, {
      key: "setData",
      value: function setData(data, forceUpdate) {
        var _this2 = this;
        if (data === this._data && !forceUpdate) {
          return;
        }
        this._data = data;
        var loadCount = ++this._loadCount;
        var loader = data;
        if (typeof data === "string") {
          loader = load(data);
        }
        if (loader instanceof Promise) {
          this.isLoaded = false;
          this._loader = loader.then(function(result) {
            if (_this2._loadCount === loadCount) {
              _this2.isLoaded = true;
              _this2._error = null;
              _this2._content = result;
            }
          })["catch"](function(error2) {
            if (_this2._loadCount === loadCount) {
              _this2.isLoaded = true;
              _this2._error = error2 || true;
            }
          });
        } else {
          this.isLoaded = true;
          this._error = null;
          this._content = data;
        }
        var _iterator = _createForOfIteratorHelper35(this._subscribers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var subscriber = _step.value;
            subscriber.onChange(this.getData());
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }]);
    return Resource3;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js
  var ResourceManager = function() {
    function ResourceManager2(_ref) {
      var gl = _ref.gl, protocol = _ref.protocol;
      _classCallCheck(this, ResourceManager2);
      this.protocol = protocol || "resource://";
      this._context = {
        gl,
        resourceManager: this
      };
      this._resources = {};
      this._consumers = {};
      this._pruneRequest = null;
    }
    _createClass(ResourceManager2, [{
      key: "contains",
      value: function contains(resourceId) {
        if (resourceId.startsWith(this.protocol)) {
          return true;
        }
        return resourceId in this._resources;
      }
    }, {
      key: "add",
      value: function add6(_ref2) {
        var resourceId = _ref2.resourceId, data = _ref2.data, _ref2$forceUpdate = _ref2.forceUpdate, forceUpdate = _ref2$forceUpdate === void 0 ? false : _ref2$forceUpdate, _ref2$persistent = _ref2.persistent, persistent = _ref2$persistent === void 0 ? true : _ref2$persistent;
        var res = this._resources[resourceId];
        if (res) {
          res.setData(data, forceUpdate);
        } else {
          res = new Resource2(resourceId, data, this._context);
          this._resources[resourceId] = res;
        }
        res.persistent = persistent;
      }
    }, {
      key: "remove",
      value: function remove(resourceId) {
        var res = this._resources[resourceId];
        if (res) {
          res["delete"]();
          delete this._resources[resourceId];
        }
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(_ref3) {
        var consumerId = _ref3.consumerId;
        var consumer = this._consumers[consumerId];
        if (consumer) {
          for (var requestId in consumer) {
            var request = consumer[requestId];
            if (request.resource) {
              request.resource.unsubscribe(request);
            }
          }
          delete this._consumers[consumerId];
          this.prune();
        }
      }
    }, {
      key: "subscribe",
      value: function subscribe(_ref4) {
        var resourceId = _ref4.resourceId, onChange = _ref4.onChange, consumerId = _ref4.consumerId, _ref4$requestId = _ref4.requestId, requestId = _ref4$requestId === void 0 ? "default" : _ref4$requestId;
        var resources = this._resources, protocol = this.protocol;
        if (resourceId.startsWith(protocol)) {
          resourceId = resourceId.replace(protocol, "");
          if (!resources[resourceId]) {
            this.add({
              resourceId,
              data: null,
              persistent: false
            });
          }
        }
        var res = resources[resourceId];
        this._track(consumerId, requestId, res, onChange);
        if (res) {
          return res.getData();
        }
        return void 0;
      }
    }, {
      key: "prune",
      value: function prune() {
        var _this = this;
        if (!this._pruneRequest) {
          this._pruneRequest = setTimeout(function() {
            return _this._prune();
          }, 0);
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        for (var key in this._resources) {
          this._resources[key]["delete"]();
        }
      }
    }, {
      key: "_track",
      value: function _track(consumerId, requestId, resource, onChange) {
        var consumers = this._consumers;
        var consumer = consumers[consumerId] = consumers[consumerId] || {};
        var request = consumer[requestId] || {};
        if (request.resource) {
          request.resource.unsubscribe(request);
          request.resource = null;
          this.prune();
        }
        if (resource) {
          consumer[requestId] = request;
          request.onChange = onChange;
          request.resource = resource;
          resource.subscribe(request);
        }
      }
    }, {
      key: "_prune",
      value: function _prune() {
        this._pruneRequest = null;
        for (var _i = 0, _Object$keys = Object.keys(this._resources); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          var res = this._resources[key];
          if (!res.persistent && !res.inUse()) {
            res["delete"]();
            delete this._resources[key];
          }
        }
      }
    }]);
    return ResourceManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js
  function _createForOfIteratorHelper36(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray37(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray37(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray37(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray37(o, minLen);
  }
  function _arrayLikeToArray37(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var TRACE_SET_LAYERS = "layerManager.setLayers";
  var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
  var INITIAL_CONTEXT = Object.seal({
    layerManager: null,
    resourceManager: null,
    deck: null,
    gl: null,
    stats: null,
    shaderCache: null,
    pickingFBO: null,
    mousePosition: null,
    userData: {}
  });
  var layerName = function layerName2(layer) {
    return layer instanceof Layer ? "".concat(layer) : !layer ? "null" : "invalid";
  };
  var LayerManager = function() {
    function LayerManager2(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, deck = _ref.deck, stats = _ref.stats, viewport3 = _ref.viewport, timeline = _ref.timeline;
      _classCallCheck(this, LayerManager2);
      this.lastRenderedLayers = [];
      this.layers = [];
      this.resourceManager = new ResourceManager({
        gl,
        protocol: "deck://"
      });
      this.context = Object.assign({}, INITIAL_CONTEXT, {
        layerManager: this,
        gl,
        deck,
        programManager: gl && createProgramManager(gl),
        stats: stats || new Stats({
          id: "deck.gl"
        }),
        viewport: viewport3 || new Viewport({
          id: "DEFAULT-INITIAL-VIEWPORT"
        }),
        timeline: timeline || new Timeline(),
        resourceManager: this.resourceManager
      });
      this._needsRedraw = "Initial render";
      this._needsUpdate = false;
      this._debug = false;
      this._onError = null;
      this.activateViewport = this.activateViewport.bind(this);
      Object.seal(this);
    }
    _createClass(LayerManager2, [{
      key: "finalize",
      value: function finalize() {
        this.resourceManager.finalize();
        var _iterator = _createForOfIteratorHelper36(this.layers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var layer = _step.value;
            this._finalizeLayer(layer);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "needsRedraw",
      value: function needsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        var redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        var _iterator2 = _createForOfIteratorHelper36(this.layers), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var layer = _step2.value;
            var layerNeedsRedraw = layer.getNeedsRedraw(opts);
            redraw = redraw || layerNeedsRedraw;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return redraw;
      }
    }, {
      key: "needsUpdate",
      value: function needsUpdate() {
        return this._needsUpdate;
      }
    }, {
      key: "setNeedsRedraw",
      value: function setNeedsRedraw(reason) {
        this._needsRedraw = this._needsRedraw || reason;
      }
    }, {
      key: "setNeedsUpdate",
      value: function setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
      }
    }, {
      key: "getLayers",
      value: function getLayers() {
        var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$layerIds = _ref2.layerIds, layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
        return layerIds ? this.layers.filter(function(layer) {
          return layerIds.find(function(layerId) {
            return layer.id.indexOf(layerId) === 0;
          });
        }) : this.layers;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("onError" in props) {
          this._onError = props.onError;
        }
        if ("debug" in props) {
          this._debug = props.debug;
        }
        if ("userData" in props) {
          this.context.userData = props.userData;
        }
        if ("layers" in props) {
          this.setLayers(props.layers);
        }
      }
    }, {
      key: "setLayers",
      value: function setLayers(newLayers) {
        var forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var shouldUpdate = forceUpdate || newLayers !== this.lastRenderedLayers;
        debug(TRACE_SET_LAYERS, this, shouldUpdate, newLayers);
        if (!shouldUpdate) {
          return this;
        }
        this.lastRenderedLayers = newLayers;
        newLayers = flatten(newLayers, Boolean);
        var _iterator3 = _createForOfIteratorHelper36(newLayers), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var layer = _step3.value;
            layer.context = this.context;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        this._updateLayers(this.layers, newLayers);
        return this;
      }
    }, {
      key: "updateLayers",
      value: function updateLayers() {
        var reason = this.needsUpdate();
        if (reason) {
          this.setNeedsRedraw("updating layers: ".concat(reason));
          var forceUpdate = true;
          this.setLayers(this.lastRenderedLayers, forceUpdate);
        }
      }
    }, {
      key: "activateViewport",
      value: function activateViewport(viewport3) {
        debug(TRACE_ACTIVATE_VIEWPORT, this, viewport3);
        if (viewport3) {
          this.context.viewport = viewport3;
        }
        return this;
      }
    }, {
      key: "_handleError",
      value: function _handleError(stage, error2, layer) {
        if (this._onError) {
          this._onError(error2, layer);
        } else {
          log_default.error("error during ".concat(stage, " of ").concat(layerName(layer)), error2)();
        }
      }
    }, {
      key: "_updateLayers",
      value: function _updateLayers(oldLayers, newLayers) {
        var oldLayerMap = {};
        var _iterator4 = _createForOfIteratorHelper36(oldLayers), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var oldLayer = _step4.value;
            if (oldLayerMap[oldLayer.id]) {
              log_default.warn("Multiple old layers with same id ".concat(layerName(oldLayer)))();
            } else {
              oldLayerMap[oldLayer.id] = oldLayer;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        var generatedLayers = [];
        this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
        this._finalizeOldLayers(oldLayerMap);
        var needsUpdate = false;
        for (var _i = 0, _generatedLayers = generatedLayers; _i < _generatedLayers.length; _i++) {
          var layer = _generatedLayers[_i];
          if (layer.hasUniformTransition()) {
            needsUpdate = true;
            break;
          }
        }
        this._needsUpdate = needsUpdate;
        this.layers = generatedLayers;
      }
    }, {
      key: "_updateSublayersRecursively",
      value: function _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
        var _iterator5 = _createForOfIteratorHelper36(newLayers), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var newLayer = _step5.value;
            newLayer.context = this.context;
            var oldLayer = oldLayerMap[newLayer.id];
            if (oldLayer === null) {
              log_default.warn("Multiple new layers with same id ".concat(layerName(newLayer)))();
            }
            oldLayerMap[newLayer.id] = null;
            var sublayers = null;
            try {
              if (this._debug && oldLayer !== newLayer) {
                newLayer.validateProps();
              }
              if (!oldLayer) {
                this._initializeLayer(newLayer);
              } else {
                this._transferLayerState(oldLayer, newLayer);
                this._updateLayer(newLayer);
              }
              generatedLayers.push(newLayer);
              sublayers = newLayer.isComposite && newLayer.getSubLayers();
            } catch (err) {
              this._handleError("matching", err, newLayer);
            }
            if (sublayers) {
              this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    }, {
      key: "_finalizeOldLayers",
      value: function _finalizeOldLayers(oldLayerMap) {
        for (var layerId in oldLayerMap) {
          var layer = oldLayerMap[layerId];
          if (layer) {
            this._finalizeLayer(layer);
          }
        }
      }
    }, {
      key: "_initializeLayer",
      value: function _initializeLayer(layer) {
        try {
          layer._initialize();
          layer.lifecycle = LIFECYCLE.INITIALIZED;
        } catch (err) {
          this._handleError("initialization", err, layer);
        }
      }
    }, {
      key: "_transferLayerState",
      value: function _transferLayerState(oldLayer, newLayer) {
        newLayer._transferState(oldLayer);
        newLayer.lifecycle = LIFECYCLE.MATCHED;
        if (newLayer !== oldLayer) {
          oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
        }
      }
    }, {
      key: "_updateLayer",
      value: function _updateLayer(layer) {
        try {
          layer._update();
        } catch (err) {
          this._handleError("update", err, layer);
        }
      }
    }, {
      key: "_finalizeLayer",
      value: function _finalizeLayer(layer) {
        this._needsRedraw = this._needsRedraw || "finalized ".concat(layerName(layer));
        layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
        try {
          layer._finalize();
          layer.lifecycle = LIFECYCLE.FINALIZED;
        } catch (err) {
          this._handleError("finalization", err, layer);
        }
      }
    }]);
    return LayerManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js
  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    for (var key in a) {
      var aValue = a[key];
      var bValue = b[key];
      var equals5 = aValue === bValue || Array.isArray(aValue) && Array.isArray(bValue) && deepEqual(aValue, bValue);
      if (!equals5) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/view-manager.js
  function ownKeys19(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread19(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys19(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys19(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var ViewManager = function() {
    function ViewManager2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, ViewManager2);
      this.views = [];
      this.width = 100;
      this.height = 100;
      this.viewState = {};
      this.controllers = {};
      this.timeline = props.timeline;
      this._viewports = [];
      this._viewportMap = {};
      this._isUpdating = false;
      this._needsRedraw = "Initial render";
      this._needsUpdate = true;
      this._eventManager = props.eventManager;
      this._eventCallbacks = {
        onViewStateChange: props.onViewStateChange,
        onInteractionStateChange: props.onInteractionStateChange
      };
      Object.seal(this);
      this.setProps(props);
    }
    _createClass(ViewManager2, [{
      key: "finalize",
      value: function finalize() {
        for (var key in this.controllers) {
          if (this.controllers[key]) {
            this.controllers[key].finalize();
          }
        }
        this.controllers = {};
      }
    }, {
      key: "needsRedraw",
      value: function needsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        var redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        return redraw;
      }
    }, {
      key: "setNeedsUpdate",
      value: function setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
        this._needsRedraw = this._needsRedraw || reason;
      }
    }, {
      key: "updateViewStates",
      value: function updateViewStates() {
        for (var viewId in this.controllers) {
          var controller = this.controllers[viewId];
          if (controller) {
            controller.updateTransition();
          }
        }
      }
    }, {
      key: "getViewports",
      value: function getViewports(rect) {
        if (rect) {
          return this._viewports.filter(function(viewport3) {
            return viewport3.containsPixel(rect);
          });
        }
        return this._viewports;
      }
    }, {
      key: "getViews",
      value: function getViews() {
        var viewMap = {};
        this.views.forEach(function(view) {
          viewMap[view.id] = view;
        });
        return viewMap;
      }
    }, {
      key: "getView",
      value: function getView(viewOrViewId) {
        return typeof viewOrViewId === "string" ? this.views.find(function(view) {
          return view.id === viewOrViewId;
        }) : viewOrViewId;
      }
    }, {
      key: "getViewState",
      value: function getViewState(viewId) {
        var view = this.getView(viewId);
        var viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
        return view ? view.filterViewState(viewState) : viewState;
      }
    }, {
      key: "getViewport",
      value: function getViewport(viewId) {
        return this._viewportMap[viewId];
      }
    }, {
      key: "unproject",
      value: function unproject(xyz, opts) {
        var viewports = this.getViewports();
        var pixel = {
          x: xyz[0],
          y: xyz[1]
        };
        for (var i = viewports.length - 1; i >= 0; --i) {
          var viewport3 = viewports[i];
          if (viewport3.containsPixel(pixel)) {
            var p = xyz.slice();
            p[0] -= viewport3.x;
            p[1] -= viewport3.y;
            return viewport3.unproject(p, opts);
          }
        }
        return null;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("views" in props) {
          this._setViews(props.views);
        }
        if ("viewState" in props) {
          this._setViewState(props.viewState);
        }
        if ("width" in props || "height" in props) {
          this._setSize(props.width, props.height);
        }
        if (!this._isUpdating) {
          this._update();
        }
      }
    }, {
      key: "_update",
      value: function _update() {
        this._isUpdating = true;
        if (this._needsUpdate) {
          this._needsUpdate = false;
          this._rebuildViewports();
        }
        if (this._needsUpdate) {
          this._needsUpdate = false;
          this._rebuildViewports();
        }
        this._isUpdating = false;
      }
    }, {
      key: "_setSize",
      value: function _setSize(width, height) {
        assert8(Number.isFinite(width) && Number.isFinite(height));
        if (width !== this.width || height !== this.height) {
          this.width = width;
          this.height = height;
          this.setNeedsUpdate("Size changed");
        }
      }
    }, {
      key: "_setViews",
      value: function _setViews(views) {
        views = flatten(views, Boolean);
        var viewsChanged = this._diffViews(views, this.views);
        if (viewsChanged) {
          this.setNeedsUpdate("views changed");
        }
        this.views = views;
      }
    }, {
      key: "_setViewState",
      value: function _setViewState(viewState) {
        if (viewState) {
          var viewStateChanged = !deepEqual(viewState, this.viewState);
          if (viewStateChanged) {
            this.setNeedsUpdate("viewState changed");
          }
          this.viewState = viewState;
        } else {
          log_default.warn("missing `viewState` or `initialViewState`")();
        }
      }
    }, {
      key: "_onViewStateChange",
      value: function _onViewStateChange(viewId, event) {
        event.viewId = viewId;
        this._eventCallbacks.onViewStateChange(event);
      }
    }, {
      key: "_createController",
      value: function _createController(view, props) {
        var Controller2 = props.type;
        var controller = new Controller2(_objectSpread19({
          timeline: this.timeline,
          eventManager: this._eventManager,
          onViewStateChange: this._onViewStateChange.bind(this, props.id),
          onStateChange: this._eventCallbacks.onInteractionStateChange,
          makeViewport: function makeViewport(viewState) {
            return view._getViewport(viewState, {
              width: viewState.width,
              height: viewState.height
            });
          }
        }, props));
        return controller;
      }
    }, {
      key: "_updateController",
      value: function _updateController(view, viewState, viewport3, controller) {
        var controllerProps = view.controller;
        if (controllerProps) {
          controllerProps = _objectSpread19(_objectSpread19(_objectSpread19(_objectSpread19({}, viewState), view.props), controllerProps), {}, {
            id: view.id,
            x: viewport3.x,
            y: viewport3.y,
            width: viewport3.width,
            height: viewport3.height
          });
          if (controller) {
            controller.setProps(controllerProps);
          } else {
            controller = this._createController(view, controllerProps);
          }
          return controller;
        }
        return null;
      }
    }, {
      key: "_rebuildViewports",
      value: function _rebuildViewports() {
        var width = this.width, height = this.height, views = this.views;
        var oldControllers = this.controllers;
        this._viewports = [];
        this.controllers = {};
        var invalidateControllers = false;
        for (var i = views.length; i--; ) {
          var view = views[i];
          var viewState = this.getViewState(view);
          var viewport3 = view.makeViewport({
            width,
            height,
            viewState
          });
          var oldController = oldControllers[view.id];
          if (!oldController) {
            invalidateControllers = true;
          } else if (invalidateControllers) {
            oldController.finalize();
            oldController = null;
          }
          this.controllers[view.id] = this._updateController(view, viewState, viewport3, oldController);
          this._viewports.unshift(viewport3);
        }
        for (var id in oldControllers) {
          if (oldControllers[id] && !this.controllers[id]) {
            oldControllers[id].finalize();
          }
        }
        this._buildViewportMap();
      }
    }, {
      key: "_buildViewportMap",
      value: function _buildViewportMap() {
        var _this = this;
        this._viewportMap = {};
        this._viewports.forEach(function(viewport3) {
          if (viewport3.id) {
            _this._viewportMap[viewport3.id] = _this._viewportMap[viewport3.id] || viewport3;
          }
        });
      }
    }, {
      key: "_diffViews",
      value: function _diffViews(newViews, oldViews) {
        if (newViews.length !== oldViews.length) {
          return true;
        }
        return newViews.some(function(_, i) {
          return !newViews[i].equals(oldViews[i]);
        });
      }
    }]);
    return ViewManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/utils/positions.js
  var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  function parsePosition(value17) {
    switch (_typeof(value17)) {
      case "number":
        return {
          position: value17,
          relative: false
        };
      case "string":
        var match = value17.match(PERCENT_OR_PIXELS_REGEX);
        if (match && match.length >= 3) {
          var relative = match[2] === "%";
          var position = parseFloat(match[1]);
          return {
            position: relative ? position / 100 : position,
            relative
          };
        }
      default:
        throw new Error("Could not parse position string ".concat(value17));
    }
  }
  function getPosition(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
  }

  // node_modules/@deck.gl/core/dist/esm/views/view.js
  function ownKeys20(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread20(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys20(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys20(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var View = function() {
    function View2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, View2);
      var _props$id = props.id, id = _props$id === void 0 ? null : _props$id, _props$x = props.x, x = _props$x === void 0 ? 0 : _props$x, _props$y = props.y, y = _props$y === void 0 ? 0 : _props$y, _props$width = props.width, width = _props$width === void 0 ? "100%" : _props$width, _props$height = props.height, height = _props$height === void 0 ? "100%" : _props$height, _props$projectionMatr = props.projectionMatrix, projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr, _props$fovy = props.fovy, fovy = _props$fovy === void 0 ? 50 : _props$fovy, _props$near = props.near, near = _props$near === void 0 ? 0.1 : _props$near, _props$far = props.far, far = _props$far === void 0 ? 1e3 : _props$far, _props$modelMatrix = props.modelMatrix, modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix, _props$viewportInstan = props.viewportInstance, viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan, _props$type = props.type, type = _props$type === void 0 ? Viewport : _props$type;
      assert8(!viewportInstance || viewportInstance instanceof Viewport);
      this.viewportInstance = viewportInstance;
      this.id = id || this.constructor.displayName || "view";
      this.type = type;
      this.props = Object.assign({}, props, {
        id: this.id,
        projectionMatrix,
        fovy,
        near,
        far,
        modelMatrix
      });
      this._parseDimensions({
        x,
        y,
        width,
        height
      });
      this.equals = this.equals.bind(this);
      Object.seal(this);
    }
    _createClass(View2, [{
      key: "equals",
      value: function equals5(view) {
        if (this === view) {
          return true;
        }
        if (this.viewportInstance) {
          return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
        }
        var viewChanged = deepEqual(this.props, view.props);
        return viewChanged;
      }
    }, {
      key: "makeViewport",
      value: function makeViewport(_ref) {
        var width = _ref.width, height = _ref.height, viewState = _ref.viewState;
        if (this.viewportInstance) {
          return this.viewportInstance;
        }
        viewState = this.filterViewState(viewState);
        var viewportDimensions = this.getDimensions({
          width,
          height
        });
        return this._getViewport(viewState, viewportDimensions);
      }
    }, {
      key: "getViewStateId",
      value: function getViewStateId() {
        switch (_typeof(this.props.viewState)) {
          case "string":
            return this.props.viewState;
          case "object":
            return this.props.viewState && this.props.viewState.id;
          default:
            return this.id;
        }
      }
    }, {
      key: "filterViewState",
      value: function filterViewState(viewState) {
        if (this.props.viewState && _typeof(this.props.viewState) === "object") {
          if (!this.props.viewState.id) {
            return this.props.viewState;
          }
          var newViewState = Object.assign({}, viewState);
          for (var key in this.props.viewState) {
            if (key !== "id") {
              newViewState[key] = this.props.viewState[key];
            }
          }
          return newViewState;
        }
        return viewState;
      }
    }, {
      key: "getDimensions",
      value: function getDimensions(_ref2) {
        var width = _ref2.width, height = _ref2.height;
        return {
          x: getPosition(this._x, width),
          y: getPosition(this._y, height),
          width: getPosition(this._width, width),
          height: getPosition(this._height, height)
        };
      }
    }, {
      key: "_getControllerProps",
      value: function _getControllerProps(defaultOpts) {
        var opts = this.props.controller;
        if (!opts) {
          return null;
        }
        if (opts === true) {
          return defaultOpts;
        }
        if (typeof opts === "function") {
          opts = {
            type: opts
          };
        }
        return Object.assign({}, defaultOpts, opts);
      }
    }, {
      key: "_getViewport",
      value: function _getViewport(viewState, viewportDimensions) {
        var ViewportType = this.type;
        return new ViewportType(_objectSpread20(_objectSpread20(_objectSpread20({}, viewState), this.props), viewportDimensions));
      }
    }, {
      key: "_parseDimensions",
      value: function _parseDimensions(_ref3) {
        var x = _ref3.x, y = _ref3.y, width = _ref3.width, height = _ref3.height;
        this._x = parsePosition(x);
        this._y = parsePosition(y);
        this._width = parsePosition(width);
        this._height = parsePosition(height);
      }
    }]);
    return View2;
  }();

  // node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js
  var noop3 = function noop4() {
  };
  var TRANSITION_EVENTS = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  };
  var DEFAULT_PROPS2 = {
    transitionEasing: function transitionEasing(t) {
      return t;
    },
    transitionInterruption: TRANSITION_EVENTS.BREAK,
    onTransitionStart: noop3,
    onTransitionInterrupt: noop3,
    onTransitionEnd: noop3
  };
  var TransitionManager = function() {
    function TransitionManager2(ControllerState) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, TransitionManager2);
      this.ControllerState = ControllerState;
      this.props = Object.assign({}, DEFAULT_PROPS2, props);
      this.propsInTransition = null;
      this.transition = new Transition(props.timeline);
      this.onViewStateChange = props.onViewStateChange || noop3;
      this.onStateChange = props.onStateChange || noop3;
      this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
    }
    _createClass(TransitionManager2, [{
      key: "finalize",
      value: function finalize() {
        this.transition.cancel();
      }
    }, {
      key: "getViewportInTransition",
      value: function getViewportInTransition() {
        return this.propsInTransition;
      }
    }, {
      key: "processViewStateChange",
      value: function processViewStateChange(nextProps) {
        var transitionTriggered = false;
        var currentProps = this.props;
        nextProps = Object.assign({}, DEFAULT_PROPS2, nextProps);
        this.props = nextProps;
        if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
          return transitionTriggered;
        }
        if (this._isTransitionEnabled(nextProps)) {
          var _this$transition$sett = this.transition.settings, interruption = _this$transition$sett.interruption, endProps = _this$transition$sett.endProps;
          var startProps = Object.assign({}, currentProps, interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps);
          this._triggerTransition(startProps, nextProps);
          transitionTriggered = true;
        } else {
          this.transition.cancel();
        }
        return transitionTriggered;
      }
    }, {
      key: "updateTransition",
      value: function updateTransition() {
        this.transition.update();
      }
    }, {
      key: "_isTransitionEnabled",
      value: function _isTransitionEnabled(props) {
        var transitionDuration = props.transitionDuration, transitionInterpolator = props.transitionInterpolator;
        return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
      }
    }, {
      key: "_isUpdateDueToCurrentTransition",
      value: function _isUpdateDueToCurrentTransition(props) {
        if (this.transition.inProgress) {
          return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
        }
        return false;
      }
    }, {
      key: "_shouldIgnoreViewportChange",
      value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
        if (this.transition.inProgress) {
          return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
        } else if (this._isTransitionEnabled(nextProps)) {
          return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
        }
        return true;
      }
    }, {
      key: "_triggerTransition",
      value: function _triggerTransition(startProps, endProps) {
        var startViewstate = new this.ControllerState(startProps);
        var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
        var transitionInterpolator = endProps.transitionInterpolator;
        var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
        if (duration === 0) {
          return;
        }
        var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);
        this.propsInTransition = {};
        this.duration = duration;
        this.transition.start({
          duration,
          easing: endProps.transitionEasing,
          interpolator: endProps.transitionInterpolator,
          interruption: endProps.transitionInterruption,
          startProps: initialProps.start,
          endProps: initialProps.end,
          onStart: endProps.onTransitionStart,
          onUpdate: this._onTransitionUpdate,
          onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
          onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
        });
        this.onStateChange({
          inTransition: true
        });
        this.updateTransition();
      }
    }, {
      key: "_onTransitionEnd",
      value: function _onTransitionEnd(callback) {
        var _this = this;
        return function(transition) {
          _this.propsInTransition = null;
          _this.onStateChange({
            inTransition: false,
            isZooming: false,
            isPanning: false,
            isRotating: false
          });
          callback(transition);
        };
      }
    }, {
      key: "_onTransitionUpdate",
      value: function _onTransitionUpdate(transition) {
        var time = transition.time, _transition$settings = transition.settings, interpolator = _transition$settings.interpolator, startProps = _transition$settings.startProps, endProps = _transition$settings.endProps, duration = _transition$settings.duration, easing2 = _transition$settings.easing;
        var t = easing2(time / duration);
        var viewport3 = interpolator.interpolateProps(startProps, endProps, t);
        this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport3)).getViewportProps();
        this.onViewStateChange({
          viewState: this.propsInTransition,
          oldViewState: this.props
        });
      }
    }]);
    return TransitionManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/controllers/controller.js
  function ownKeys21(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread21(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys21(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys21(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var NO_TRANSITION_PROPS = {
    transitionDuration: 0
  };
  var DEFAULT_INERTIA = 300;
  var INERTIA_EASING = function INERTIA_EASING2(t) {
    return 1 - (1 - t) * (1 - t);
  };
  var EVENT_TYPES = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
    DOUBLE_TAP: ["doubletap"],
    KEYBOARD: ["keydown"]
  };
  var Controller = function() {
    function Controller2(ControllerState) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Controller2);
      assert8(ControllerState);
      this.ControllerState = ControllerState;
      this.controllerState = null;
      this.controllerStateProps = null;
      this.eventManager = null;
      this.transitionManager = new TransitionManager(ControllerState, _objectSpread21(_objectSpread21({}, options), {}, {
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      }));
      this._events = null;
      this._interactionState = {
        isDragging: false
      };
      this._customEvents = [];
      this.onViewStateChange = null;
      this.onStateChange = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.setProps(options);
    }
    _createClass(Controller2, [{
      key: "finalize",
      value: function finalize() {
        for (var eventName in this._events) {
          if (this._events[eventName]) {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
        this.transitionManager.finalize();
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        var ControllerState = this.ControllerState;
        this.controllerState = new ControllerState(_objectSpread21(_objectSpread21({
          makeViewport: this.makeViewport
        }, this.controllerStateProps), this._state));
        var eventStartBlocked = this._eventStartBlocked;
        switch (event.type) {
          case "panstart":
            return eventStartBlocked ? false : this._onPanStart(event);
          case "panmove":
            return this._onPan(event);
          case "panend":
            return this._onPanEnd(event);
          case "pinchstart":
            return eventStartBlocked ? false : this._onPinchStart(event);
          case "pinchmove":
            return this._onPinch(event);
          case "pinchend":
            return this._onPinchEnd(event);
          case "tripanstart":
            return eventStartBlocked ? false : this._onTriplePanStart(event);
          case "tripanmove":
            return this._onTriplePan(event);
          case "tripanend":
            return this._onTriplePanEnd(event);
          case "doubletap":
            return this._onDoubleTap(event);
          case "wheel":
            return this._onWheel(event);
          case "keydown":
            return this._onKeyDown(event);
          default:
            return false;
        }
      }
    }, {
      key: "getCenter",
      value: function getCenter(event) {
        var _this$controllerState = this.controllerStateProps, x = _this$controllerState.x, y = _this$controllerState.y;
        var offsetCenter = event.offsetCenter;
        return [offsetCenter.x - x, offsetCenter.y - y];
      }
    }, {
      key: "isPointInBounds",
      value: function isPointInBounds(pos, event) {
        var _this$controllerState2 = this.controllerStateProps, width = _this$controllerState2.width, height = _this$controllerState2.height;
        if (event && event.handled) {
          return false;
        }
        var inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
        if (inside && event) {
          event.stopPropagation();
        }
        return inside;
      }
    }, {
      key: "isFunctionKeyPressed",
      value: function isFunctionKeyPressed(event) {
        var srcEvent = event.srcEvent;
        return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
      }
    }, {
      key: "isDragging",
      value: function isDragging() {
        return this._interactionState.isDragging;
      }
    }, {
      key: "blockEvents",
      value: function blockEvents(timeout) {
        var _this = this;
        var timer = setTimeout(function() {
          if (_this._eventStartBlocked === timer) {
            _this._eventStartBlocked = null;
          }
        }, timeout);
        this._eventStartBlocked = timer;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        if ("onViewStateChange" in props) {
          this.onViewStateChange = props.onViewStateChange;
        }
        if ("onStateChange" in props) {
          this.onStateChange = props.onStateChange;
        }
        if ("makeViewport" in props) {
          this.makeViewport = props.makeViewport;
        }
        if ("dragMode" in props) {
          this.dragMode = props.dragMode;
        }
        this.controllerStateProps = props;
        if ("eventManager" in props && this.eventManager !== props.eventManager) {
          this.eventManager = props.eventManager;
          this._events = {};
          this.toggleEvents(this._customEvents, true);
        }
        if (!("transitionInterpolator" in props)) {
          props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
        }
        this.transitionManager.processViewStateChange(props);
        var inertia = props.inertia;
        if (inertia === true) {
          inertia = DEFAULT_INERTIA;
        }
        this.inertia = inertia;
        var _props$scrollZoom = props.scrollZoom, scrollZoom = _props$scrollZoom === void 0 ? true : _props$scrollZoom, _props$dragPan = props.dragPan, dragPan = _props$dragPan === void 0 ? true : _props$dragPan, _props$dragRotate = props.dragRotate, dragRotate = _props$dragRotate === void 0 ? true : _props$dragRotate, _props$doubleClickZoo = props.doubleClickZoom, doubleClickZoom = _props$doubleClickZoo === void 0 ? true : _props$doubleClickZoo, _props$touchZoom = props.touchZoom, touchZoom = _props$touchZoom === void 0 ? true : _props$touchZoom, _props$touchRotate = props.touchRotate, touchRotate = _props$touchRotate === void 0 ? false : _props$touchRotate, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard;
        var isInteractive = Boolean(this.onViewStateChange);
        this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
        this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
        this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
        this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
        this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
        this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
        this.scrollZoom = scrollZoom;
        this.dragPan = dragPan;
        this.dragRotate = dragRotate;
        this.doubleClickZoom = doubleClickZoom;
        this.touchZoom = touchZoom;
        this.touchRotate = touchRotate;
        this.keyboard = keyboard;
      }
    }, {
      key: "updateTransition",
      value: function updateTransition() {
        this.transitionManager.updateTransition();
      }
    }, {
      key: "toggleEvents",
      value: function toggleEvents(eventNames, enabled) {
        var _this2 = this;
        if (this.eventManager) {
          eventNames.forEach(function(eventName) {
            if (_this2._events[eventName] !== enabled) {
              _this2._events[eventName] = enabled;
              if (enabled) {
                _this2.eventManager.on(eventName, _this2.handleEvent);
              } else {
                _this2.eventManager.off(eventName, _this2.handleEvent);
              }
            }
          });
        }
      }
    }, {
      key: "updateViewport",
      value: function updateViewport(newControllerState) {
        var extraProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var interactionState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var viewState = Object.assign({}, newControllerState.getViewportProps(), extraProps);
        var changed = this.controllerState !== newControllerState;
        this._state = newControllerState.getState();
        this._setInteractionState(interactionState);
        if (changed) {
          var oldViewState = this.controllerState ? this.controllerState.getViewportProps() : null;
          if (this.onViewStateChange) {
            this.onViewStateChange({
              viewState,
              interactionState: this._interactionState,
              oldViewState
            });
          }
        }
      }
    }, {
      key: "_onTransition",
      value: function _onTransition(params) {
        if (this.onViewStateChange) {
          params.interactionState = this._interactionState;
          this.onViewStateChange(params);
        }
      }
    }, {
      key: "_setInteractionState",
      value: function _setInteractionState(newStates) {
        Object.assign(this._interactionState, newStates);
        if (this.onStateChange) {
          this.onStateChange(this._interactionState);
        }
      }
    }, {
      key: "_onPanStart",
      value: function _onPanStart(event) {
        var pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        var alternateMode = this.isFunctionKeyPressed(event) || event.rightButton;
        if (this.invertPan || this.dragMode === "pan") {
          alternateMode = !alternateMode;
        }
        var newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
          pos
        });
        this._panMove = alternateMode;
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true
        });
        return true;
      }
    }, {
      key: "_onPan",
      value: function _onPan(event) {
        if (!this.isDragging()) {
          return false;
        }
        return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
      }
    }, {
      key: "_onPanEnd",
      value: function _onPanEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
      }
    }, {
      key: "_onPanMove",
      value: function _onPanMove(event) {
        if (!this.dragPan) {
          return false;
        }
        var pos = this.getCenter(event);
        var newControllerState = this.controllerState.pan({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isPanning: true
        });
        return true;
      }
    }, {
      key: "_onPanMoveEnd",
      value: function _onPanMoveEnd(event) {
        var inertia = this.inertia;
        if (this.dragPan && inertia && event.velocity) {
          var pos = this.getCenter(event);
          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
          var newControllerState = this.controllerState.pan({
            pos: endPos
          }).panEnd();
          this.updateViewport(newControllerState, _objectSpread21(_objectSpread21({}, this._getTransitionProps()), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isPanning: true
          });
        } else {
          var _newControllerState = this.controllerState.panEnd();
          this.updateViewport(_newControllerState, null, {
            isDragging: false,
            isPanning: false
          });
        }
        return true;
      }
    }, {
      key: "_onPanRotate",
      value: function _onPanRotate(event) {
        if (!this.dragRotate) {
          return false;
        }
        var pos = this.getCenter(event);
        var newControllerState = this.controllerState.rotate({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isRotating: true
        });
        return true;
      }
    }, {
      key: "_onPanRotateEnd",
      value: function _onPanRotateEnd(event) {
        var inertia = this.inertia;
        if (this.dragRotate && inertia && event.velocity) {
          var pos = this.getCenter(event);
          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
          var newControllerState = this.controllerState.rotate({
            pos: endPos
          }).rotateEnd();
          this.updateViewport(newControllerState, _objectSpread21(_objectSpread21({}, this._getTransitionProps()), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isRotating: true
          });
        } else {
          var _newControllerState2 = this.controllerState.rotateEnd();
          this.updateViewport(_newControllerState2, null, {
            isDragging: false,
            isRotating: false
          });
        }
        return true;
      }
    }, {
      key: "_onWheel",
      value: function _onWheel(event) {
        if (!this.scrollZoom) {
          return false;
        }
        event.preventDefault();
        var pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        var _this$scrollZoom = this.scrollZoom, _this$scrollZoom$spee = _this$scrollZoom.speed, speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee, _this$scrollZoom$smoo = _this$scrollZoom.smooth, smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;
        var delta = event.delta;
        var scale5 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
        if (delta < 0 && scale5 !== 0) {
          scale5 = 1 / scale5;
        }
        var newControllerState = this.controllerState.zoom({
          pos,
          scale: scale5
        });
        this.updateViewport(newControllerState, _objectSpread21(_objectSpread21({}, this._getTransitionProps({
          around: pos
        })), {}, {
          transitionDuration: smooth ? 250 : 1
        }), {
          isZooming: true,
          isPanning: true
        });
        return true;
      }
    }, {
      key: "_onTriplePanStart",
      value: function _onTriplePanStart(event) {
        var pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        var newControllerState = this.controllerState.rotateStart({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true
        });
        return true;
      }
    }, {
      key: "_onTriplePan",
      value: function _onTriplePan(event) {
        if (!this.touchRotate) {
          return false;
        }
        if (!this.isDragging()) {
          return false;
        }
        var pos = this.getCenter(event);
        pos[0] -= event.deltaX;
        var newControllerState = this.controllerState.rotate({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isRotating: true
        });
        return true;
      }
    }, {
      key: "_onTriplePanEnd",
      value: function _onTriplePanEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        var inertia = this.inertia;
        if (this.touchRotate && inertia && event.velocityY) {
          var pos = this.getCenter(event);
          var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
          var newControllerState = this.controllerState.rotate({
            pos: endPos
          });
          this.updateViewport(newControllerState, _objectSpread21(_objectSpread21({}, this._getTransitionProps()), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isRotating: true
          });
          this.blockEvents(inertia);
        } else {
          var _newControllerState3 = this.controllerState.rotateEnd();
          this.updateViewport(_newControllerState3, null, {
            isDragging: false,
            isRotating: false
          });
        }
        return true;
      }
    }, {
      key: "_onPinchStart",
      value: function _onPinchStart(event) {
        var pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        var newControllerState = this.controllerState.zoomStart({
          pos
        }).rotateStart({
          pos
        });
        this._startPinchRotation = event.rotation;
        this._lastPinchEvent = event;
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true
        });
        return true;
      }
    }, {
      key: "_onPinch",
      value: function _onPinch(event) {
        if (!this.touchZoom && !this.touchRotate) {
          return false;
        }
        if (!this.isDragging()) {
          return false;
        }
        var newControllerState = this.controllerState;
        if (this.touchZoom) {
          var scale5 = event.scale;
          var pos = this.getCenter(event);
          newControllerState = newControllerState.zoom({
            pos,
            scale: scale5
          });
        }
        if (this.touchRotate) {
          var rotation = event.rotation;
          newControllerState = newControllerState.rotate({
            deltaAngleX: this._startPinchRotation - rotation
          });
        }
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isPanning: this.touchZoom,
          isZooming: this.touchZoom,
          isRotating: this.touchRotate
        });
        this._lastPinchEvent = event;
        return true;
      }
    }, {
      key: "_onPinchEnd",
      value: function _onPinchEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        var inertia = this.inertia, _lastPinchEvent = this._lastPinchEvent;
        if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
          var pos = this.getCenter(event);
          var newControllerState = this.controllerState.rotateEnd();
          var z = Math.log2(event.scale);
          var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
          var endScale = Math.pow(2, z + velocityZ * inertia / 2);
          newControllerState = newControllerState.zoom({
            pos,
            scale: endScale
          }).zoomEnd();
          this.updateViewport(newControllerState, _objectSpread21(_objectSpread21({}, this._getTransitionProps({
            around: pos
          })), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: false
          });
          this.blockEvents(inertia);
        } else {
          var _newControllerState4 = this.controllerState.zoomEnd().rotateEnd();
          this.updateViewport(_newControllerState4, null, {
            isDragging: false,
            isPanning: false,
            isZooming: false,
            isRotating: false
          });
        }
        this._startPinchRotation = null;
        this._lastPinchEvent = null;
        return true;
      }
    }, {
      key: "_onDoubleTap",
      value: function _onDoubleTap(event) {
        if (!this.doubleClickZoom) {
          return false;
        }
        var pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        var isZoomOut = this.isFunctionKeyPressed(event);
        var newControllerState = this.controllerState.zoom({
          pos,
          scale: isZoomOut ? 0.5 : 2
        });
        this.updateViewport(newControllerState, this._getTransitionProps({
          around: pos
        }), {
          isZooming: true,
          isPanning: true
        });
        this.blockEvents(100);
        return true;
      }
    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        if (!this.keyboard) {
          return false;
        }
        var funcKey = this.isFunctionKeyPressed(event);
        var _this$keyboard = this.keyboard, zoomSpeed = _this$keyboard.zoomSpeed, moveSpeed = _this$keyboard.moveSpeed, rotateSpeedX = _this$keyboard.rotateSpeedX, rotateSpeedY = _this$keyboard.rotateSpeedY;
        var controllerState = this.controllerState;
        var newControllerState;
        var interactionState = {};
        switch (event.srcEvent.code) {
          case "Minus":
            newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
            interactionState.isZooming = true;
            break;
          case "Equal":
            newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
            interactionState.isZooming = true;
            break;
          case "ArrowLeft":
            if (funcKey) {
              newControllerState = controllerState.rotateLeft(rotateSpeedX);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveLeft(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          case "ArrowRight":
            if (funcKey) {
              newControllerState = controllerState.rotateRight(rotateSpeedX);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveRight(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          case "ArrowUp":
            if (funcKey) {
              newControllerState = controllerState.rotateUp(rotateSpeedY);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveUp(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          case "ArrowDown":
            if (funcKey) {
              newControllerState = controllerState.rotateDown(rotateSpeedY);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveDown(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          default:
            return false;
        }
        this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
        return true;
      }
    }, {
      key: "_getTransitionProps",
      value: function _getTransitionProps() {
        return NO_TRANSITION_PROPS;
      }
    }, {
      key: "events",
      set: function set2(customEvents) {
        this.toggleEvents(this._customEvents, false);
        this.toggleEvents(customEvents, true);
        this._customEvents = customEvents;
        this.setProps(this.controllerStateProps);
      }
    }]);
    return Controller2;
  }();

  // node_modules/@deck.gl/core/dist/esm/controllers/view-state.js
  var ViewState = function() {
    function ViewState2(opts) {
      _classCallCheck(this, ViewState2);
      assert8(Number.isFinite(opts.width), "`width` must be supplied");
      assert8(Number.isFinite(opts.height), "`height` must be supplied");
      this._viewportProps = this._applyConstraints(opts);
    }
    _createClass(ViewState2, [{
      key: "getViewportProps",
      value: function getViewportProps() {
        return this._viewportProps;
      }
    }, {
      key: "getState",
      value: function getState() {
        return this._state;
      }
    }, {
      key: "shortestPathFrom",
      value: function shortestPathFrom(viewState) {
        return this._viewportProps;
      }
    }, {
      key: "_applyConstraints",
      value: function _applyConstraints(props) {
        return props;
      }
    }]);
    return ViewState2;
  }();

  // node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js
  function _createForOfIteratorHelper37(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray38(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray38(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray38(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray38(o, minLen);
  }
  function _arrayLikeToArray38(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var TransitionInterpolator = function() {
    function TransitionInterpolator2() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, TransitionInterpolator2);
      if (Array.isArray(opts)) {
        opts = {
          compare: opts,
          extract: opts,
          required: opts
        };
      }
      var _opts = opts, compare = _opts.compare, extract = _opts.extract, required = _opts.required;
      this._propsToCompare = compare;
      this._propsToExtract = extract;
      this._requiredProps = required;
    }
    _createClass(TransitionInterpolator2, [{
      key: "arePropsEqual",
      value: function arePropsEqual(currentProps, nextProps) {
        var _iterator = _createForOfIteratorHelper37(this._propsToCompare || Object.keys(nextProps)), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
              return false;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return true;
      }
    }, {
      key: "initializeProps",
      value: function initializeProps(startProps, endProps) {
        var result;
        if (this._propsToExtract) {
          var startViewStateProps = {};
          var endViewStateProps = {};
          var _iterator2 = _createForOfIteratorHelper37(this._propsToExtract), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var key = _step2.value;
              startViewStateProps[key] = startProps[key];
              endViewStateProps[key] = endProps[key];
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          result = {
            start: startViewStateProps,
            end: endViewStateProps
          };
        } else {
          result = {
            start: startProps,
            end: endProps
          };
        }
        this._checkRequiredProps(result.start);
        this._checkRequiredProps(result.end);
        return result;
      }
    }, {
      key: "interpolateProps",
      value: function interpolateProps(startProps, endProps, t) {
        return endProps;
      }
    }, {
      key: "getDuration",
      value: function getDuration(startProps, endProps) {
        return endProps.transitionDuration;
      }
    }, {
      key: "_checkRequiredProps",
      value: function _checkRequiredProps(props) {
        if (!this._requiredProps) {
          return;
        }
        this._requiredProps.forEach(function(propName) {
          var value17 = props[propName];
          assert8(Number.isFinite(value17) || Array.isArray(value17), "".concat(propName, " is required for transition"));
        });
      }
    }]);
    return TransitionInterpolator2;
  }();

  // node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js
  function ownKeys22(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread22(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys22(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys22(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper38(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray39(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray39(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray39(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray39(o, minLen);
  }
  function _arrayLikeToArray39(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper29(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct30();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct30() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
  var LinearInterpolator = function(_TransitionInterpolat) {
    _inherits(LinearInterpolator2, _TransitionInterpolat);
    var _super = _createSuper29(LinearInterpolator2);
    function LinearInterpolator2() {
      var _this;
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, LinearInterpolator2);
      var transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
      _this = _super.call(this, transitionProps || {
        compare: DEFAULT_PROPS3,
        extract: DEFAULT_PROPS3,
        required: DEFAULT_REQUIRED_PROPS
      });
      _this.opts = opts;
      return _this;
    }
    _createClass(LinearInterpolator2, [{
      key: "initializeProps",
      value: function initializeProps(startProps, endProps) {
        var result = _get(_getPrototypeOf(LinearInterpolator2.prototype), "initializeProps", this).call(this, startProps, endProps);
        var _this$opts = this.opts, makeViewport = _this$opts.makeViewport, around = _this$opts.around;
        if (makeViewport && around) {
          var startViewport = makeViewport(startProps);
          var endViewport = makeViewport(endProps);
          var aroundLngLat = startViewport.unproject(around);
          result.start.around = around;
          Object.assign(result.end, {
            around: endViewport.project(aroundLngLat),
            aroundLngLat,
            width: endProps.width,
            height: endProps.height
          });
        }
        return result;
      }
    }, {
      key: "interpolateProps",
      value: function interpolateProps(startProps, endProps, t) {
        var propsInTransition = {};
        var _iterator = _createForOfIteratorHelper38(this._propsToExtract), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (endProps.aroundLngLat) {
          var viewport3 = this.opts.makeViewport(_objectSpread22(_objectSpread22({}, endProps), propsInTransition));
          var _viewport$getMapCente = viewport3.getMapCenterByLngLatPosition({
            lngLat: endProps.aroundLngLat,
            pos: lerp(startProps.around, endProps.around, t)
          }), _viewport$getMapCente2 = _slicedToArray(_viewport$getMapCente, 2), longitude = _viewport$getMapCente2[0], latitude = _viewport$getMapCente2[1];
          propsInTransition.longitude = longitude;
          propsInTransition.latitude = latitude;
        }
        return propsInTransition;
      }
    }]);
    return LinearInterpolator2;
  }(TransitionInterpolator);

  // node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js
  function ownKeys23(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread23(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys23(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys23(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper30(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct31();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct31() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var PITCH_MOUSE_THRESHOLD = 5;
  var PITCH_ACCEL = 1.2;
  var LINEAR_TRANSITION_PROPS = {
    transitionDuration: 300,
    transitionEasing: function transitionEasing2(t) {
      return t;
    },
    transitionInterpolator: new LinearInterpolator(),
    transitionInterruption: TRANSITION_EVENTS.BREAK
  };
  var DEFAULT_STATE = {
    pitch: 0,
    bearing: 0,
    altitude: 1.5,
    minZoom: 0,
    maxZoom: 20,
    minPitch: 0,
    maxPitch: 60
  };
  var MapState = function(_ViewState) {
    _inherits(MapState2, _ViewState);
    var _super = _createSuper30(MapState2);
    function MapState2() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, makeViewport = _ref.makeViewport, width = _ref.width, height = _ref.height, latitude = _ref.latitude, longitude = _ref.longitude, zoom = _ref.zoom, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? DEFAULT_STATE.maxZoom : _ref$maxZoom, _ref$minZoom = _ref.minZoom, minZoom = _ref$minZoom === void 0 ? DEFAULT_STATE.minZoom : _ref$minZoom, _ref$maxPitch = _ref.maxPitch, maxPitch = _ref$maxPitch === void 0 ? DEFAULT_STATE.maxPitch : _ref$maxPitch, _ref$minPitch = _ref.minPitch, minPitch = _ref$minPitch === void 0 ? DEFAULT_STATE.minPitch : _ref$minPitch, startPanLngLat = _ref.startPanLngLat, startZoomLngLat = _ref.startZoomLngLat, startRotatePos = _ref.startRotatePos, startBearing = _ref.startBearing, startPitch = _ref.startPitch, startZoom = _ref.startZoom;
      _classCallCheck(this, MapState2);
      assert8(Number.isFinite(longitude), "`longitude` must be supplied");
      assert8(Number.isFinite(latitude), "`latitude` must be supplied");
      assert8(Number.isFinite(zoom), "`zoom` must be supplied");
      _this = _super.call(this, {
        width,
        height,
        latitude,
        longitude,
        zoom,
        bearing,
        pitch,
        altitude,
        maxZoom,
        minZoom,
        maxPitch,
        minPitch
      });
      _this._state = {
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom
      };
      _this.makeViewport = makeViewport;
      return _this;
    }
    _createClass(MapState2, [{
      key: "panStart",
      value: function panStart(_ref2) {
        var pos = _ref2.pos;
        return this._getUpdatedState({
          startPanLngLat: this._unproject(pos)
        });
      }
    }, {
      key: "pan",
      value: function pan(_ref3) {
        var pos = _ref3.pos, startPos = _ref3.startPos;
        var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);
        if (!startPanLngLat) {
          return this;
        }
        var _this$_calculateNewLn = this._calculateNewLngLat({
          startPanLngLat,
          pos
        }), _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2), longitude = _this$_calculateNewLn2[0], latitude = _this$_calculateNewLn2[1];
        return this._getUpdatedState({
          longitude,
          latitude
        });
      }
    }, {
      key: "panEnd",
      value: function panEnd() {
        return this._getUpdatedState({
          startPanLngLat: null
        });
      }
    }, {
      key: "rotateStart",
      value: function rotateStart(_ref4) {
        var pos = _ref4.pos;
        return this._getUpdatedState({
          startRotatePos: pos,
          startBearing: this._viewportProps.bearing,
          startPitch: this._viewportProps.pitch
        });
      }
    }, {
      key: "rotate",
      value: function rotate3(_ref5) {
        var pos = _ref5.pos, _ref5$deltaAngleX = _ref5.deltaAngleX, deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX, _ref5$deltaAngleY = _ref5.deltaAngleY, deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;
        var _this$_state = this._state, startRotatePos = _this$_state.startRotatePos, startBearing = _this$_state.startBearing, startPitch = _this$_state.startPitch;
        if (!startRotatePos || !Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
          return this;
        }
        var newRotation;
        if (pos) {
          newRotation = this._calculateNewPitchAndBearing(_objectSpread23(_objectSpread23({}, this._getRotationParams(pos, startRotatePos)), {}, {
            startBearing,
            startPitch
          }));
        } else {
          newRotation = {
            bearing: startBearing + deltaAngleX,
            pitch: startPitch + deltaAngleY
          };
        }
        return this._getUpdatedState(newRotation);
      }
    }, {
      key: "rotateEnd",
      value: function rotateEnd() {
        return this._getUpdatedState({
          startBearing: null,
          startPitch: null
        });
      }
    }, {
      key: "zoomStart",
      value: function zoomStart(_ref6) {
        var pos = _ref6.pos;
        return this._getUpdatedState({
          startZoomLngLat: this._unproject(pos),
          startZoom: this._viewportProps.zoom
        });
      }
    }, {
      key: "zoom",
      value: function zoom(_ref7) {
        var pos = _ref7.pos, startPos = _ref7.startPos, scale5 = _ref7.scale;
        var _this$_state2 = this._state, startZoom = _this$_state2.startZoom, startZoomLngLat = _this$_state2.startZoomLngLat;
        if (!Number.isFinite(startZoom)) {
          startZoom = this._viewportProps.zoom;
          startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
        }
        var zoom2 = this._calculateNewZoom({
          scale: scale5,
          startZoom
        });
        var zoomedViewport = this.makeViewport(_objectSpread23(_objectSpread23({}, this._viewportProps), {}, {
          zoom: zoom2
        }));
        var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({
          lngLat: startZoomLngLat,
          pos
        }), _zoomedViewport$getMa2 = _slicedToArray(_zoomedViewport$getMa, 2), longitude = _zoomedViewport$getMa2[0], latitude = _zoomedViewport$getMa2[1];
        return this._getUpdatedState({
          zoom: zoom2,
          longitude,
          latitude
        });
      }
    }, {
      key: "zoomEnd",
      value: function zoomEnd() {
        return this._getUpdatedState({
          startZoomLngLat: null,
          startZoom: null
        });
      }
    }, {
      key: "zoomIn",
      value: function zoomIn() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
        return this._zoomFromCenter(speed);
      }
    }, {
      key: "zoomOut",
      value: function zoomOut() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
        return this._zoomFromCenter(1 / speed);
      }
    }, {
      key: "moveLeft",
      value: function moveLeft() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        return this._panFromCenter([speed, 0]);
      }
    }, {
      key: "moveRight",
      value: function moveRight() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        return this._panFromCenter([-speed, 0]);
      }
    }, {
      key: "moveUp",
      value: function moveUp() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        return this._panFromCenter([0, speed]);
      }
    }, {
      key: "moveDown",
      value: function moveDown() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        return this._panFromCenter([0, -speed]);
      }
    }, {
      key: "rotateLeft",
      value: function rotateLeft() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
        return this._getUpdatedState({
          bearing: this._viewportProps.bearing - speed
        });
      }
    }, {
      key: "rotateRight",
      value: function rotateRight() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
        return this._getUpdatedState({
          bearing: this._viewportProps.bearing + speed
        });
      }
    }, {
      key: "rotateUp",
      value: function rotateUp() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
        return this._getUpdatedState({
          pitch: this._viewportProps.pitch + speed
        });
      }
    }, {
      key: "rotateDown",
      value: function rotateDown() {
        var speed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
        return this._getUpdatedState({
          pitch: this._viewportProps.pitch - speed
        });
      }
    }, {
      key: "shortestPathFrom",
      value: function shortestPathFrom(viewState) {
        var fromProps = viewState.getViewportProps();
        var props = Object.assign({}, this._viewportProps);
        var bearing = props.bearing, longitude = props.longitude;
        if (Math.abs(bearing - fromProps.bearing) > 180) {
          props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
        }
        if (Math.abs(longitude - fromProps.longitude) > 180) {
          props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
        }
        return props;
      }
    }, {
      key: "_zoomFromCenter",
      value: function _zoomFromCenter(scale5) {
        var _this$_viewportProps = this._viewportProps, width = _this$_viewportProps.width, height = _this$_viewportProps.height;
        return this.zoom({
          pos: [width / 2, height / 2],
          scale: scale5
        });
      }
    }, {
      key: "_panFromCenter",
      value: function _panFromCenter(offset) {
        var _this$_viewportProps2 = this._viewportProps, width = _this$_viewportProps2.width, height = _this$_viewportProps2.height;
        return this.pan({
          startPos: [width / 2, height / 2],
          pos: [width / 2 + offset[0], height / 2 + offset[1]]
        });
      }
    }, {
      key: "_getUpdatedState",
      value: function _getUpdatedState(newProps) {
        return new this.constructor(_objectSpread23(_objectSpread23(_objectSpread23({
          makeViewport: this.makeViewport
        }, this._viewportProps), this._state), newProps));
      }
    }, {
      key: "_applyConstraints",
      value: function _applyConstraints(props) {
        var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom;
        props.zoom = clamp(zoom, minZoom, maxZoom);
        var maxPitch = props.maxPitch, minPitch = props.minPitch, pitch = props.pitch;
        props.pitch = clamp(pitch, minPitch, maxPitch);
        Object.assign(props, normalizeViewportProps(props));
        return props;
      }
    }, {
      key: "_unproject",
      value: function _unproject(pos) {
        var viewport3 = this.makeViewport(this._viewportProps);
        return pos && viewport3.unproject(pos);
      }
    }, {
      key: "_calculateNewLngLat",
      value: function _calculateNewLngLat(_ref8) {
        var startPanLngLat = _ref8.startPanLngLat, pos = _ref8.pos;
        var viewport3 = this.makeViewport(this._viewportProps);
        return viewport3.getMapCenterByLngLatPosition({
          lngLat: startPanLngLat,
          pos
        });
      }
    }, {
      key: "_calculateNewZoom",
      value: function _calculateNewZoom(_ref9) {
        var scale5 = _ref9.scale, startZoom = _ref9.startZoom;
        var _this$_viewportProps3 = this._viewportProps, maxZoom = _this$_viewportProps3.maxZoom, minZoom = _this$_viewportProps3.minZoom;
        var zoom = startZoom + Math.log2(scale5);
        return clamp(zoom, minZoom, maxZoom);
      }
    }, {
      key: "_calculateNewPitchAndBearing",
      value: function _calculateNewPitchAndBearing(_ref10) {
        var deltaScaleX = _ref10.deltaScaleX, deltaScaleY = _ref10.deltaScaleY, startBearing = _ref10.startBearing, startPitch = _ref10.startPitch;
        deltaScaleY = clamp(deltaScaleY, -1, 1);
        var _this$_viewportProps4 = this._viewportProps, minPitch = _this$_viewportProps4.minPitch, maxPitch = _this$_viewportProps4.maxPitch;
        var bearing = startBearing + 180 * deltaScaleX;
        var pitch = startPitch;
        if (deltaScaleY > 0) {
          pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
        } else if (deltaScaleY < 0) {
          pitch = startPitch - deltaScaleY * (minPitch - startPitch);
        }
        return {
          pitch,
          bearing
        };
      }
    }, {
      key: "_getRotationParams",
      value: function _getRotationParams(pos, startPos) {
        var deltaX = pos[0] - startPos[0];
        var deltaY = pos[1] - startPos[1];
        var centerY = pos[1];
        var startY = startPos[1];
        var _this$_viewportProps5 = this._viewportProps, width = _this$_viewportProps5.width, height = _this$_viewportProps5.height;
        var deltaScaleX = deltaX / width;
        var deltaScaleY = 0;
        if (deltaY > 0) {
          if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
            deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
          }
        } else if (deltaY < 0) {
          if (startY > PITCH_MOUSE_THRESHOLD) {
            deltaScaleY = 1 - centerY / startY;
          }
        }
        deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
        return {
          deltaScaleX,
          deltaScaleY
        };
      }
    }]);
    return MapState2;
  }(ViewState);
  var MapController = function(_Controller) {
    _inherits(MapController2, _Controller);
    var _super2 = _createSuper30(MapController2);
    function MapController2(props) {
      _classCallCheck(this, MapController2);
      props.dragMode = props.dragMode || "pan";
      return _super2.call(this, MapState, props);
    }
    _createClass(MapController2, [{
      key: "_getTransitionProps",
      value: function _getTransitionProps(opts) {
        return opts ? _objectSpread23(_objectSpread23({}, LINEAR_TRANSITION_PROPS), {}, {
          transitionInterpolator: new LinearInterpolator(_objectSpread23(_objectSpread23({}, opts), {}, {
            makeViewport: this.controllerState.makeViewport
          }))
        }) : LINEAR_TRANSITION_PROPS;
      }
    }]);
    return MapController2;
  }(Controller);

  // node_modules/@deck.gl/core/dist/esm/views/map-view.js
  function _createSuper31(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct32();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct32() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var MapView = function(_View) {
    _inherits(MapView2, _View);
    var _super = _createSuper31(MapView2);
    function MapView2(props) {
      _classCallCheck(this, MapView2);
      return _super.call(this, Object.assign({}, props, {
        type: WebMercatorViewport2
      }));
    }
    _createClass(MapView2, [{
      key: "controller",
      get: function get2() {
        return this._getControllerProps({
          type: MapController
        });
      }
    }]);
    return MapView2;
  }(View);
  MapView.displayName = "MapView";

  // node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js
  function _createForOfIteratorHelper39(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray40(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray40(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray40(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray40(o, minLen);
  }
  function _arrayLikeToArray40(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
  var EffectManager = function() {
    function EffectManager2() {
      _classCallCheck(this, EffectManager2);
      this.effects = [];
      this._internalEffects = [];
      this._needsRedraw = "Initial render";
      this.setEffects();
    }
    _createClass(EffectManager2, [{
      key: "setProps",
      value: function setProps(props) {
        if ("effects" in props) {
          if (props.effects.length !== this.effects.length || !deepEqual(props.effects, this.effects)) {
            this.setEffects(props.effects);
            this._needsRedraw = "effects changed";
          }
        }
      }
    }, {
      key: "needsRedraw",
      value: function needsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        var redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        return redraw;
      }
    }, {
      key: "getEffects",
      value: function getEffects() {
        return this._internalEffects;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.cleanup();
      }
    }, {
      key: "setEffects",
      value: function setEffects() {
        var effects = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        this.cleanup();
        this.effects = effects;
        this._createInternalEffects();
      }
    }, {
      key: "cleanup",
      value: function cleanup() {
        var _iterator = _createForOfIteratorHelper39(this.effects), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var effect = _step.value;
            effect.cleanup();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var _iterator2 = _createForOfIteratorHelper39(this._internalEffects), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _effect = _step2.value;
            _effect.cleanup();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this.effects.length = 0;
        this._internalEffects.length = 0;
      }
    }, {
      key: "_createInternalEffects",
      value: function _createInternalEffects() {
        this._internalEffects = this.effects.slice();
        if (!this.effects.some(function(effect) {
          return effect instanceof LightingEffect;
        })) {
          this._internalEffects.push(DEFAULT_LIGHTING_EFFECT);
        }
      }
    }]);
    return EffectManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js
  function _createSuper32(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct33();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct33() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DrawLayersPass = function(_LayersPass) {
    _inherits(DrawLayersPass2, _LayersPass);
    var _super = _createSuper32(DrawLayersPass2);
    function DrawLayersPass2() {
      _classCallCheck(this, DrawLayersPass2);
      return _super.apply(this, arguments);
    }
    return DrawLayersPass2;
  }(LayersPass);

  // node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js
  function ownKeys24(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread24(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys24(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys24(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper33(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct34();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct34() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var PICKING_PARAMETERS = {
    blendFunc: [1, 0, 32771, 0],
    blendEquation: 32774
  };
  var PickLayersPass = function(_LayersPass) {
    _inherits(PickLayersPass2, _LayersPass);
    var _super = _createSuper33(PickLayersPass2);
    function PickLayersPass2() {
      _classCallCheck(this, PickLayersPass2);
      return _super.apply(this, arguments);
    }
    _createClass(PickLayersPass2, [{
      key: "render",
      value: function render(props) {
        if (props.pickingFBO) {
          this.useAlpha = true;
          this._drawPickingBuffer(props);
        } else {
          this.useAlpha = false;
          _get(_getPrototypeOf(PickLayersPass2.prototype), "render", this).call(this, props);
        }
      }
    }, {
      key: "_drawPickingBuffer",
      value: function _drawPickingBuffer(_ref) {
        var _this = this;
        var layers = _ref.layers, layerFilter = _ref.layerFilter, views = _ref.views, viewports = _ref.viewports, onViewportActive = _ref.onViewportActive, pickingFBO = _ref.pickingFBO, _ref$deviceRect = _ref.deviceRect, x = _ref$deviceRect.x, y = _ref$deviceRect.y, width = _ref$deviceRect.width, height = _ref$deviceRect.height, _ref$pass = _ref.pass, pass = _ref$pass === void 0 ? "picking" : _ref$pass, redrawReason = _ref.redrawReason, pickZ = _ref.pickZ;
        var gl = this.gl;
        this.pickZ = pickZ;
        return withParameters(gl, _objectSpread24(_objectSpread24({
          scissorTest: true,
          scissor: [x, y, width, height],
          clearColor: [0, 0, 0, 0],
          depthMask: true,
          depthTest: true,
          depthRange: [0, 1],
          colorMask: [true, true, true, true]
        }, PICKING_PARAMETERS), {}, {
          blend: !pickZ
        }), function() {
          _get(_getPrototypeOf(PickLayersPass2.prototype), "render", _this).call(_this, {
            target: pickingFBO,
            layers,
            layerFilter,
            views,
            viewports,
            onViewportActive,
            pass,
            redrawReason
          });
        });
      }
    }, {
      key: "shouldDrawLayer",
      value: function shouldDrawLayer(layer) {
        return layer.props.pickable;
      }
    }, {
      key: "getModuleParameters",
      value: function getModuleParameters() {
        return {
          pickingActive: 1,
          pickingAttribute: this.pickZ,
          lightSources: {}
        };
      }
    }, {
      key: "getLayerParameters",
      value: function getLayerParameters(layer, layerIndex) {
        var pickParameters = this.pickZ ? {
          blend: false
        } : _objectSpread24(_objectSpread24({}, PICKING_PARAMETERS), {}, {
          blend: true,
          blendColor: [0, 0, 0, this.useAlpha ? (layerIndex + 1) / 255 : 1]
        });
        return Object.assign({}, layer.props.parameters, pickParameters);
      }
    }]);
    return PickLayersPass2;
  }(LayersPass);

  // node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js
  function _createForOfIteratorHelper40(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray41(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray41(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray41(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray41(o, minLen);
  }
  function _arrayLikeToArray41(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys25(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread25(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys25(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys25(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
  var DeckRenderer = function() {
    function DeckRenderer2(gl) {
      _classCallCheck(this, DeckRenderer2);
      this.gl = gl;
      this.layerFilter = null;
      this.drawPickingColors = false;
      this.drawLayersPass = new DrawLayersPass(gl);
      this.pickLayersPass = new PickLayersPass(gl);
      this.renderCount = 0;
      this._needsRedraw = "Initial render";
      this.renderBuffers = [];
      this.lastPostProcessEffect = null;
      this._onError = null;
    }
    _createClass(DeckRenderer2, [{
      key: "setProps",
      value: function setProps(props) {
        if ("layerFilter" in props && this.layerFilter !== props.layerFilter) {
          this.layerFilter = props.layerFilter;
          this._needsRedraw = "layerFilter changed";
        }
        if ("drawPickingColors" in props && this.drawPickingColors !== props.drawPickingColors) {
          this.drawPickingColors = props.drawPickingColors;
          this._needsRedraw = "drawPickingColors changed";
        }
        if ("onError" in props) {
          this._onError = props.onError;
        }
      }
    }, {
      key: "renderLayers",
      value: function renderLayers(opts) {
        var layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
        opts.layerFilter = this.layerFilter;
        opts.onError = this._onError;
        opts.effects = opts.effects || [];
        opts.target = opts.target || Framebuffer.getDefaultFramebuffer(this.gl);
        this._preRender(opts.effects, opts);
        var outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : opts.target;
        var renderStats = layerPass.render(_objectSpread25(_objectSpread25({}, opts), {}, {
          target: outputBuffer
        }));
        this._postRender(opts.effects, opts);
        this.renderCount++;
        debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
      }
    }, {
      key: "needsRedraw",
      value: function needsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        var redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        return redraw;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        var renderBuffers = this.renderBuffers;
        var _iterator = _createForOfIteratorHelper40(renderBuffers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var buffer = _step.value;
            buffer["delete"]();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        renderBuffers.length = 0;
      }
    }, {
      key: "_preRender",
      value: function _preRender(effects, opts) {
        var lastPostProcessEffect = null;
        var _iterator2 = _createForOfIteratorHelper40(effects), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var effect = _step2.value;
            effect.preRender(this.gl, opts);
            if (effect.postRender) {
              lastPostProcessEffect = effect;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (lastPostProcessEffect) {
          this._resizeRenderBuffers();
        }
        this.lastPostProcessEffect = lastPostProcessEffect;
      }
    }, {
      key: "_resizeRenderBuffers",
      value: function _resizeRenderBuffers() {
        var renderBuffers = this.renderBuffers;
        if (renderBuffers.length === 0) {
          renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
        }
        var _iterator3 = _createForOfIteratorHelper40(renderBuffers), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var buffer = _step3.value;
            buffer.resize();
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender(effects, opts) {
        var renderBuffers = this.renderBuffers;
        var params = {
          inputBuffer: renderBuffers[0],
          swapBuffer: renderBuffers[1],
          target: null
        };
        var _iterator4 = _createForOfIteratorHelper40(effects), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var effect = _step4.value;
            if (effect.postRender) {
              if (effect === this.lastPostProcessEffect) {
                params.target = opts.target;
                effect.postRender(this.gl, params);
                break;
              }
              var buffer = effect.postRender(this.gl, params);
              params.inputBuffer = buffer;
              params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }]);
    return DeckRenderer2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js
  var NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedLayer: null,
    pickedObjectIndex: -1
  };
  function getClosestObject(_ref) {
    var pickedColors = _ref.pickedColors, layers = _ref.layers, deviceX = _ref.deviceX, deviceY = _ref.deviceY, deviceRadius = _ref.deviceRadius, deviceRect = _ref.deviceRect;
    if (pickedColors) {
      var x = deviceRect.x, y = deviceRect.y, width = deviceRect.width, height = deviceRect.height;
      var minSquareDistanceToCenter = deviceRadius * deviceRadius;
      var closestPixelIndex = -1;
      var i = 0;
      for (var row = 0; row < height; row++) {
        var dy = row + y - deviceY;
        var dy2 = dy * dy;
        if (dy2 > minSquareDistanceToCenter) {
          i += 4 * width;
        } else {
          for (var col = 0; col < width; col++) {
            var pickedLayerIndex = pickedColors[i + 3] - 1;
            if (pickedLayerIndex >= 0) {
              var dx = col + x - deviceX;
              var d2 = dx * dx + dy2;
              if (d2 <= minSquareDistanceToCenter) {
                minSquareDistanceToCenter = d2;
                closestPixelIndex = i;
              }
            }
            i += 4;
          }
        }
      }
      if (closestPixelIndex >= 0) {
        var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;
        var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
        var pickedLayer = layers[_pickedLayerIndex];
        if (pickedLayer) {
          var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
          var _dy = Math.floor(closestPixelIndex / 4 / width);
          var _dx = closestPixelIndex / 4 - _dy * width;
          return {
            pickedColor,
            pickedLayer,
            pickedObjectIndex,
            pickedX: x + _dx,
            pickedY: y + _dy
          };
        }
        log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
      }
    }
    return NO_PICKED_OBJECT;
  }
  function getUniqueObjects(_ref2) {
    var pickedColors = _ref2.pickedColors, layers = _ref2.layers;
    var uniqueColors = new Map();
    if (pickedColors) {
      for (var i = 0; i < pickedColors.length; i += 4) {
        var pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          var pickedColor = pickedColors.slice(i, i + 4);
          var colorKey = pickedColor.join(",");
          if (!uniqueColors.has(colorKey)) {
            var pickedLayer = layers[pickedLayerIndex];
            if (pickedLayer) {
              uniqueColors.set(colorKey, {
                pickedColor,
                pickedLayer,
                pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
              });
            } else {
              log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
          }
        }
      }
    }
    return Array.from(uniqueColors.values());
  }

  // node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js
  function getEmptyPickingInfo(_ref) {
    var pickInfo = _ref.pickInfo, mode = _ref.mode, viewports = _ref.viewports, layerFilter = _ref.layerFilter, pixelRatio = _ref.pixelRatio, x = _ref.x, y = _ref.y, z = _ref.z;
    var layer = pickInfo && pickInfo.pickedLayer;
    var viewportFilter = layerFilter && layer && function(v) {
      return layerFilter({
        layer,
        viewport: v,
        isPicking: true,
        renderPass: "picking:".concat(mode)
      });
    };
    var viewport3 = getViewportFromCoordinates(viewports, {
      x,
      y
    }, viewportFilter);
    var coordinate = viewport3 && viewport3.unproject([x - viewport3.x, y - viewport3.y], {
      targetZ: z
    });
    return {
      color: null,
      layer: null,
      viewport: viewport3,
      index: -1,
      picked: false,
      x,
      y,
      pixel: [x, y],
      coordinate,
      devicePixel: pickInfo && [pickInfo.pickedX, pickInfo.pickedY],
      pixelRatio
    };
  }
  function processPickInfo(opts) {
    var pickInfo = opts.pickInfo, lastPickedInfo = opts.lastPickedInfo, mode = opts.mode, layers = opts.layers;
    var pickedColor = pickInfo.pickedColor, pickedLayer = pickInfo.pickedLayer, pickedObjectIndex = pickInfo.pickedObjectIndex;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];
    if (mode === "hover") {
      var lastPickedObjectIndex = lastPickedInfo.index;
      var lastPickedLayerId = lastPickedInfo.layerId;
      var pickedLayerId = pickedLayer && pickedLayer.props.id;
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          var lastPickedLayer = layers.find(function(layer) {
            return layer.props.id === lastPickedLayerId;
          });
          if (lastPickedLayer) {
            affectedLayers.unshift(lastPickedLayer);
          }
        }
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
        lastPickedInfo.info = null;
      }
    }
    var baseInfo = getEmptyPickingInfo(opts);
    var infos = new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach(function(layer) {
      var info = Object.assign({}, baseInfo);
      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }
      info = getLayerPickingInfo({
        layer,
        info,
        mode
      });
      if (layer === pickedLayer && mode === "hover") {
        lastPickedInfo.info = info;
      }
      if (info) {
        infos.set(info.layer.id, info);
      }
      if (mode === "hover" && layer.props.autoHighlight) {
        var pickingModuleParameters = {
          pickingSelectedColor: pickedLayer === layer ? pickedColor : null
        };
        var highlightColor = layer.props.highlightColor;
        if (pickedLayer === layer && typeof highlightColor === "function") {
          pickingModuleParameters.pickingHighlightColor = highlightColor(info);
        }
        layer.setModuleParameters(pickingModuleParameters);
        layer.setNeedsRedraw();
      }
    });
    return infos;
  }
  function getLayerPickingInfo(_ref2) {
    var layer = _ref2.layer, info = _ref2.info, mode = _ref2.mode;
    while (layer && info) {
      var sourceLayer = info.layer || layer;
      info.layer = layer;
      info = layer.getPickingInfo({
        info,
        mode,
        sourceLayer
      });
      layer = layer.parent;
    }
    return info;
  }
  function getViewportFromCoordinates(viewports, pixel, filter) {
    for (var i = viewports.length - 1; i >= 0; i--) {
      var viewport3 = viewports[i];
      if (viewport3.containsPixel(pixel) && (!filter || filter(viewport3))) {
        return viewport3;
      }
    }
    return viewports[0];
  }

  // node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js
  function _createForOfIteratorHelper41(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray42(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray42(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray42(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray42(o, minLen);
  }
  function _arrayLikeToArray42(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DeckPicker = function() {
    function DeckPicker2(gl) {
      _classCallCheck(this, DeckPicker2);
      this.gl = gl;
      this.pickingFBO = null;
      this.pickLayersPass = new PickLayersPass(gl);
      this.layerFilter = null;
      this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
      this._onError = null;
    }
    _createClass(DeckPicker2, [{
      key: "setProps",
      value: function setProps(props) {
        if ("layerFilter" in props) {
          this.layerFilter = props.layerFilter;
        }
        if ("onError" in props) {
          this._onError = props.onError;
        }
        if ("_pickable" in props) {
          this._pickable = props._pickable;
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        if (this.pickingFBO) {
          this.pickingFBO["delete"]();
        }
        if (this.depthFBO) {
          this.depthFBO.color["delete"]();
          this.depthFBO["delete"]();
        }
      }
    }, {
      key: "pickObject",
      value: function pickObject(opts) {
        return this._pickClosestObject(opts);
      }
    }, {
      key: "pickObjects",
      value: function pickObjects(opts) {
        return this._pickVisibleObjects(opts);
      }
    }, {
      key: "getLastPickedObject",
      value: function getLastPickedObject(_ref) {
        var x = _ref.x, y = _ref.y, layers = _ref.layers, viewports = _ref.viewports;
        var lastPickedInfo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
        var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
        var lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
        var layer = lastPickedLayerId ? layers.find(function(l) {
          return l.id === lastPickedLayerId;
        }) : null;
        var viewport3 = lastPickedViewportId && viewports.find(function(v) {
          return v.id === lastPickedViewportId;
        }) || viewports[0];
        var coordinate = viewport3 && viewport3.unproject([x - viewport3.x, y - viewport3.y]);
        var info = {
          x,
          y,
          viewport: viewport3,
          coordinate,
          layer
        };
        if (layer) {
          return Object.assign({}, lastPickedInfo, info);
        }
        return Object.assign(info, {
          color: null,
          object: null,
          index: -1
        });
      }
    }, {
      key: "_resizeBuffer",
      value: function _resizeBuffer() {
        var gl = this.gl;
        if (!this.pickingFBO) {
          this.pickingFBO = new Framebuffer(gl);
          if (Framebuffer.isSupported(gl, {
            colorBufferFloat: true
          })) {
            this.depthFBO = new Framebuffer(gl);
            this.depthFBO.attach(_defineProperty({}, 36064, new Texture2D(gl, {
              format: isWebGL2(gl) ? 34836 : 6408,
              type: 5126
            })));
          }
        }
        this.pickingFBO.resize({
          width: gl.canvas.width,
          height: gl.canvas.height
        });
        if (this.depthFBO) {
          this.depthFBO.resize({
            width: gl.canvas.width,
            height: gl.canvas.height
          });
        }
        return this.pickingFBO;
      }
    }, {
      key: "_getPickable",
      value: function _getPickable(layers) {
        if (this._pickable === false) {
          return null;
        }
        var pickableLayers = layers.filter(function(layer) {
          return layer.isPickable() && !layer.isComposite;
        });
        if (pickableLayers.length > 255) {
          log_default.warn("Too many pickable layers, only picking the first 255")();
          return pickableLayers.slice(0, 255);
        }
        return pickableLayers.length ? pickableLayers : null;
      }
    }, {
      key: "_pickClosestObject",
      value: function _pickClosestObject(_ref2) {
        var layers = _ref2.layers, views = _ref2.views, viewports = _ref2.viewports, x = _ref2.x, y = _ref2.y, _ref2$radius = _ref2.radius, radius = _ref2$radius === void 0 ? 0 : _ref2$radius, _ref2$depth = _ref2.depth, depth = _ref2$depth === void 0 ? 1 : _ref2$depth, _ref2$mode = _ref2.mode, mode = _ref2$mode === void 0 ? "query" : _ref2$mode, unproject3D = _ref2.unproject3D, onViewportActive = _ref2.onViewportActive;
        layers = this._getPickable(layers);
        if (!layers) {
          return {
            result: [],
            emptyInfo: getEmptyPickingInfo({
              viewports,
              x,
              y
            })
          };
        }
        this._resizeBuffer();
        var pixelRatio = cssToDeviceRatio(this.gl);
        var devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);
        var devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
        var deviceRadius = Math.round(radius * pixelRatio);
        var _this$pickingFBO = this.pickingFBO, width = _this$pickingFBO.width, height = _this$pickingFBO.height;
        var deviceRect = this._getPickingRect({
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceWidth: width,
          deviceHeight: height
        });
        var infos;
        var result = [];
        var affectedLayers = {};
        for (var i = 0; i < depth; i++) {
          var pickedColors = deviceRect && this._drawAndSample({
            layers,
            views,
            viewports,
            onViewportActive,
            deviceRect,
            pass: "picking:".concat(mode),
            redrawReason: mode
          });
          var pickInfo = getClosestObject({
            pickedColors,
            layers,
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceRect
          });
          var z = void 0;
          if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
            var zValues = this._drawAndSample({
              layers: [pickInfo.pickedLayer],
              views,
              viewports,
              onViewportActive,
              deviceRect: {
                x: pickInfo.pickedX,
                y: pickInfo.pickedY,
                width: 1,
                height: 1
              },
              pass: "picking:".concat(mode),
              redrawReason: "pick-z",
              pickZ: true
            });
            z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];
          }
          if (pickInfo.pickedColor && i + 1 < depth) {
            var layerId = pickInfo.pickedColor[3] - 1;
            affectedLayers[layerId] = true;
            layers[layerId].disablePickingIndex(pickInfo.pickedObjectIndex);
          }
          infos = processPickInfo({
            pickInfo,
            lastPickedInfo: this.lastPickedInfo,
            mode,
            layers,
            layerFilter: this.layerFilter,
            viewports,
            x,
            y,
            z,
            pixelRatio
          });
          var _iterator = _createForOfIteratorHelper41(infos.values()), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var info = _step.value;
              if (info.layer) {
                result.push(info);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!pickInfo.pickedColor) {
            break;
          }
        }
        for (var _layerId in affectedLayers) {
          layers[_layerId].restorePickingColors();
        }
        return {
          result,
          emptyInfo: infos && infos.get(null)
        };
      }
    }, {
      key: "_pickVisibleObjects",
      value: function _pickVisibleObjects(_ref3) {
        var layers = _ref3.layers, views = _ref3.views, viewports = _ref3.viewports, x = _ref3.x, y = _ref3.y, _ref3$width = _ref3.width, width = _ref3$width === void 0 ? 1 : _ref3$width, _ref3$height = _ref3.height, height = _ref3$height === void 0 ? 1 : _ref3$height, _ref3$mode = _ref3.mode, mode = _ref3$mode === void 0 ? "query" : _ref3$mode, _ref3$maxObjects = _ref3.maxObjects, maxObjects = _ref3$maxObjects === void 0 ? null : _ref3$maxObjects, onViewportActive = _ref3.onViewportActive;
        layers = this._getPickable(layers);
        if (!layers) {
          return [];
        }
        this._resizeBuffer();
        var pixelRatio = cssToDeviceRatio(this.gl);
        var leftTop = cssToDevicePixels(this.gl, [x, y], true);
        var deviceLeft = leftTop.x;
        var deviceTop = leftTop.y + leftTop.height;
        var rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);
        var deviceRight = rightBottom.x + rightBottom.width;
        var deviceBottom = rightBottom.y;
        var deviceRect = {
          x: deviceLeft,
          y: deviceBottom,
          width: deviceRight - deviceLeft,
          height: deviceTop - deviceBottom
        };
        var pickedColors = this._drawAndSample({
          layers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          pass: "picking:".concat(mode),
          redrawReason: mode
        });
        var pickInfos = getUniqueObjects({
          pickedColors,
          layers
        });
        var uniqueInfos = new Map();
        var isMaxObjects = Number.isFinite(maxObjects);
        for (var i = 0; i < pickInfos.length; i++) {
          if (isMaxObjects && uniqueInfos.size >= maxObjects) {
            break;
          }
          var pickInfo = pickInfos[i];
          var info = {
            color: pickInfo.pickedColor,
            layer: null,
            index: pickInfo.pickedObjectIndex,
            picked: true,
            x,
            y,
            width,
            height,
            pixelRatio
          };
          info = getLayerPickingInfo({
            layer: pickInfo.pickedLayer,
            info,
            mode
          });
          if (!uniqueInfos.has(info.object)) {
            uniqueInfos.set(info.object, info);
          }
        }
        return Array.from(uniqueInfos.values());
      }
    }, {
      key: "_drawAndSample",
      value: function _drawAndSample(_ref4) {
        var layers = _ref4.layers, views = _ref4.views, viewports = _ref4.viewports, onViewportActive = _ref4.onViewportActive, deviceRect = _ref4.deviceRect, pass = _ref4.pass, redrawReason = _ref4.redrawReason, pickZ = _ref4.pickZ;
        assert8(deviceRect.width > 0 && deviceRect.height > 0);
        if (layers.length < 1) {
          return null;
        }
        var pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
        this.pickLayersPass.render({
          layers,
          layerFilter: this.layerFilter,
          onError: this._onError,
          views,
          viewports,
          onViewportActive,
          pickingFBO,
          deviceRect,
          pass,
          redrawReason,
          pickZ
        });
        var x = deviceRect.x, y = deviceRect.y, width = deviceRect.width, height = deviceRect.height;
        var pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
        readPixelsToArray(pickingFBO, {
          sourceX: x,
          sourceY: y,
          sourceWidth: width,
          sourceHeight: height,
          target: pickedColors
        });
        return pickedColors;
      }
    }, {
      key: "_getPickingRect",
      value: function _getPickingRect(_ref5) {
        var deviceX = _ref5.deviceX, deviceY = _ref5.deviceY, deviceRadius = _ref5.deviceRadius, deviceWidth = _ref5.deviceWidth, deviceHeight = _ref5.deviceHeight;
        var x = Math.max(0, deviceX - deviceRadius);
        var y = Math.max(0, deviceY - deviceRadius);
        var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
        var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
        if (width <= 0 || height <= 0) {
          return null;
        }
        return {
          x,
          y,
          width,
          height
        };
      }
    }]);
    return DeckPicker2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/tooltip.js
  var defaultStyle = {
    zIndex: 1,
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: 0,
    left: 0,
    display: "none"
  };
  var Tooltip = function() {
    function Tooltip2(canvas) {
      _classCallCheck(this, Tooltip2);
      var canvasParent = canvas.parentElement;
      if (canvasParent) {
        this.el = document.createElement("div");
        this.el.className = "deck-tooltip";
        Object.assign(this.el.style, defaultStyle);
        canvasParent.appendChild(this.el);
      }
    }
    _createClass(Tooltip2, [{
      key: "setTooltip",
      value: function setTooltip(displayInfo, x, y) {
        var el = this.el;
        if (typeof displayInfo === "string") {
          el.innerText = displayInfo;
        } else if (!displayInfo) {
          el.style.display = "none";
          return;
        } else {
          if ("text" in displayInfo) {
            el.innerText = displayInfo.text;
          }
          if ("html" in displayInfo) {
            el.innerHTML = displayInfo.html;
          }
          if ("className" in displayInfo) {
            el.className = displayInfo.className;
          }
          Object.assign(el.style, displayInfo.style);
        }
        el.style.display = "block";
        el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
      }
    }, {
      key: "remove",
      value: function remove() {
        if (this.el) {
          this.el.remove();
        }
      }
    }]);
    return Tooltip2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/deck.js
  var import_env7 = __toModule(require_env2());

  // node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  var import_hammerjs = __toModule(require_hammer());

  // node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  function some(array, predict) {
    for (var i = 0; i < array.length; i++) {
      if (predict(array[i])) {
        return true;
      }
    }
    return false;
  }
  function enhancePointerEventInput(PointerEventInput) {
    var oldHandler = PointerEventInput.prototype.handler;
    PointerEventInput.prototype.handler = function handler(ev) {
      var store = this.store;
      if (ev.button > 0) {
        if (!some(store, function(e) {
          return e.pointerId === ev.pointerId;
        })) {
          store.push(ev);
        }
      }
      oldHandler.call(this, ev);
    };
  }
  function enhanceMouseInput(MouseInput) {
    MouseInput.prototype.handler = function handler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type];
      if (eventType & INPUT_START && ev.button >= 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which === 0) {
        eventType = INPUT_END;
      }
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: "mouse",
        srcEvent: ev
      });
    };
  }

  // node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  enhancePointerEventInput(import_hammerjs.default.PointerEventInput);
  enhanceMouseInput(import_hammerjs.default.MouseInput);
  var Manager = import_hammerjs.default.Manager;
  var hammer_browser_default = import_hammerjs.default;

  // node_modules/mjolnir.js/dist/esm/constants.js
  var RECOGNIZERS = hammer_browser_default ? [[hammer_browser_default.Pan, {
    event: "tripan",
    pointers: 3,
    threshold: 0,
    enable: false
  }], [hammer_browser_default.Rotate, {
    enable: false
  }], [hammer_browser_default.Pinch, {
    enable: false
  }], [hammer_browser_default.Swipe, {
    enable: false
  }], [hammer_browser_default.Pan, {
    threshold: 0,
    enable: false
  }], [hammer_browser_default.Press, {
    enable: false
  }], [hammer_browser_default.Tap, {
    event: "doubletap",
    taps: 2,
    enable: false
  }], [hammer_browser_default.Tap, {
    event: "anytap",
    enable: false
  }], [hammer_browser_default.Tap, {
    enable: false
  }]] : null;
  var RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ["rotate", "pinch", "pan"],
    rotate: ["pinch"],
    pinch: ["pan"],
    pan: ["press", "doubletap", "anytap", "tap"],
    doubletap: ["anytap"],
    anytap: ["tap"]
  };
  var RECOGNIZER_FALLBACK_MAP = {
    doubletap: ["tap"]
  };
  var BASIC_EVENT_ALIASES = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
  };
  var INPUT_EVENT_TYPES = {
    KEY_EVENTS: ["keydown", "keyup"],
    MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
    WHEEL_EVENTS: ["wheel", "mousewheel"]
  };
  var EVENT_RECOGNIZER_MAP = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
  };
  var GESTURE_EVENT_ALIASES = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
  };

  // node_modules/mjolnir.js/dist/esm/utils/globals.js
  var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var window_4 = typeof window !== "undefined" ? window : global;
  var global_6 = typeof global !== "undefined" ? global : window;
  var passiveSupported = false;
  try {
    options = {
      get passive() {
        passiveSupported = true;
        return true;
      }
    };
    window_4.addEventListener("test", options, options);
    window_4.removeEventListener("test", options, options);
  } catch (err) {
  }
  var options;

  // node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
  var firefox = userAgent.indexOf("firefox") !== -1;
  var WHEEL_EVENTS = INPUT_EVENT_TYPES.WHEEL_EVENTS;
  var EVENT_TYPE = "wheel";
  var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
  var WHEEL_DELTA_PER_LINE = 40;
  var SHIFT_MULTIPLIER = 0.25;
  var WheelInput = function() {
    function WheelInput2(element, callback) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      _classCallCheck(this, WheelInput2);
      this.element = element;
      this.callback = callback;
      this.options = Object.assign({
        enable: true
      }, options);
      this.events = WHEEL_EVENTS.concat(options.events || []);
      this.handleEvent = this.handleEvent.bind(this);
      this.events.forEach(function(event) {
        return element.addEventListener(event, _this.handleEvent, passiveSupported ? {
          passive: false
        } : false);
      });
    }
    _createClass(WheelInput2, [{
      key: "destroy",
      value: function destroy() {
        var _this2 = this;
        this.events.forEach(function(event) {
          return _this2.element.removeEventListener(event, _this2.handleEvent);
        });
      }
    }, {
      key: "enableEventType",
      value: function enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE) {
          this.options.enable = enabled;
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (!this.options.enable) {
          return;
        }
        var value17 = event.deltaY;
        if (window_4.WheelEvent) {
          if (firefox && event.deltaMode === window_4.WheelEvent.DOM_DELTA_PIXEL) {
            value17 /= window_4.devicePixelRatio;
          }
          if (event.deltaMode === window_4.WheelEvent.DOM_DELTA_LINE) {
            value17 *= WHEEL_DELTA_PER_LINE;
          }
        }
        var wheelPosition = {
          x: event.clientX,
          y: event.clientY
        };
        if (value17 !== 0 && value17 % WHEEL_DELTA_MAGIC_SCALER === 0) {
          value17 = Math.floor(value17 / WHEEL_DELTA_MAGIC_SCALER);
        }
        if (event.shiftKey && value17) {
          value17 = value17 * SHIFT_MULTIPLIER;
        }
        this._onWheel(event, -value17, wheelPosition);
      }
    }, {
      key: "_onWheel",
      value: function _onWheel(srcEvent, delta, position) {
        this.callback({
          type: EVENT_TYPE,
          center: position,
          delta,
          srcEvent,
          pointerType: "mouse",
          target: srcEvent.target
        });
      }
    }]);
    return WheelInput2;
  }();

  // node_modules/mjolnir.js/dist/esm/inputs/move-input.js
  var MOUSE_EVENTS = INPUT_EVENT_TYPES.MOUSE_EVENTS;
  var MOVE_EVENT_TYPE = "pointermove";
  var OVER_EVENT_TYPE = "pointerover";
  var OUT_EVENT_TYPE = "pointerout";
  var LEAVE_EVENT_TYPE = "pointerleave";
  var MoveInput = function() {
    function MoveInput2(element, callback) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      _classCallCheck(this, MoveInput2);
      this.element = element;
      this.callback = callback;
      this.pressed = false;
      this.options = Object.assign({
        enable: true
      }, options);
      this.enableMoveEvent = this.options.enable;
      this.enableLeaveEvent = this.options.enable;
      this.enableOutEvent = this.options.enable;
      this.enableOverEvent = this.options.enable;
      this.events = MOUSE_EVENTS.concat(options.events || []);
      this.handleEvent = this.handleEvent.bind(this);
      this.events.forEach(function(event) {
        return element.addEventListener(event, _this.handleEvent);
      });
    }
    _createClass(MoveInput2, [{
      key: "destroy",
      value: function destroy() {
        var _this2 = this;
        this.events.forEach(function(event) {
          return _this2.element.removeEventListener(event, _this2.handleEvent);
        });
      }
    }, {
      key: "enableEventType",
      value: function enableEventType(eventType, enabled) {
        if (eventType === MOVE_EVENT_TYPE) {
          this.enableMoveEvent = enabled;
        }
        if (eventType === OVER_EVENT_TYPE) {
          this.enableOverEvent = enabled;
        }
        if (eventType === OUT_EVENT_TYPE) {
          this.enableOutEvent = enabled;
        }
        if (eventType === LEAVE_EVENT_TYPE) {
          this.enableLeaveEvent = enabled;
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        this.handleOverEvent(event);
        this.handleOutEvent(event);
        this.handleLeaveEvent(event);
        this.handleMoveEvent(event);
      }
    }, {
      key: "handleOverEvent",
      value: function handleOverEvent(event) {
        if (this.enableOverEvent) {
          if (event.type === "mouseover") {
            this.callback({
              type: OVER_EVENT_TYPE,
              srcEvent: event,
              pointerType: "mouse",
              target: event.target
            });
          }
        }
      }
    }, {
      key: "handleOutEvent",
      value: function handleOutEvent(event) {
        if (this.enableOutEvent) {
          if (event.type === "mouseout") {
            this.callback({
              type: OUT_EVENT_TYPE,
              srcEvent: event,
              pointerType: "mouse",
              target: event.target
            });
          }
        }
      }
    }, {
      key: "handleLeaveEvent",
      value: function handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
          if (event.type === "mouseleave") {
            this.callback({
              type: LEAVE_EVENT_TYPE,
              srcEvent: event,
              pointerType: "mouse",
              target: event.target
            });
          }
        }
      }
    }, {
      key: "handleMoveEvent",
      value: function handleMoveEvent(event) {
        if (this.enableMoveEvent) {
          switch (event.type) {
            case "mousedown":
              if (event.button >= 0) {
                this.pressed = true;
              }
              break;
            case "mousemove":
              if (event.which === 0) {
                this.pressed = false;
              }
              if (!this.pressed) {
                this.callback({
                  type: MOVE_EVENT_TYPE,
                  srcEvent: event,
                  pointerType: "mouse",
                  target: event.target
                });
              }
              break;
            case "mouseup":
              this.pressed = false;
              break;
            default:
          }
        }
      }
    }]);
    return MoveInput2;
  }();

  // node_modules/mjolnir.js/dist/esm/inputs/key-input.js
  var KEY_EVENTS = INPUT_EVENT_TYPES.KEY_EVENTS;
  var DOWN_EVENT_TYPE = "keydown";
  var UP_EVENT_TYPE = "keyup";
  var KeyInput = function() {
    function KeyInput2(element, callback) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      _classCallCheck(this, KeyInput2);
      this.element = element;
      this.callback = callback;
      this.options = Object.assign({
        enable: true
      }, options);
      this.enableDownEvent = this.options.enable;
      this.enableUpEvent = this.options.enable;
      this.events = KEY_EVENTS.concat(options.events || []);
      this.handleEvent = this.handleEvent.bind(this);
      element.tabIndex = options.tabIndex || 0;
      element.style.outline = "none";
      this.events.forEach(function(event) {
        return element.addEventListener(event, _this.handleEvent);
      });
    }
    _createClass(KeyInput2, [{
      key: "destroy",
      value: function destroy() {
        var _this2 = this;
        this.events.forEach(function(event) {
          return _this2.element.removeEventListener(event, _this2.handleEvent);
        });
      }
    }, {
      key: "enableEventType",
      value: function enableEventType(eventType, enabled) {
        if (eventType === DOWN_EVENT_TYPE) {
          this.enableDownEvent = enabled;
        }
        if (eventType === UP_EVENT_TYPE) {
          this.enableUpEvent = enabled;
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        var targetElement = event.target || event.srcElement;
        if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
          return;
        }
        if (this.enableDownEvent && event.type === "keydown") {
          this.callback({
            type: DOWN_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
        if (this.enableUpEvent && event.type === "keyup") {
          this.callback({
            type: UP_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
      }
    }]);
    return KeyInput2;
  }();

  // node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
  var EVENT_TYPE2 = "contextmenu";
  var ContextmenuInput = function() {
    function ContextmenuInput2(element, callback) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      _classCallCheck(this, ContextmenuInput2);
      this.element = element;
      this.callback = callback;
      this.options = Object.assign({
        enable: true
      }, options);
      this.handleEvent = this.handleEvent.bind(this);
      element.addEventListener("contextmenu", this.handleEvent);
    }
    _createClass(ContextmenuInput2, [{
      key: "destroy",
      value: function destroy() {
        this.element.removeEventListener("contextmenu", this.handleEvent);
      }
    }, {
      key: "enableEventType",
      value: function enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE2) {
          this.options.enable = enabled;
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (!this.options.enable) {
          return;
        }
        this.callback({
          type: EVENT_TYPE2,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      }
    }]);
    return ContextmenuInput2;
  }();

  // node_modules/mjolnir.js/dist/esm/utils/event-utils.js
  var DOWN_EVENT = 1;
  var MOVE_EVENT = 2;
  var UP_EVENT = 4;
  var MOUSE_EVENTS2 = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
  };
  var MOUSE_EVENT_WHICH_LEFT = 1;
  var MOUSE_EVENT_WHICH_MIDDLE = 2;
  var MOUSE_EVENT_WHICH_RIGHT = 3;
  var MOUSE_EVENT_BUTTON_LEFT = 0;
  var MOUSE_EVENT_BUTTON_MIDDLE = 1;
  var MOUSE_EVENT_BUTTON_RIGHT = 2;
  var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
  var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
  var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  function whichButtons(event) {
    var eventType = MOUSE_EVENTS2[event.srcEvent.type];
    if (!eventType) {
      return null;
    }
    var _event$srcEvent = event.srcEvent, buttons = _event$srcEvent.buttons, button = _event$srcEvent.button, which = _event$srcEvent.which;
    var leftButton = false;
    var middleButton = false;
    var rightButton = false;
    if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
      leftButton = which === MOUSE_EVENT_WHICH_LEFT;
      middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
      rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === MOVE_EVENT) {
      leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
      middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
      rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === DOWN_EVENT) {
      leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
      middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
      rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return {
      leftButton,
      middleButton,
      rightButton
    };
  }
  function getOffsetPosition(event, rootElement) {
    var srcEvent = event.srcEvent;
    if (!event.center && !Number.isFinite(srcEvent.clientX)) {
      return null;
    }
    var center = event.center || {
      x: srcEvent.clientX,
      y: srcEvent.clientY
    };
    var rect = rootElement.getBoundingClientRect();
    var scaleX2 = rect.width / rootElement.offsetWidth || 1;
    var scaleY2 = rect.height / rootElement.offsetHeight || 1;
    var offsetCenter = {
      x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
      y: (center.y - rect.top - rootElement.clientTop) / scaleY2
    };
    return {
      center,
      offsetCenter
    };
  }

  // node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
  var DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
  };
  var EventRegistrar = function() {
    function EventRegistrar2(eventManager) {
      _classCallCheck(this, EventRegistrar2);
      this.eventManager = eventManager;
      this.handlers = [];
      this.handlersByElement = new Map();
      this.handleEvent = this.handleEvent.bind(this);
      this._active = false;
    }
    _createClass(EventRegistrar2, [{
      key: "isEmpty",
      value: function isEmpty() {
        return !this._active;
      }
    }, {
      key: "add",
      value: function add6(type, handler, opts) {
        var once = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        var passive = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        var handlers = this.handlers, handlersByElement = this.handlersByElement;
        if (opts && (_typeof(opts) !== "object" || opts.addEventListener)) {
          opts = {
            srcElement: opts
          };
        }
        opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;
        var entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
          entries = [];
          handlersByElement.set(opts.srcElement, entries);
        }
        var entry = {
          type,
          handler,
          srcElement: opts.srcElement,
          priority: opts.priority
        };
        if (once) {
          entry.once = true;
        }
        if (passive) {
          entry.passive = true;
        }
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        var insertPosition = entries.length - 1;
        while (insertPosition >= 0) {
          if (entries[insertPosition].priority >= entry.priority) {
            break;
          }
          insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
      }
    }, {
      key: "remove",
      value: function remove(type, handler) {
        var handlers = this.handlers, handlersByElement = this.handlersByElement;
        for (var i = handlers.length - 1; i >= 0; i--) {
          var entry = handlers[i];
          if (entry.type === type && entry.handler === handler) {
            handlers.splice(i, 1);
            var entries = handlersByElement.get(entry.srcElement);
            entries.splice(entries.indexOf(entry), 1);
            if (entries.length === 0) {
              handlersByElement["delete"](entry.srcElement);
            }
          }
        }
        this._active = handlers.some(function(entry2) {
          return !entry2.passive;
        });
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (this.isEmpty()) {
          return;
        }
        var mjolnirEvent = this._normalizeEvent(event);
        var target = event.srcEvent.target;
        while (target && target !== mjolnirEvent.rootElement) {
          this._emit(mjolnirEvent, target);
          if (mjolnirEvent.handled) {
            return;
          }
          target = target.parentNode;
        }
        this._emit(mjolnirEvent, "root");
      }
    }, {
      key: "_emit",
      value: function _emit(event, srcElement) {
        var entries = this.handlersByElement.get(srcElement);
        if (entries) {
          var immediatePropagationStopped = false;
          var stopPropagation = function stopPropagation2() {
            event.handled = true;
          };
          var stopImmediatePropagation = function stopImmediatePropagation2() {
            event.handled = true;
            immediatePropagationStopped = true;
          };
          var entriesToRemove = [];
          for (var i = 0; i < entries.length; i++) {
            var _entries$i = entries[i], type = _entries$i.type, handler = _entries$i.handler, once = _entries$i.once;
            handler(Object.assign({}, event, {
              type,
              stopPropagation,
              stopImmediatePropagation
            }));
            if (once) {
              entriesToRemove.push(entries[i]);
            }
            if (immediatePropagationStopped) {
              break;
            }
          }
          for (var _i = 0; _i < entriesToRemove.length; _i++) {
            var _entriesToRemove$_i = entriesToRemove[_i], _type = _entriesToRemove$_i.type, _handler = _entriesToRemove$_i.handler;
            this.remove(_type, _handler);
          }
        }
      }
    }, {
      key: "_normalizeEvent",
      value: function _normalizeEvent(event) {
        var rootElement = this.eventManager.element;
        return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {
          handled: false,
          rootElement
        });
      }
    }]);
    return EventRegistrar2;
  }();

  // node_modules/mjolnir.js/dist/esm/event-manager.js
  function _createForOfIteratorHelper42(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray43(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray43(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray43(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray43(o, minLen);
  }
  function _arrayLikeToArray43(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DEFAULT_OPTIONS2 = {
    events: null,
    recognizers: null,
    recognizerOptions: {},
    Manager,
    touchAction: "none",
    tabIndex: 0
  };
  var EventManager = function() {
    function EventManager2() {
      var element = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, EventManager2);
      this.options = Object.assign({}, DEFAULT_OPTIONS2, options);
      this.events = new Map();
      this._onBasicInput = this._onBasicInput.bind(this);
      this._onOtherEvent = this._onOtherEvent.bind(this);
      this.setElement(element);
      var events = options.events;
      if (events) {
        this.on(events);
      }
    }
    _createClass(EventManager2, [{
      key: "setElement",
      value: function setElement(element) {
        var _this = this;
        if (this.element) {
          this.destroy();
        }
        this.element = element;
        if (!element) {
          return;
        }
        var options = this.options;
        var ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
          touchAction: options.touchAction,
          recognizers: options.recognizers || RECOGNIZERS
        }).on("hammer.input", this._onBasicInput);
        if (!options.recognizers) {
          Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function(name) {
            var recognizer2 = _this.manager.get(name);
            if (recognizer2) {
              RECOGNIZER_COMPATIBLE_MAP[name].forEach(function(otherName) {
                recognizer2.recognizeWith(otherName);
              });
            }
          });
        }
        for (var recognizerName in options.recognizerOptions) {
          var recognizer = this.manager.get(recognizerName);
          if (recognizer) {
            var recognizerOption = options.recognizerOptions[recognizerName];
            delete recognizerOption.enable;
            recognizer.set(recognizerOption);
          }
        }
        this.wheelInput = new WheelInput(element, this._onOtherEvent, {
          enable: false
        });
        this.moveInput = new MoveInput(element, this._onOtherEvent, {
          enable: false
        });
        this.keyInput = new KeyInput(element, this._onOtherEvent, {
          enable: false,
          tabIndex: options.tabIndex
        });
        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
          enable: false
        });
        var _iterator = _createForOfIteratorHelper42(this.events), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), eventAlias = _step$value[0], eventRegistrar = _step$value[1];
            if (!eventRegistrar.isEmpty()) {
              this._toggleRecognizer(eventRegistrar.recognizerName, true);
              this.manager.on(eventAlias, eventRegistrar.handleEvent);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.element) {
          this.wheelInput.destroy();
          this.moveInput.destroy();
          this.keyInput.destroy();
          this.contextmenuInput.destroy();
          this.manager.destroy();
          this.wheelInput = null;
          this.moveInput = null;
          this.keyInput = null;
          this.contextmenuInput = null;
          this.manager = null;
          this.element = null;
        }
      }
    }, {
      key: "on",
      value: function on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
      }
    }, {
      key: "once",
      value: function once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
      }
    }, {
      key: "watch",
      value: function watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
      }
    }, {
      key: "off",
      value: function off(event, handler) {
        this._removeEventHandler(event, handler);
      }
    }, {
      key: "_toggleRecognizer",
      value: function _toggleRecognizer(name, enabled) {
        var manager = this.manager;
        if (!manager) {
          return;
        }
        var recognizer = manager.get(name);
        if (recognizer && recognizer.options.enable !== enabled) {
          recognizer.set({
            enable: enabled
          });
          var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
          if (fallbackRecognizers && !this.options.recognizers) {
            fallbackRecognizers.forEach(function(otherName) {
              var otherRecognizer = manager.get(otherName);
              if (enabled) {
                otherRecognizer.requireFailure(name);
                recognizer.dropRequireFailure(otherName);
              } else {
                otherRecognizer.dropRequireFailure(name);
              }
            });
          }
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
      }
    }, {
      key: "_addEventHandler",
      value: function _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== "string") {
          opts = handler;
          for (var eventName in event) {
            this._addEventHandler(eventName, event[eventName], opts, once, passive);
          }
          return;
        }
        var manager = this.manager, events = this.events;
        var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        var eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
          eventRegistrar = new EventRegistrar(this);
          events.set(eventAlias, eventRegistrar);
          eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
          if (manager) {
            manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
        }
      }
    }, {
      key: "_removeEventHandler",
      value: function _removeEventHandler(event, handler) {
        if (typeof event !== "string") {
          for (var eventName in event) {
            this._removeEventHandler(eventName, event[eventName]);
          }
          return;
        }
        var events = this.events;
        var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        var eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
          return;
        }
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
          var recognizerName = eventRegistrar.recognizerName;
          var isRecognizerUsed = false;
          var _iterator2 = _createForOfIteratorHelper42(events.values()), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var eh = _step2.value;
              if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
                isRecognizerUsed = true;
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (!isRecognizerUsed) {
            this._toggleRecognizer(recognizerName, false);
          }
        }
      }
    }, {
      key: "_onBasicInput",
      value: function _onBasicInput(event) {
        var srcEvent = event.srcEvent;
        var alias = BASIC_EVENT_ALIASES[srcEvent.type];
        if (alias) {
          this.manager.emit(alias, event);
        }
      }
    }, {
      key: "_onOtherEvent",
      value: function _onOtherEvent(event) {
        this.manager.emit(event.type, event);
      }
    }]);
    return EventManager2;
  }();

  // node_modules/@deck.gl/core/dist/esm/lib/deck.js
  function ownKeys26(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread26(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys26(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys26(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper43(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray44(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray44(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray44(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray44(o, minLen);
  }
  function _arrayLikeToArray44(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function noop5() {
  }
  var getCursor = function getCursor2(_ref) {
    var isDragging = _ref.isDragging;
    return isDragging ? "grabbing" : "grab";
  };
  function getPropTypes2(PropTypes) {
    return {
      id: PropTypes.string,
      width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
      layerFilter: PropTypes.func,
      views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
      viewState: PropTypes.object,
      effects: PropTypes.arrayOf(PropTypes.instanceOf(Effect)),
      controller: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
      gl: PropTypes.object,
      glOptions: PropTypes.object,
      parameters: PropTypes.object,
      pickingRadius: PropTypes.number,
      useDevicePixels: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),
      touchAction: PropTypes.string,
      eventRecognizerOptions: PropTypes.object,
      onWebGLInitialized: PropTypes.func,
      onResize: PropTypes.func,
      onViewStateChange: PropTypes.func,
      onInteractionStateChange: PropTypes.func,
      onBeforeRender: PropTypes.func,
      onAfterRender: PropTypes.func,
      onLoad: PropTypes.func,
      onError: PropTypes.func,
      debug: PropTypes.bool,
      drawPickingColors: PropTypes.bool,
      _framebuffer: PropTypes.object,
      _animate: PropTypes.bool,
      _pickable: PropTypes.bool,
      _typedArrayManagerProps: PropTypes.object
    };
  }
  var defaultProps3 = {
    id: "deckgl-overlay",
    width: "100%",
    height: "100%",
    pickingRadius: 0,
    layerFilter: null,
    glOptions: {},
    gl: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    onWebGLInitialized: noop5,
    onResize: noop5,
    onViewStateChange: noop5,
    onInteractionStateChange: noop5,
    onBeforeRender: noop5,
    onAfterRender: noop5,
    onLoad: noop5,
    onError: null,
    _onMetrics: null,
    getCursor,
    debug: false,
    drawPickingColors: false
  };
  var Deck = function() {
    function Deck2(props) {
      _classCallCheck(this, Deck2);
      props = Object.assign({}, defaultProps3, props);
      this.props = {};
      this.width = 0;
      this.height = 0;
      this.viewManager = null;
      this.layerManager = null;
      this.effectManager = null;
      this.deckRenderer = null;
      this.deckPicker = null;
      this._needsRedraw = true;
      this._pickRequest = {};
      this._lastPointerDownInfo = null;
      this.viewState = null;
      this.interactiveState = {
        isHovering: false,
        isDragging: false
      };
      this._onEvent = this._onEvent.bind(this);
      this._onPointerDown = this._onPointerDown.bind(this);
      this._onPointerMove = this._onPointerMove.bind(this);
      this._pickAndCallback = this._pickAndCallback.bind(this);
      this._onRendererInitialized = this._onRendererInitialized.bind(this);
      this._onRenderFrame = this._onRenderFrame.bind(this);
      this._onViewStateChange = this._onViewStateChange.bind(this);
      this._onInteractionStateChange = this._onInteractionStateChange.bind(this);
      if (props.viewState && props.initialViewState) {
        log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
      }
      if ((0, import_env7.getBrowser)() === "IE") {
        log_default.warn("IE 11 support will be deprecated in v8.0")();
      }
      if (!props.gl) {
        if (typeof document !== "undefined") {
          this.canvas = this._createCanvas(props);
        }
      }
      this.animationLoop = this._createAnimationLoop(props);
      this.stats = new Stats({
        id: "deck.gl"
      });
      this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      };
      this._metricsCounter = 0;
      this.setProps(props);
      if (props._typedArrayManagerProps) {
        typed_array_manager_default.setProps(props._typedArrayManagerProps);
      }
      this.animationLoop.start();
    }
    _createClass(Deck2, [{
      key: "finalize",
      value: function finalize() {
        this.animationLoop.stop();
        this.animationLoop = null;
        this._lastPointerDownInfo = null;
        if (this.layerManager) {
          this.layerManager.finalize();
          this.layerManager = null;
          this.viewManager.finalize();
          this.viewManager = null;
          this.effectManager.finalize();
          this.effectManager = null;
          this.deckRenderer.finalize();
          this.deckRenderer = null;
          this.deckPicker.finalize();
          this.deckPicker = null;
          this.eventManager.destroy();
          this.eventManager = null;
          this.tooltip.remove();
          this.tooltip = null;
        }
        if (!this.props.canvas && !this.props.gl && this.canvas) {
          this.canvas.parentElement.removeChild(this.canvas);
          this.canvas = null;
        }
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        this.stats.get("setProps Time").timeStart();
        if ("onLayerHover" in props) {
          log_default.removed("onLayerHover", "onHover")();
        }
        if ("onLayerClick" in props) {
          log_default.removed("onLayerClick", "onClick")();
        }
        if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState)) {
          this.viewState = props.initialViewState;
        }
        Object.assign(this.props, props);
        this._setCanvasSize(this.props);
        var resolvedProps = Object.create(this.props);
        Object.assign(resolvedProps, {
          views: this._getViews(),
          width: this.width,
          height: this.height,
          viewState: this._getViewState()
        });
        this.animationLoop.setProps(resolvedProps);
        if (this.layerManager) {
          this.viewManager.setProps(resolvedProps);
          this.layerManager.activateViewport(this.getViewports()[0]);
          this.layerManager.setProps(resolvedProps);
          this.effectManager.setProps(resolvedProps);
          this.deckRenderer.setProps(resolvedProps);
          this.deckPicker.setProps(resolvedProps);
        }
        this.stats.get("setProps Time").timeEnd();
      }
    }, {
      key: "needsRedraw",
      value: function needsRedraw() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          clearRedrawFlags: false
        };
        if (this.props._animate) {
          return "Deck._animate";
        }
        var redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        var viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
        var layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
        var effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
        var deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
        redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
        return redraw;
      }
    }, {
      key: "redraw",
      value: function redraw(force) {
        if (!this.layerManager) {
          return;
        }
        var redrawReason = force || this.needsRedraw({
          clearRedrawFlags: true
        });
        if (!redrawReason) {
          return;
        }
        this.stats.get("Redraw Count").incrementCount();
        if (this.props._customRender) {
          this.props._customRender(redrawReason);
        } else {
          this._drawLayers(redrawReason);
        }
      }
    }, {
      key: "getViews",
      value: function getViews() {
        return this.viewManager.views;
      }
    }, {
      key: "getViewports",
      value: function getViewports(rect) {
        return this.viewManager.getViewports(rect);
      }
    }, {
      key: "pickObject",
      value: function pickObject(opts) {
        var infos = this._pick("pickObject", "pickObject Time", opts).result;
        return infos.length ? infos[0] : null;
      }
    }, {
      key: "pickMultipleObjects",
      value: function pickMultipleObjects(opts) {
        opts.depth = opts.depth || 10;
        return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
      }
    }, {
      key: "pickObjects",
      value: function pickObjects(opts) {
        return this._pick("pickObjects", "pickObjects Time", opts);
      }
    }, {
      key: "_addResources",
      value: function _addResources(resources) {
        var forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        for (var id in resources) {
          this.layerManager.resourceManager.add({
            resourceId: id,
            data: resources[id],
            forceUpdate
          });
        }
      }
    }, {
      key: "_removeResources",
      value: function _removeResources(resourceIds) {
        var _iterator = _createForOfIteratorHelper43(resourceIds), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var id = _step.value;
            this.layerManager.resourceManager.remove(id);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "_pick",
      value: function _pick(method, statKey, opts) {
        var stats = this.stats;
        stats.get("Pick Count").incrementCount();
        stats.get(statKey).timeStart();
        var infos = this.deckPicker[method](Object.assign({
          layers: this.layerManager.getLayers(opts),
          views: this.viewManager.getViews(),
          viewports: this.getViewports(opts),
          onViewportActive: this.layerManager.activateViewport
        }, opts));
        stats.get(statKey).timeEnd();
        return infos;
      }
    }, {
      key: "_createCanvas",
      value: function _createCanvas(props) {
        var canvas = props.canvas;
        if (typeof canvas === "string") {
          canvas = document.getElementById(canvas);
          assert8(canvas);
        }
        if (!canvas) {
          canvas = document.createElement("canvas");
          var parent = props.parent || document.body;
          parent.appendChild(canvas);
        }
        var id = props.id, style = props.style;
        canvas.id = id;
        Object.assign(canvas.style, style);
        return canvas;
      }
    }, {
      key: "_setCanvasSize",
      value: function _setCanvasSize(props) {
        if (!this.canvas) {
          return;
        }
        var width = props.width, height = props.height;
        if (width || width === 0) {
          width = Number.isFinite(width) ? "".concat(width, "px") : width;
          this.canvas.style.width = width;
        }
        if (height || height === 0) {
          height = Number.isFinite(height) ? "".concat(height, "px") : height;
          this.canvas.style.position = "absolute";
          this.canvas.style.height = height;
        }
      }
    }, {
      key: "_updateCanvasSize",
      value: function _updateCanvasSize() {
        if (this._checkForCanvasSizeChange()) {
          var width = this.width, height = this.height;
          this.viewManager.setProps({
            width,
            height
          });
          this.props.onResize({
            width: this.width,
            height: this.height
          });
        }
      }
    }, {
      key: "_checkForCanvasSizeChange",
      value: function _checkForCanvasSizeChange() {
        var canvas = this.canvas;
        if (!canvas) {
          return false;
        }
        var newWidth = canvas.clientWidth || canvas.width;
        var newHeight = canvas.clientHeight || canvas.height;
        if (newWidth !== this.width || newHeight !== this.height) {
          this.width = newWidth;
          this.height = newHeight;
          return true;
        }
        return false;
      }
    }, {
      key: "_createAnimationLoop",
      value: function _createAnimationLoop(props) {
        var _this = this;
        var width = props.width, height = props.height, gl = props.gl, glOptions = props.glOptions, debug2 = props.debug, useDevicePixels = props.useDevicePixels, autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
        return new AnimationLoop({
          width,
          height,
          useDevicePixels,
          autoResizeDrawingBuffer,
          autoResizeViewport: false,
          gl,
          onCreateContext: function onCreateContext(opts) {
            return createGLContext(Object.assign({}, glOptions, opts, {
              canvas: _this.canvas,
              debug: debug2
            }));
          },
          onInitialize: this._onRendererInitialized,
          onRender: this._onRenderFrame,
          onBeforeRender: props.onBeforeRender,
          onAfterRender: props.onAfterRender,
          onError: props.onError
        });
      }
    }, {
      key: "_getViewState",
      value: function _getViewState() {
        return this.props.viewState || this.viewState;
      }
    }, {
      key: "_getViews",
      value: function _getViews() {
        var views = this.props.views || [new MapView({
          id: "default-view"
        })];
        views = Array.isArray(views) ? views : [views];
        if (views.length && this.props.controller) {
          views[0].props.controller = this.props.controller;
        }
        return views;
      }
    }, {
      key: "_onPointerMove",
      value: function _onPointerMove(event) {
        var _pickRequest = this._pickRequest;
        if (event.type === "pointerleave") {
          _pickRequest.x = -1;
          _pickRequest.y = -1;
          _pickRequest.radius = 0;
        } else if (event.leftButton || event.rightButton) {
          return;
        } else {
          var pos = event.offsetCenter;
          if (!pos) {
            return;
          }
          _pickRequest.x = pos.x;
          _pickRequest.y = pos.y;
          _pickRequest.radius = this.props.pickingRadius;
        }
        if (this.layerManager) {
          this.layerManager.context.mousePosition = {
            x: _pickRequest.x,
            y: _pickRequest.y
          };
        }
        _pickRequest.event = event;
        _pickRequest.mode = "hover";
      }
    }, {
      key: "_pickAndCallback",
      value: function _pickAndCallback() {
        var _pickRequest = this._pickRequest;
        if (_pickRequest.event) {
          var _this$_pick = this._pick("pickObject", "pickObject Time", _pickRequest), result = _this$_pick.result, emptyInfo = _this$_pick.emptyInfo;
          this.interactiveState.isHovering = result.length > 0;
          var pickedInfo = emptyInfo;
          var handled = false;
          var _iterator2 = _createForOfIteratorHelper43(result), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var info = _step2.value;
              pickedInfo = info;
              handled = info.layer.onHover(info, _pickRequest.event);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (!handled && this.props.onHover) {
            this.props.onHover(pickedInfo, _pickRequest.event);
          }
          if (this.props.getTooltip) {
            var displayInfo = this.props.getTooltip(pickedInfo);
            this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
          }
          _pickRequest.event = null;
        }
      }
    }, {
      key: "_updateCursor",
      value: function _updateCursor() {
        var container = this.props.parent || this.canvas;
        if (container) {
          container.style.cursor = this.props.getCursor(this.interactiveState);
        }
      }
    }, {
      key: "_setGLContext",
      value: function _setGLContext(gl) {
        if (this.layerManager) {
          return;
        }
        if (!this.canvas) {
          this.canvas = gl.canvas;
          instrumentGLContext(gl, {
            enable: true,
            copyState: true
          });
        }
        this.tooltip = new Tooltip(this.canvas);
        setParameters(gl, {
          blend: true,
          blendFunc: [770, 771, 1, 771],
          polygonOffsetFill: true,
          depthTest: true,
          depthFunc: 515
        });
        this.props.onWebGLInitialized(gl);
        var timeline = new Timeline();
        timeline.play();
        this.animationLoop.attachTimeline(timeline);
        this.eventManager = new EventManager(this.props.parent || gl.canvas, {
          touchAction: this.props.touchAction,
          recognizerOptions: this.props.eventRecognizerOptions,
          events: {
            pointerdown: this._onPointerDown,
            pointermove: this._onPointerMove,
            pointerleave: this._onPointerMove
          }
        });
        for (var eventType in EVENTS) {
          this.eventManager.on(eventType, this._onEvent);
        }
        this.viewManager = new ViewManager({
          timeline,
          eventManager: this.eventManager,
          onViewStateChange: this._onViewStateChange,
          onInteractionStateChange: this._onInteractionStateChange,
          views: this._getViews(),
          viewState: this._getViewState(),
          width: this.width,
          height: this.height
        });
        var viewport3 = this.viewManager.getViewports()[0];
        this.layerManager = new LayerManager(gl, {
          deck: this,
          stats: this.stats,
          viewport: viewport3,
          timeline
        });
        this.effectManager = new EffectManager();
        this.deckRenderer = new DeckRenderer(gl);
        this.deckPicker = new DeckPicker(gl);
        this.setProps(this.props);
        this._updateCanvasSize();
        this.props.onLoad();
      }
    }, {
      key: "_drawLayers",
      value: function _drawLayers(redrawReason, renderOptions) {
        var gl = this.layerManager.context.gl;
        setParameters(gl, this.props.parameters);
        this.props.onBeforeRender({
          gl
        });
        this.deckRenderer.renderLayers(Object.assign({
          target: this.props._framebuffer,
          layers: this.layerManager.getLayers(),
          viewports: this.viewManager.getViewports(),
          onViewportActive: this.layerManager.activateViewport,
          views: this.viewManager.getViews(),
          pass: "screen",
          redrawReason,
          effects: this.effectManager.getEffects()
        }, renderOptions));
        this.props.onAfterRender({
          gl
        });
      }
    }, {
      key: "_onRendererInitialized",
      value: function _onRendererInitialized(_ref2) {
        var gl = _ref2.gl;
        this._setGLContext(gl);
      }
    }, {
      key: "_onRenderFrame",
      value: function _onRenderFrame(animationProps) {
        this._getFrameStats();
        if (this._metricsCounter++ % 60 === 0) {
          this._getMetrics();
          this.stats.reset();
          log_default.table(4, this.metrics)();
          if (this.props._onMetrics) {
            this.props._onMetrics(this.metrics);
          }
        }
        this._updateCanvasSize();
        this._updateCursor();
        this.layerManager.updateLayers();
        this._pickAndCallback();
        this.redraw(false);
        if (this.viewManager) {
          this.viewManager.updateViewStates();
        }
      }
    }, {
      key: "_onViewStateChange",
      value: function _onViewStateChange(params) {
        var viewState = this.props.onViewStateChange(params) || params.viewState;
        if (this.viewState) {
          this.viewState = _objectSpread26(_objectSpread26({}, this.viewState), {}, _defineProperty({}, params.viewId, viewState));
          if (!this.props.viewState) {
            this.viewManager.setProps({
              viewState: this.viewState
            });
          }
        }
      }
    }, {
      key: "_onInteractionStateChange",
      value: function _onInteractionStateChange(interactionState) {
        this.interactiveState.isDragging = interactionState.isDragging;
        this.props.onInteractionStateChange(interactionState);
      }
    }, {
      key: "_onEvent",
      value: function _onEvent(event) {
        var eventOptions = EVENTS[event.type];
        var pos = event.offsetCenter;
        if (!eventOptions || !pos) {
          return;
        }
        var layers = this.layerManager.getLayers();
        var info = this.deckPicker.getLastPickedObject({
          x: pos.x,
          y: pos.y,
          layers,
          viewports: this.getViewports(pos)
        }, this._lastPointerDownInfo);
        var layer = info.layer;
        var layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
        var rootHandler = this.props[eventOptions.handler];
        var handled = false;
        if (layerHandler) {
          handled = layerHandler.call(layer, info, event);
        }
        if (!handled && rootHandler) {
          rootHandler(info, event);
        }
      }
    }, {
      key: "_onPointerDown",
      value: function _onPointerDown(event) {
        var pos = event.offsetCenter;
        this._lastPointerDownInfo = this.pickObject({
          x: pos.x,
          y: pos.y,
          radius: this.props.pickingRadius
        });
      }
    }, {
      key: "_getFrameStats",
      value: function _getFrameStats() {
        var stats = this.stats;
        stats.get("frameRate").timeEnd();
        stats.get("frameRate").timeStart();
        var animationLoopStats = this.animationLoop.stats;
        stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
        stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
      }
    }, {
      key: "_getMetrics",
      value: function _getMetrics() {
        var metrics = this.metrics, stats = this.stats;
        metrics.fps = stats.get("frameRate").getHz();
        metrics.setPropsTime = stats.get("setProps Time").time;
        metrics.updateAttributesTime = stats.get("Update Attributes").time;
        metrics.framesRedrawn = stats.get("Redraw Count").count;
        metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
        metrics.pickCount = stats.get("Pick Count").count;
        metrics.gpuTime = stats.get("GPU Time").time;
        metrics.cpuTime = stats.get("CPU Time").time;
        metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
        metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
        var memoryStats = lumaStats.get("Memory Usage");
        metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
        metrics.textureMemory = memoryStats.get("Texture Memory").count;
        metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
        metrics.gpuMemory = memoryStats.get("GPU Memory").count;
      }
    }]);
    return Deck2;
  }();
  Deck.getPropTypes = getPropTypes2;
  Deck.defaultProps = defaultProps3;
  Deck.VERSION = init_default.VERSION;

  // node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js
  function _createForOfIteratorHelper44(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray45(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray45(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray45(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray45(o, minLen);
  }
  function _arrayLikeToArray45(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper34(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct35();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct35() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
  var CompositeLayer = function(_Layer) {
    _inherits(CompositeLayer2, _Layer);
    var _super = _createSuper34(CompositeLayer2);
    function CompositeLayer2() {
      _classCallCheck(this, CompositeLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(CompositeLayer2, [{
      key: "getSubLayers",
      value: function getSubLayers() {
        return this.internalState && this.internalState.subLayers || [];
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
      }
    }, {
      key: "setState",
      value: function setState(updateObject) {
        _get(_getPrototypeOf(CompositeLayer2.prototype), "setState", this).call(this, updateObject);
        this.setNeedsUpdate();
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(_ref) {
        var info = _ref.info;
        var object = info.object;
        var isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
        if (!isDataWrapped) {
          return info;
        }
        return Object.assign(info, {
          object: object.__source.object,
          index: object.__source.index
        });
      }
    }, {
      key: "renderLayers",
      value: function renderLayers() {
        return null;
      }
    }, {
      key: "shouldRenderSubLayer",
      value: function shouldRenderSubLayer(id, data) {
        var overridingProps = this.props._subLayerProps;
        return data && data.length || overridingProps && overridingProps[id];
      }
    }, {
      key: "getSubLayerClass",
      value: function getSubLayerClass(id, DefaultLayerClass) {
        var overridingProps = this.props._subLayerProps;
        return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;
      }
    }, {
      key: "getSubLayerRow",
      value: function getSubLayerRow(row, sourceObject, sourceObjectIndex) {
        row.__source = {
          parent: this,
          object: sourceObject,
          index: sourceObjectIndex
        };
        return row;
      }
    }, {
      key: "getSubLayerAccessor",
      value: function getSubLayerAccessor(accessor) {
        if (typeof accessor === "function") {
          var objectInfo = {
            data: this.props.data,
            target: []
          };
          return function(x, i) {
            if (x && x.__source) {
              objectInfo.index = x.__source.index;
              return accessor(x.__source.object, objectInfo);
            }
            return accessor(x, i);
          };
        }
        return accessor;
      }
    }, {
      key: "getSubLayerProps",
      value: function getSubLayerProps() {
        var sublayerProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$props = this.props, opacity = _this$props.opacity, pickable = _this$props.pickable, visible = _this$props.visible, parameters = _this$props.parameters, getPolygonOffset = _this$props.getPolygonOffset, highlightedObjectIndex = _this$props.highlightedObjectIndex, autoHighlight = _this$props.autoHighlight, highlightColor = _this$props.highlightColor, coordinateSystem = _this$props.coordinateSystem, coordinateOrigin = _this$props.coordinateOrigin, wrapLongitude = _this$props.wrapLongitude, positionFormat = _this$props.positionFormat, modelMatrix = _this$props.modelMatrix, extensions = _this$props.extensions, overridingProps = _this$props._subLayerProps;
        var newProps = {
          opacity,
          pickable,
          visible,
          parameters,
          getPolygonOffset,
          highlightedObjectIndex,
          autoHighlight,
          highlightColor,
          coordinateSystem,
          coordinateOrigin,
          wrapLongitude,
          positionFormat,
          modelMatrix,
          extensions
        };
        var overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];
        var overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
        var sublayerId = sublayerProps.id || "sublayer";
        if (overridingSublayerProps) {
          var propTypes = this.constructor._propTypes;
          for (var key in overridingSublayerProps) {
            var propType = propTypes[key];
            if (propType && propType.type === "accessor") {
              overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
            }
          }
        }
        Object.assign(newProps, sublayerProps, overridingSublayerProps, {
          id: "".concat(this.props.id, "-").concat(sublayerId),
          updateTriggers: Object.assign({
            all: this.props.updateTriggers.all
          }, sublayerProps.updateTriggers, overridingSublayerTriggers)
        });
        var _iterator = _createForOfIteratorHelper44(extensions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var extension = _step.value;
            var passThroughProps = extension.getSubLayerProps.call(this, extension);
            if (passThroughProps) {
              Object.assign(newProps, passThroughProps, {
                updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
              });
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return newProps;
      }
    }, {
      key: "_getAttributeManager",
      value: function _getAttributeManager() {
        return null;
      }
    }, {
      key: "_renderLayers",
      value: function _renderLayers() {
        var subLayers = this.internalState.subLayers;
        var shouldUpdate = !subLayers || this.needsUpdate();
        if (shouldUpdate) {
          subLayers = this.renderLayers();
          subLayers = flatten(subLayers, Boolean);
          this.internalState.subLayers = subLayers;
        }
        debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
        var _iterator2 = _createForOfIteratorHelper44(subLayers), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var layer = _step2.value;
            layer.parent = this;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "isComposite",
      get: function get2() {
        return true;
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        return _get(_getPrototypeOf(CompositeLayer2.prototype), "isLoaded", this) && this.getSubLayers().every(function(layer) {
          return layer.isLoaded;
        });
      }
    }]);
    return CompositeLayer2;
  }(Layer);
  CompositeLayer.layerName = "CompositeLayer";

  // node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js
  function _createSuper35(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct36();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct36() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEGREES_TO_RADIANS5 = Math.PI / 180;
  var RADIANS_TO_DEGREES3 = 180 / Math.PI;
  var EARTH_RADIUS = 6370972;
  var GLOBE_RADIUS = 256;
  function getDistanceScales2() {
    var unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;
    var unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
    return {
      unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],
      unitsPerMeter2: [0, 0, 0],
      metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],
      unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],
      unitsPerDegree2: [0, 0, 0],
      degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]
    };
  }
  var GlobeViewport = function(_Viewport) {
    _inherits(GlobeViewport2, _Viewport);
    var _super = _createSuper35(GlobeViewport2);
    function GlobeViewport2() {
      var _this;
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, GlobeViewport2);
      var _opts$latitude = opts.latitude, latitude = _opts$latitude === void 0 ? 0 : _opts$latitude, _opts$longitude = opts.longitude, longitude = _opts$longitude === void 0 ? 0 : _opts$longitude, _opts$zoom = opts.zoom, zoom = _opts$zoom === void 0 ? 11 : _opts$zoom, _opts$nearZMultiplier = opts.nearZMultiplier, nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier, _opts$farZMultiplier = opts.farZMultiplier, farZMultiplier = _opts$farZMultiplier === void 0 ? 2 : _opts$farZMultiplier, _opts$resolution = opts.resolution, resolution = _opts$resolution === void 0 ? 10 : _opts$resolution;
      var width = opts.width, height = opts.height, _opts$altitude = opts.altitude, altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;
      width = width || 1;
      height = height || 1;
      altitude = Math.max(0.75, altitude);
      var viewMatrix = new Matrix4().lookAt({
        eye: [0, -altitude, 0],
        up: [0, 0, 1]
      });
      var scale5 = Math.pow(2, zoom);
      viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS5);
      viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS5);
      viewMatrix.scale(scale5 / height);
      var halfFov = Math.atan(0.5 / altitude);
      var relativeScale = GLOBE_RADIUS * 2 * scale5 / height;
      var viewportOpts = Object.assign({}, opts, {
        width,
        height,
        viewMatrix,
        longitude,
        latitude,
        zoom,
        fovyRadians: halfFov * 2,
        aspect: width / height,
        focalDistance: altitude,
        near: nearZMultiplier,
        far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
      });
      _this = _super.call(this, viewportOpts);
      _this.resolution = resolution;
      _this.distanceScales = getDistanceScales2();
      return _this;
    }
    _createClass(GlobeViewport2, [{
      key: "getDistanceScales",
      value: function getDistanceScales3() {
        return this.distanceScales;
      }
    }, {
      key: "getBounds",
      value: function getBounds2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var unprojectOption = {
          targetZ: options.z || 0
        };
        var left = this.unproject([0, this.height / 2], unprojectOption);
        var top = this.unproject([this.width / 2, 0], unprojectOption);
        var right = this.unproject([this.width, this.height / 2], unprojectOption);
        var bottom = this.unproject([this.width / 2, this.height], unprojectOption);
        if (right[0] < this.longitude)
          right[0] += 360;
        if (left[0] > this.longitude)
          left[0] -= 360;
        return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
      }
    }, {
      key: "unproject",
      value: function unproject(xyz) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$topLeft = _ref.topLeft, topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft, targetZ = _ref.targetZ;
        var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
        var y2 = topLeft ? y : this.height - y;
        var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;
        var coord;
        if (Number.isFinite(z)) {
          coord = transformVector2(pixelUnprojectionMatrix, [x, y2, z, 1]);
        } else {
          var coord0 = transformVector2(pixelUnprojectionMatrix, [x, y2, -1, 1]);
          var coord1 = transformVector2(pixelUnprojectionMatrix, [x, y2, 1, 1]);
          var lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
          var lSqr = sqrLen(sub([], coord0, coord1));
          var l0Sqr = sqrLen(coord0);
          var l1Sqr = sqrLen(coord1);
          var sSqr = (4 * l0Sqr * l1Sqr - Math.pow(lSqr - l0Sqr - l1Sqr, 2)) / 16;
          var dSqr = 4 * sSqr / lSqr;
          var r0 = Math.sqrt(l0Sqr - dSqr);
          var dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
          var t = (r0 - dr) / Math.sqrt(lSqr);
          coord = lerp3([], coord0, coord1, t);
        }
        var _this$unprojectPositi = this.unprojectPosition(coord), _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3), X = _this$unprojectPositi2[0], Y = _this$unprojectPositi2[1], Z = _this$unprojectPositi2[2];
        if (Number.isFinite(z)) {
          return [X, Y, Z];
        }
        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
      }
    }, {
      key: "projectPosition",
      value: function projectPosition2(xyz) {
        var _xyz2 = _slicedToArray(xyz, 3), lng = _xyz2[0], lat = _xyz2[1], _xyz2$ = _xyz2[2], Z = _xyz2$ === void 0 ? 0 : _xyz2$;
        var lambda = lng * DEGREES_TO_RADIANS5;
        var phi = lat * DEGREES_TO_RADIANS5;
        var cosPhi = Math.cos(phi);
        var D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
        return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
      }
    }, {
      key: "unprojectPosition",
      value: function unprojectPosition(xyz) {
        var _xyz3 = _slicedToArray(xyz, 3), x = _xyz3[0], y = _xyz3[1], z = _xyz3[2];
        var D = len(xyz);
        var phi = Math.asin(z / D);
        var lambda = Math.atan2(x, -y);
        var lng = lambda * RADIANS_TO_DEGREES3;
        var lat = phi * RADIANS_TO_DEGREES3;
        var Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
        return [lng, lat, Z];
      }
    }, {
      key: "projectFlat",
      value: function projectFlat(xyz) {
        return xyz;
      }
    }, {
      key: "unprojectFlat",
      value: function unprojectFlat(xyz) {
        return xyz;
      }
    }, {
      key: "getMapCenterByLngLatPosition",
      value: function getMapCenterByLngLatPosition(_ref2) {
        var lngLat = _ref2.lngLat, pos = _ref2.pos;
        var fromPosition = this.unproject(pos);
        return [lngLat[0] - fromPosition[0] + this.longitude, lngLat[1] - fromPosition[1] + this.latitude];
      }
    }, {
      key: "projectionMode",
      get: function get2() {
        return PROJECTION_MODE.GLOBE;
      }
    }]);
    return GlobeViewport2;
  }(Viewport);
  function transformVector2(matrix, vector) {
    var result = transformMat43([], vector, matrix);
    scale3(result, result, 1 / result[3]);
    return result;
  }

  // node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js
  function _createSuper36(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct37();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct37() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var LINEAR_TRANSITION_PROPS2 = {
    transitionDuration: 300,
    transitionEasing: function transitionEasing3(t) {
      return t;
    },
    transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"]),
    transitionInterruption: TRANSITION_EVENTS.BREAK
  };
  var GlobeState = function(_MapState) {
    _inherits(GlobeState2, _MapState);
    var _super = _createSuper36(GlobeState2);
    function GlobeState2() {
      _classCallCheck(this, GlobeState2);
      return _super.apply(this, arguments);
    }
    _createClass(GlobeState2, [{
      key: "_applyConstraints",
      value: function _applyConstraints(props) {
        var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom;
        props.zoom = clamp(zoom, minZoom, maxZoom);
        var longitude = props.longitude, latitude = props.latitude;
        if (longitude < -180 || longitude > 180) {
          props.longitude = mod2(longitude + 180, 360) - 180;
        }
        props.latitude = clamp(latitude, -89, 89);
        return props;
      }
    }]);
    return GlobeState2;
  }(MapState);
  var GlobeController = function(_Controller) {
    _inherits(GlobeController2, _Controller);
    var _super2 = _createSuper36(GlobeController2);
    function GlobeController2(props) {
      _classCallCheck(this, GlobeController2);
      props.dragMode = props.dragMode || "pan";
      return _super2.call(this, GlobeState, props);
    }
    _createClass(GlobeController2, [{
      key: "setProps",
      value: function setProps(props) {
        _get(_getPrototypeOf(GlobeController2.prototype), "setProps", this).call(this, props);
        this.dragRotate = false;
        this.touchRotate = false;
      }
    }, {
      key: "_getTransitionProps",
      value: function _getTransitionProps() {
        return LINEAR_TRANSITION_PROPS2;
      }
    }]);
    return GlobeController2;
  }(Controller);

  // node_modules/@deck.gl/core/dist/esm/views/globe-view.js
  function ownKeys27(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread27(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys27(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys27(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper37(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct38();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct38() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var GlobeView = function(_View) {
    _inherits(GlobeView2, _View);
    var _super = _createSuper37(GlobeView2);
    function GlobeView2(props) {
      _classCallCheck(this, GlobeView2);
      return _super.call(this, _objectSpread27(_objectSpread27({}, props), {}, {
        type: GlobeViewport
      }));
    }
    _createClass(GlobeView2, [{
      key: "controller",
      get: function get2() {
        return this._getControllerProps({
          type: GlobeController
        });
      }
    }]);
    return GlobeView2;
  }(View);
  GlobeView.displayName = "GlobeView";

  // node_modules/@deck.gl/core/dist/esm/utils/tesselator.js
  function _createForOfIteratorHelper45(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray46(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray46(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray46(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray46(o, minLen);
  }
  function _arrayLikeToArray46(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var Tesselator = function() {
    function Tesselator2() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Tesselator2);
      var _opts$attributes = opts.attributes, attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
      this.typedArrayManager = typed_array_manager_default;
      this.indexStarts = null;
      this.vertexStarts = null;
      this.vertexCount = 0;
      this.instanceCount = 0;
      this.attributes = {};
      this._attributeDefs = attributes;
      this.opts = opts;
      this.updateGeometry(opts);
      Object.seal(this);
    }
    _createClass(Tesselator2, [{
      key: "updateGeometry",
      value: function updateGeometry(opts) {
        Object.assign(this.opts, opts);
        var _this$opts = this.opts, data = _this$opts.data, _this$opts$buffers = _this$opts.buffers, buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers, getGeometry = _this$opts.getGeometry, geometryBuffer = _this$opts.geometryBuffer, positionFormat = _this$opts.positionFormat, dataChanged = _this$opts.dataChanged, _this$opts$normalize = _this$opts.normalize, normalize5 = _this$opts$normalize === void 0 ? true : _this$opts$normalize;
        this.data = data;
        this.getGeometry = getGeometry;
        this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
        this.buffers = buffers;
        this.normalize = normalize5;
        if (geometryBuffer) {
          assert8(data.startIndices, "binary data missing startIndices");
          this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
          if (!normalize5) {
            buffers.positions = geometryBuffer;
          }
        }
        this.geometryBuffer = buffers.positions;
        if (Array.isArray(dataChanged)) {
          var _iterator = _createForOfIteratorHelper45(dataChanged), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var dataRange = _step.value;
              this._rebuildGeometry(dataRange);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          this._rebuildGeometry();
        }
      }
    }, {
      key: "updatePartialGeometry",
      value: function updatePartialGeometry(_ref) {
        var startRow = _ref.startRow, endRow = _ref.endRow;
        this._rebuildGeometry({
          startRow,
          endRow
        });
      }
    }, {
      key: "normalizeGeometry",
      value: function normalizeGeometry(geometry) {
        return geometry;
      }
    }, {
      key: "updateGeometryAttributes",
      value: function updateGeometryAttributes(geometry, startIndex, size) {
        throw new Error("Not implemented");
      }
    }, {
      key: "getGeometrySize",
      value: function getGeometrySize(geometry) {
        throw new Error("Not implemented");
      }
    }, {
      key: "getGeometryFromBuffer",
      value: function getGeometryFromBuffer(geometryBuffer) {
        var value17 = geometryBuffer.value || geometryBuffer;
        assert8(ArrayBuffer.isView(value17), "cannot read geometries");
        return getAccessorFromBuffer(value17, {
          size: this.positionSize,
          offset: geometryBuffer.offset,
          stride: geometryBuffer.stride,
          startIndices: this.data.startIndices
        });
      }
    }, {
      key: "_allocate",
      value: function _allocate(instanceCount, copy3) {
        var attributes = this.attributes, buffers = this.buffers, _attributeDefs = this._attributeDefs, typedArrayManager = this.typedArrayManager;
        for (var name in _attributeDefs) {
          if (name in buffers) {
            typedArrayManager.release(attributes[name]);
            attributes[name] = null;
          } else {
            var def = _attributeDefs[name];
            def.copy = copy3;
            attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
          }
        }
      }
    }, {
      key: "_forEachGeometry",
      value: function _forEachGeometry(visitor, startRow, endRow) {
        var data = this.data, getGeometry = this.getGeometry;
        var _createIterable = createIterable(data, startRow, endRow), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
        var _iterator2 = _createForOfIteratorHelper45(iterable), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var object = _step2.value;
            objectInfo.index++;
            var geometry = getGeometry(object, objectInfo);
            visitor(geometry, objectInfo.index);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "_rebuildGeometry",
      value: function _rebuildGeometry(dataRange) {
        var _this = this;
        if (!this.data || !this.getGeometry) {
          return;
        }
        var indexStarts = this.indexStarts, vertexStarts = this.vertexStarts, instanceCount = this.instanceCount;
        var data = this.data, geometryBuffer = this.geometryBuffer;
        var _ref2 = dataRange || {}, _ref2$startRow = _ref2.startRow, startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow, _ref2$endRow = _ref2.endRow, endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;
        var normalizedData = {};
        if (!dataRange) {
          indexStarts = [0];
          vertexStarts = [0];
        }
        if (this.normalize || !geometryBuffer) {
          this._forEachGeometry(function(geometry, dataIndex) {
            geometry = _this.normalizeGeometry(geometry);
            normalizedData[dataIndex] = geometry;
            vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);
          }, startRow, endRow);
          instanceCount = vertexStarts[vertexStarts.length - 1];
        } else if (geometryBuffer.buffer instanceof Buffer2) {
          var byteStride = geometryBuffer.stride || this.positionSize * 4;
          vertexStarts = data.startIndices;
          instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;
        } else {
          var bufferValue = geometryBuffer.value || geometryBuffer;
          var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
          vertexStarts = data.startIndices;
          instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;
        }
        this._allocate(instanceCount, Boolean(dataRange));
        this.indexStarts = indexStarts;
        this.vertexStarts = vertexStarts;
        this.instanceCount = instanceCount;
        var context = {};
        this._forEachGeometry(function(geometry, dataIndex) {
          geometry = normalizedData[dataIndex] || geometry;
          context.vertexStart = vertexStarts[dataIndex];
          context.indexStart = indexStarts[dataIndex];
          var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
          context.geometrySize = vertexEnd - vertexStarts[dataIndex];
          context.geometryIndex = dataIndex;
          _this.updateGeometryAttributes(geometry, context);
        }, startRow, endRow);
        this.vertexCount = indexStarts[indexStarts.length - 1];
      }
    }]);
    return Tesselator2;
  }();

  // node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js
  var DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
  var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  function createMesh(bounds, resolution) {
    if (!resolution) {
      return createQuad(bounds);
    }
    var maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
    var maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
    var uCount = Math.ceil(maxXSpan / resolution) + 1;
    var vCount = Math.ceil(maxYSpan / resolution) + 1;
    var vertexCount = (uCount - 1) * (vCount - 1) * 6;
    var indices = new Uint32Array(vertexCount);
    var texCoords = new Float32Array(uCount * vCount * 2);
    var positions = new Float64Array(uCount * vCount * 3);
    var vertex = 0;
    var index = 0;
    for (var u = 0; u < uCount; u++) {
      var ut = u / (uCount - 1);
      for (var v = 0; v < vCount; v++) {
        var vt = v / (vCount - 1);
        var p = interpolateQuad(bounds, ut, vt);
        positions[vertex * 3 + 0] = p[0];
        positions[vertex * 3 + 1] = p[1];
        positions[vertex * 3 + 2] = p[2] || 0;
        texCoords[vertex * 2 + 0] = ut;
        texCoords[vertex * 2 + 1] = 1 - vt;
        if (u > 0 && v > 0) {
          indices[index++] = vertex - vCount;
          indices[index++] = vertex - vCount - 1;
          indices[index++] = vertex - 1;
          indices[index++] = vertex - vCount;
          indices[index++] = vertex - 1;
          indices[index++] = vertex;
        }
        vertex++;
      }
    }
    return {
      vertexCount,
      positions,
      indices,
      texCoords
    };
  }
  function createQuad(bounds) {
    var positions = new Float64Array(12);
    for (var i = 0; i < bounds.length; i++) {
      positions[i * 3 + 0] = bounds[i][0];
      positions[i * 3 + 1] = bounds[i][1];
      positions[i * 3 + 2] = bounds[i][2] || 0;
    }
    return {
      vertexCount: 6,
      positions,
      indices: DEFAULT_INDICES,
      texCoords: DEFAULT_TEX_COORDS
    };
  }
  function interpolateQuad(quad, ut, vt) {
    return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
  }

  // node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js
  var bitmap_layer_vertex_default2 = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js
  var packUVsIntoRGB = "\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n";
  var bitmap_layer_fragment_default2 = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor, vec4(color, 1.0), alpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat(packUVsIntoRGB, "\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n");

  // node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js
  function ownKeys28(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread28(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys28(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys28(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper38(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct39();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct39() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var defaultProps4 = {
    image: {
      type: "image",
      value: null,
      async: true
    },
    bounds: {
      type: "array",
      value: [1, 0, 0, 1],
      compare: true
    },
    _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    desaturate: {
      type: "number",
      min: 0,
      max: 1,
      value: 0
    },
    transparentColor: {
      type: "color",
      value: [0, 0, 0, 0]
    },
    tintColor: {
      type: "color",
      value: [255, 255, 255]
    }
  };
  var BitmapLayer = function(_Layer) {
    _inherits(BitmapLayer2, _Layer);
    var _super = _createSuper38(BitmapLayer2);
    function BitmapLayer2() {
      _classCallCheck(this, BitmapLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(BitmapLayer2, [{
      key: "getShaders",
      value: function getShaders() {
        return _get(_getPrototypeOf(BitmapLayer2.prototype), "getShaders", this).call(this, {
          vs: bitmap_layer_vertex_default2,
          fs: bitmap_layer_fragment_default2,
          modules: [project32_default, picking_default]
        });
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        var _this = this;
        var attributeManager = this.getAttributeManager();
        attributeManager.remove(["instancePickingColors"]);
        var noAlloc = true;
        attributeManager.add({
          indices: {
            size: 1,
            isIndexed: true,
            update: function update3(attribute) {
              return attribute.value = _this.state.mesh.indices;
            },
            noAlloc
          },
          positions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            update: function update3(attribute) {
              return attribute.value = _this.state.mesh.positions;
            },
            noAlloc
          },
          texCoords: {
            size: 2,
            update: function update3(attribute) {
              return attribute.value = _this.state.mesh.texCoords;
            },
            noAlloc
          }
        });
      }
    }, {
      key: "updateState",
      value: function updateState(_ref) {
        var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
        if (changeFlags.extensionsChanged) {
          var gl = this.context.gl;
          if (this.state.model) {
            this.state.model["delete"]();
          }
          this.setState({
            model: this._getModel(gl)
          });
          this.getAttributeManager().invalidateAll();
        }
        var attributeManager = this.getAttributeManager();
        if (props.bounds !== oldProps.bounds) {
          var oldMesh = this.state.mesh;
          var mesh = this._createMesh();
          this.state.model.setVertexCount(mesh.vertexCount);
          for (var key in mesh) {
            if (oldMesh && oldMesh[key] !== mesh[key]) {
              attributeManager.invalidate(key);
            }
          }
          this.setState(_objectSpread28({
            mesh
          }, this._getCoordinateUniforms()));
        } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
          this.setState(this._getCoordinateUniforms());
        }
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(_ref2) {
        var info = _ref2.info;
        var image = this.props.image;
        if (!info.color || !image) {
          info.bitmap = null;
          return info;
        }
        var width = image.width, height = image.height;
        info.index = 0;
        var uv = unpackUVsFromRGB(info.color);
        var pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];
        info.bitmap = {
          size: {
            width,
            height
          },
          uv,
          pixel
        };
        return info;
      }
    }, {
      key: "disablePickingIndex",
      value: function disablePickingIndex() {
        this.setState({
          disablePicking: true
        });
      }
    }, {
      key: "restorePickingColors",
      value: function restorePickingColors() {
        this.setState({
          disablePicking: false
        });
      }
    }, {
      key: "_createMesh",
      value: function _createMesh() {
        var bounds = this.props.bounds;
        var normalizedBounds = bounds;
        if (Number.isFinite(bounds[0])) {
          normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
        }
        return createMesh(normalizedBounds, this.context.viewport.resolution);
      }
    }, {
      key: "_getModel",
      value: function _getModel(gl) {
        if (!gl) {
          return null;
        }
        return new Model(gl, Object.assign({}, this.getShaders(), {
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 4,
            vertexCount: 6
          }),
          isInstanced: false
        }));
      }
    }, {
      key: "draw",
      value: function draw(opts) {
        var uniforms = opts.uniforms, moduleParameters = opts.moduleParameters;
        var _this$state = this.state, model = _this$state.model, coordinateConversion = _this$state.coordinateConversion, bounds = _this$state.bounds, disablePicking = _this$state.disablePicking;
        var _this$props = this.props, image = _this$props.image, desaturate = _this$props.desaturate, transparentColor = _this$props.transparentColor, tintColor = _this$props.tintColor;
        if (moduleParameters.pickingActive && disablePicking) {
          return;
        }
        if (image && model) {
          model.setUniforms(uniforms).setUniforms({
            bitmapTexture: image,
            desaturate,
            transparentColor: transparentColor.map(function(x) {
              return x / 255;
            }),
            tintColor: tintColor.slice(0, 3).map(function(x) {
              return x / 255;
            }),
            coordinateConversion,
            bounds
          }).draw();
        }
      }
    }, {
      key: "_getCoordinateUniforms",
      value: function _getCoordinateUniforms() {
        var LNGLAT = COORDINATE_SYSTEM.LNGLAT, CARTESIAN = COORDINATE_SYSTEM.CARTESIAN, DEFAULT = COORDINATE_SYSTEM.DEFAULT;
        var imageCoordinateSystem = this.props._imageCoordinateSystem;
        if (imageCoordinateSystem !== DEFAULT) {
          var bounds = this.props.bounds;
          if (!Number.isFinite(bounds[0])) {
            throw new Error("_imageCoordinateSystem only supports rectangular bounds");
          }
          var defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
          imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
          if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
            return {
              coordinateConversion: -1,
              bounds
            };
          }
          if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
            var bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
            var topRight = lngLatToWorld([bounds[2], bounds[3]]);
            return {
              coordinateConversion: 1,
              bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
            };
          }
        }
        return {
          coordinateConversion: 0,
          bounds: [0, 0, 0, 0]
        };
      }
    }]);
    return BitmapLayer2;
  }(Layer);
  BitmapLayer.layerName = "BitmapLayer";
  BitmapLayer.defaultProps = defaultProps4;
  function unpackUVsFromRGB(color) {
    var _color = _slicedToArray(color, 3), u = _color[0], v = _color[1], fracUV = _color[2];
    var vFrac = (fracUV & 240) / 256;
    var uFrac = (fracUV & 15) / 16;
    return [(u + uFrac) / 256, (v + vFrac) / 256];
  }

  // node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js
  var icon_layer_vertex_glsl_default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js
  var icon_layer_fragment_glsl_default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js
  var _DEFAULT_TEXTURE_PARA2;
  function ownKeys29(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread29(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys29(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys29(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper46(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray47(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray47(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray47(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray47(o, minLen);
  }
  function _arrayLikeToArray47(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DEFAULT_CANVAS_WIDTH = 1024;
  var DEFAULT_BUFFER = 4;
  var noop6 = function noop7() {
  };
  var DEFAULT_TEXTURE_PARAMETERS2 = (_DEFAULT_TEXTURE_PARA2 = {}, _defineProperty(_DEFAULT_TEXTURE_PARA2, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA2, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA2, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA2, 10243, 33071), _DEFAULT_TEXTURE_PARA2);
  function nextPowOfTwo(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function resizeImage(ctx, imageData, width, height) {
    if (width === imageData.width && height === imageData.height) {
      return imageData;
    }
    ctx.canvas.height = height;
    ctx.canvas.width = width;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
    return ctx.canvas;
  }
  function getIconId(icon) {
    return icon && (icon.id || icon.url);
  }
  function resizeTexture(gl, texture, width, height) {
    var oldWidth = texture.width;
    var oldHeight = texture.height;
    var newTexture = cloneTextureFrom(texture, {
      width,
      height
    });
    copyToTexture(texture, newTexture, {
      targetY: 0,
      width: oldWidth,
      height: oldHeight
    });
    texture["delete"]();
    return newTexture;
  }
  function buildRowMapping(mapping, columns, yOffset) {
    for (var i = 0; i < columns.length; i++) {
      var _columns$i = columns[i], icon = _columns$i.icon, xOffset = _columns$i.xOffset;
      var id = getIconId(icon);
      mapping[id] = Object.assign({}, icon, {
        x: xOffset,
        y: yOffset
      });
    }
  }
  function buildMapping(_ref) {
    var icons = _ref.icons, buffer = _ref.buffer, _ref$mapping = _ref.mapping, mapping = _ref$mapping === void 0 ? {} : _ref$mapping, _ref$xOffset = _ref.xOffset, xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset, _ref$yOffset = _ref.yOffset, yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset, _ref$rowHeight = _ref.rowHeight, rowHeight = _ref$rowHeight === void 0 ? 0 : _ref$rowHeight, canvasWidth = _ref.canvasWidth;
    var columns = [];
    for (var i = 0; i < icons.length; i++) {
      var icon = icons[i];
      var id = getIconId(icon);
      if (!mapping[id]) {
        var height = icon.height, width = icon.width;
        if (xOffset + width + buffer > canvasWidth) {
          buildRowMapping(mapping, columns, yOffset);
          xOffset = 0;
          yOffset = rowHeight + yOffset + buffer;
          rowHeight = 0;
          columns = [];
        }
        columns.push({
          icon,
          xOffset
        });
        xOffset = xOffset + width + buffer;
        rowHeight = Math.max(rowHeight, height);
      }
    }
    if (columns.length > 0) {
      buildRowMapping(mapping, columns, yOffset);
    }
    return {
      mapping,
      rowHeight,
      xOffset,
      yOffset,
      canvasWidth,
      canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
    };
  }
  function getDiffIcons(data, getIcon, cachedIcons) {
    if (!data || !getIcon) {
      return null;
    }
    cachedIcons = cachedIcons || {};
    var icons = {};
    var _createIterable = createIterable(data), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
    var _iterator = _createForOfIteratorHelper46(iterable), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var object = _step.value;
        objectInfo.index++;
        var icon = getIcon(object, objectInfo);
        var id = getIconId(icon);
        if (!icon) {
          throw new Error("Icon is missing.");
        }
        if (!icon.url) {
          throw new Error("Icon url is missing.");
        }
        if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
          icons[id] = _objectSpread29(_objectSpread29({}, icon), {}, {
            source: object,
            sourceIndex: objectInfo.index
          });
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return icons;
  }
  var IconManager = function() {
    function IconManager2(gl, _ref2) {
      var _ref2$onUpdate = _ref2.onUpdate, onUpdate = _ref2$onUpdate === void 0 ? noop6 : _ref2$onUpdate, _ref2$onError = _ref2.onError, onError = _ref2$onError === void 0 ? noop6 : _ref2$onError;
      _classCallCheck(this, IconManager2);
      this.gl = gl;
      this.onUpdate = onUpdate;
      this.onError = onError;
      this._loadOptions = null;
      this._getIcon = null;
      this._texture = null;
      this._externalTexture = null;
      this._mapping = {};
      this._pendingCount = 0;
      this._autoPacking = false;
      this._xOffset = 0;
      this._yOffset = 0;
      this._rowHeight = 0;
      this._buffer = DEFAULT_BUFFER;
      this._canvasWidth = DEFAULT_CANVAS_WIDTH;
      this._canvasHeight = 0;
      this._canvas = null;
    }
    _createClass(IconManager2, [{
      key: "finalize",
      value: function finalize() {
        if (this._texture) {
          this._texture["delete"]();
        }
      }
    }, {
      key: "getTexture",
      value: function getTexture2() {
        return this._texture || this._externalTexture;
      }
    }, {
      key: "getIconMapping",
      value: function getIconMapping(icon) {
        var id = this._autoPacking ? getIconId(icon) : icon;
        return this._mapping[id] || {};
      }
    }, {
      key: "setProps",
      value: function setProps(_ref3) {
        var loadOptions = _ref3.loadOptions, autoPacking = _ref3.autoPacking, iconAtlas = _ref3.iconAtlas, iconMapping = _ref3.iconMapping, data = _ref3.data, getIcon = _ref3.getIcon;
        if (loadOptions) {
          this._loadOptions = loadOptions;
        }
        if (autoPacking !== void 0) {
          this._autoPacking = autoPacking;
        }
        if (getIcon) {
          this._getIcon = getIcon;
        }
        if (iconMapping) {
          this._mapping = iconMapping;
        }
        if (iconAtlas) {
          this._updateIconAtlas(iconAtlas);
        }
        if (this._autoPacking && (data || getIcon) && typeof document !== "undefined") {
          this._canvas = this._canvas || document.createElement("canvas");
          this._updateAutoPacking(data);
        }
      }
    }, {
      key: "_updateIconAtlas",
      value: function _updateIconAtlas(iconAtlas) {
        if (this._texture) {
          this._texture["delete"]();
          this._texture = null;
        }
        this._externalTexture = iconAtlas;
        this.onUpdate();
      }
    }, {
      key: "_updateAutoPacking",
      value: function _updateAutoPacking(data) {
        var icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});
        if (icons.length > 0) {
          var _buildMapping = buildMapping({
            icons,
            buffer: this._buffer,
            canvasWidth: this._canvasWidth,
            mapping: this._mapping,
            rowHeight: this._rowHeight,
            xOffset: this._xOffset,
            yOffset: this._yOffset
          }), mapping = _buildMapping.mapping, xOffset = _buildMapping.xOffset, yOffset = _buildMapping.yOffset, rowHeight = _buildMapping.rowHeight, canvasHeight = _buildMapping.canvasHeight;
          this._rowHeight = rowHeight;
          this._mapping = mapping;
          this._xOffset = xOffset;
          this._yOffset = yOffset;
          this._canvasHeight = canvasHeight;
          if (!this._texture) {
            this._texture = new Texture2D(this.gl, {
              width: this._canvasWidth,
              height: this._canvasHeight,
              parameters: DEFAULT_TEXTURE_PARAMETERS2
            });
          }
          if (this._texture.height !== this._canvasHeight) {
            this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight);
          }
          this.onUpdate();
          this._loadIcons(icons);
        }
      }
    }, {
      key: "_loadIcons",
      value: function _loadIcons(icons) {
        var _this = this;
        var ctx = this._canvas.getContext("2d");
        var _iterator2 = _createForOfIteratorHelper46(icons), _step2;
        try {
          var _loop = function _loop2() {
            var icon = _step2.value;
            _this._pendingCount++;
            load(icon.url, image_loader_default, _this._loadOptions).then(function(imageData) {
              var id = getIconId(icon);
              var _this$_mapping$id = _this._mapping[id], x = _this$_mapping$id.x, y = _this$_mapping$id.y, width = _this$_mapping$id.width, height = _this$_mapping$id.height;
              var data = resizeImage(ctx, imageData, width, height);
              _this._texture.setSubImageData({
                data,
                x,
                y,
                width,
                height
              });
              _this._texture.generateMipmap();
              _this.onUpdate();
            })["catch"](function(error2) {
              _this.onError({
                url: icon.url,
                source: icon.source,
                sourceIndex: icon.sourceIndex,
                loadOptions: _this._loadOptions,
                error: error2
              });
            })["finally"](function() {
              _this._pendingCount--;
            });
          };
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            _loop();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        return this._pendingCount === 0;
      }
    }]);
    return IconManager2;
  }();

  // node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js
  function _createSuper39(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct40();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct40() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps5 = {
    iconAtlas: {
      type: "image",
      value: null,
      async: true
    },
    iconMapping: {
      type: "object",
      value: {},
      async: true
    },
    sizeScale: {
      type: "number",
      value: 1,
      min: 0
    },
    billboard: true,
    sizeUnits: "pixels",
    sizeMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    sizeMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    alphaCutoff: {
      type: "number",
      value: 0.05,
      min: 0,
      max: 1
    },
    getPosition: {
      type: "accessor",
      value: function value4(x) {
        return x.position;
      }
    },
    getIcon: {
      type: "accessor",
      value: function value5(x) {
        return x.icon;
      }
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR
    },
    getSize: {
      type: "accessor",
      value: 1
    },
    getAngle: {
      type: "accessor",
      value: 0
    },
    getPixelOffset: {
      type: "accessor",
      value: [0, 0]
    },
    onIconError: {
      type: "function",
      value: null,
      compare: false,
      optional: true
    }
  };
  var IconLayer = function(_Layer) {
    _inherits(IconLayer2, _Layer);
    var _super = _createSuper39(IconLayer2);
    function IconLayer2() {
      _classCallCheck(this, IconLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(IconLayer2, [{
      key: "getShaders",
      value: function getShaders() {
        return _get(_getPrototypeOf(IconLayer2.prototype), "getShaders", this).call(this, {
          vs: icon_layer_vertex_glsl_default,
          fs: icon_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        this.state = {
          iconManager: new IconManager(this.context.gl, {
            onUpdate: this._onUpdate.bind(this),
            onError: this._onError.bind(this)
          })
        };
        var attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceSizes: {
            size: 1,
            transition: true,
            accessor: "getSize",
            defaultValue: 1
          },
          instanceOffsets: {
            size: 2,
            accessor: "getIcon",
            transform: this.getInstanceOffset
          },
          instanceIconFrames: {
            size: 4,
            accessor: "getIcon",
            transform: this.getInstanceIconFrame
          },
          instanceColorModes: {
            size: 1,
            type: 5121,
            accessor: "getIcon",
            transform: this.getInstanceColorMode
          },
          instanceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getColor",
            defaultValue: DEFAULT_COLOR
          },
          instanceAngles: {
            size: 1,
            transition: true,
            accessor: "getAngle"
          },
          instancePixelOffset: {
            size: 2,
            transition: true,
            accessor: "getPixelOffset"
          }
        });
      }
    }, {
      key: "updateState",
      value: function updateState(_ref) {
        var oldProps = _ref.oldProps, props = _ref.props, changeFlags = _ref.changeFlags;
        _get(_getPrototypeOf(IconLayer2.prototype), "updateState", this).call(this, {
          props,
          oldProps,
          changeFlags
        });
        var attributeManager = this.getAttributeManager();
        var iconAtlas = props.iconAtlas, iconMapping = props.iconMapping, data = props.data, getIcon = props.getIcon;
        var iconManager = this.state.iconManager;
        iconManager.setProps({
          loadOptions: props.loadOptions
        });
        var iconMappingChanged = false;
        var prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
        if (prePacked) {
          if (oldProps.iconAtlas !== props.iconAtlas) {
            iconManager.setProps({
              iconAtlas,
              autoPacking: false
            });
          }
          if (oldProps.iconMapping !== props.iconMapping) {
            iconManager.setProps({
              iconMapping
            });
            iconMappingChanged = true;
          }
        } else {
          iconManager.setProps({
            autoPacking: true
          });
        }
        if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
          iconManager.setProps({
            data,
            getIcon
          });
        }
        if (iconMappingChanged) {
          attributeManager.invalidate("instanceOffsets");
          attributeManager.invalidate("instanceIconFrames");
          attributeManager.invalidate("instanceColorModes");
        }
        if (changeFlags.extensionsChanged) {
          var gl = this.context.gl;
          if (this.state.model) {
            this.state.model["delete"]();
          }
          this.setState({
            model: this._getModel(gl)
          });
          attributeManager.invalidateAll();
        }
      }
    }, {
      key: "finalizeState",
      value: function finalizeState() {
        _get(_getPrototypeOf(IconLayer2.prototype), "finalizeState", this).call(this);
        this.state.iconManager.finalize();
      }
    }, {
      key: "draw",
      value: function draw(_ref2) {
        var uniforms = _ref2.uniforms;
        var _this$props = this.props, sizeScale = _this$props.sizeScale, sizeMinPixels = _this$props.sizeMinPixels, sizeMaxPixels = _this$props.sizeMaxPixels, sizeUnits = _this$props.sizeUnits, billboard = _this$props.billboard, alphaCutoff = _this$props.alphaCutoff;
        var iconManager = this.state.iconManager;
        var viewport3 = this.context.viewport;
        var iconsTexture = iconManager.getTexture();
        if (iconsTexture) {
          this.state.model.setUniforms(Object.assign({}, uniforms, {
            iconsTexture,
            iconsTextureDim: [iconsTexture.width, iconsTexture.height],
            sizeScale: sizeScale * (sizeUnits === "pixels" ? viewport3.metersPerPixel : 1),
            sizeMinPixels,
            sizeMaxPixels,
            billboard,
            alphaCutoff
          })).draw();
        }
      }
    }, {
      key: "_getModel",
      value: function _getModel(gl) {
        var positions = [-1, -1, -1, 1, 1, 1, 1, -1];
        return new Model(gl, Object.assign({}, this.getShaders(), {
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 6,
            attributes: {
              positions: {
                size: 2,
                value: new Float32Array(positions)
              }
            }
          }),
          isInstanced: true
        }));
      }
    }, {
      key: "_onUpdate",
      value: function _onUpdate() {
        this.setNeedsRedraw();
      }
    }, {
      key: "_onError",
      value: function _onError(evt) {
        var onIconError = this.getCurrentLayer().props.onIconError;
        if (onIconError) {
          onIconError(evt);
        } else {
          log_default.error(evt.error)();
        }
      }
    }, {
      key: "getInstanceOffset",
      value: function getInstanceOffset(icon) {
        var rect = this.state.iconManager.getIconMapping(icon);
        return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];
      }
    }, {
      key: "getInstanceColorMode",
      value: function getInstanceColorMode(icon) {
        var mapping = this.state.iconManager.getIconMapping(icon);
        return mapping.mask ? 1 : 0;
      }
    }, {
      key: "getInstanceIconFrame",
      value: function getInstanceIconFrame(icon) {
        var rect = this.state.iconManager.getIconMapping(icon);
        return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        return _get(_getPrototypeOf(IconLayer2.prototype), "isLoaded", this) && this.state.iconManager.isLoaded;
      }
    }]);
    return IconLayer2;
  }(Layer);
  IconLayer.layerName = "IconLayer";
  IconLayer.defaultProps = defaultProps5;

  // node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js
  var scatterplot_layer_vertex_glsl_default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js
  var scatterplot_layer_fragment_glsl_default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = smoothedge(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js
  function _createSuper40(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct41();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct41() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_COLOR2 = [0, 0, 0, 255];
  var defaultProps6 = {
    radiusUnits: "meters",
    radiusScale: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    radiusMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    lineWidthUnits: "meters",
    lineWidthScale: {
      type: "number",
      min: 0,
      value: 1
    },
    lineWidthMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    lineWidthMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    stroked: false,
    filled: true,
    getPosition: {
      type: "accessor",
      value: function value6(x) {
        return x.position;
      }
    },
    getRadius: {
      type: "accessor",
      value: 1
    },
    getFillColor: {
      type: "accessor",
      value: DEFAULT_COLOR2
    },
    getLineColor: {
      type: "accessor",
      value: DEFAULT_COLOR2
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    strokeWidth: {
      deprecatedFor: "getLineWidth"
    },
    outline: {
      deprecatedFor: "stroked"
    },
    getColor: {
      deprecatedFor: ["getFillColor", "getLineColor"]
    }
  };
  var ScatterplotLayer = function(_Layer) {
    _inherits(ScatterplotLayer2, _Layer);
    var _super = _createSuper40(ScatterplotLayer2);
    function ScatterplotLayer2() {
      _classCallCheck(this, ScatterplotLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(ScatterplotLayer2, [{
      key: "getShaders",
      value: function getShaders() {
        return _get(_getPrototypeOf(ScatterplotLayer2.prototype), "getShaders", this).call(this, {
          vs: scatterplot_layer_vertex_glsl_default,
          fs: scatterplot_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        this.getAttributeManager().addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceRadius: {
            size: 1,
            transition: true,
            accessor: "getRadius",
            defaultValue: 1
          },
          instanceFillColors: {
            size: this.props.colorFormat.length,
            transition: true,
            normalized: true,
            type: 5121,
            accessor: "getFillColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceLineColors: {
            size: this.props.colorFormat.length,
            transition: true,
            normalized: true,
            type: 5121,
            accessor: "getLineColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceLineWidths: {
            size: 1,
            transition: true,
            accessor: "getLineWidth",
            defaultValue: 1
          }
        });
      }
    }, {
      key: "updateState",
      value: function updateState(_ref) {
        var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
        _get(_getPrototypeOf(ScatterplotLayer2.prototype), "updateState", this).call(this, {
          props,
          oldProps,
          changeFlags
        });
        if (changeFlags.extensionsChanged) {
          var gl = this.context.gl;
          if (this.state.model) {
            this.state.model["delete"]();
          }
          this.setState({
            model: this._getModel(gl)
          });
          this.getAttributeManager().invalidateAll();
        }
      }
    }, {
      key: "draw",
      value: function draw(_ref2) {
        var uniforms = _ref2.uniforms;
        var viewport3 = this.context.viewport;
        var _this$props = this.props, radiusUnits = _this$props.radiusUnits, radiusScale = _this$props.radiusScale, radiusMinPixels = _this$props.radiusMinPixels, radiusMaxPixels = _this$props.radiusMaxPixels, stroked = _this$props.stroked, filled = _this$props.filled, lineWidthUnits = _this$props.lineWidthUnits, lineWidthScale = _this$props.lineWidthScale, lineWidthMinPixels = _this$props.lineWidthMinPixels, lineWidthMaxPixels = _this$props.lineWidthMaxPixels;
        var pointRadiusMultiplier = radiusUnits === "pixels" ? viewport3.metersPerPixel : 1;
        var lineWidthMultiplier = lineWidthUnits === "pixels" ? viewport3.metersPerPixel : 1;
        this.state.model.setUniforms(uniforms).setUniforms({
          stroked: stroked ? 1 : 0,
          filled,
          radiusScale: radiusScale * pointRadiusMultiplier,
          radiusMinPixels,
          radiusMaxPixels,
          lineWidthScale: lineWidthScale * lineWidthMultiplier,
          lineWidthMinPixels,
          lineWidthMaxPixels
        }).draw();
      }
    }, {
      key: "_getModel",
      value: function _getModel(gl) {
        var positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
        return new Model(gl, Object.assign(this.getShaders(), {
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 6,
            vertexCount: 4,
            attributes: {
              positions: {
                size: 3,
                value: new Float32Array(positions)
              }
            }
          }),
          isInstanced: true
        }));
      }
    }]);
    return ScatterplotLayer2;
  }(Layer);
  ScatterplotLayer.layerName = "ScatterplotLayer";
  ScatterplotLayer.defaultProps = defaultProps6;

  // node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
  var WINDING = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
  };
  function modifyPolygonWindingDirection(points, direction) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var windingDirection = getPolygonWindingDirection(points, options);
    if (windingDirection !== direction) {
      reversePolygon(points, options);
      return true;
    }
    return false;
  }
  function getPolygonWindingDirection(points) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Math.sign(getPolygonSignedArea(points, options));
  }
  function getPolygonSignedArea(points) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var area = 0;
    forEachSegmentInPolygon(points, function(p1x, p1y, p2x, p2y) {
      area += areaCalcCallback(p1x, p1y, p2x, p2y);
    }, options);
    return area / 2;
  }
  function forEachSegmentInPolygon(points, visitor) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _options$start = options.start, start2 = _options$start === void 0 ? 0 : _options$start, _options$end = options.end, end = _options$end === void 0 ? points.length : _options$end, _options$size = options.size, size = _options$size === void 0 ? 2 : _options$size, isClosed = options.isClosed;
    var numPoints = (end - start2) / size;
    for (var i = 0; i < numPoints - 1; ++i) {
      visitor(points[start2 + i * size], points[start2 + i * size + 1], points[start2 + (i + 1) * size], points[start2 + (i + 1) * size + 1], i, i + 1);
    }
    var endPointIndex = start2 + (numPoints - 1) * size;
    var isClosedEx = isClosed || equals(points[start2], points[endPointIndex]) && equals(points[start2 + 1], points[endPointIndex + 1]);
    if (!isClosedEx) {
      visitor(points[endPointIndex], points[endPointIndex + 1], points[start2], points[start2 + 1], numPoints - 1, 0);
    }
  }
  function reversePolygon(points, options) {
    var _options$start2 = options.start, start2 = _options$start2 === void 0 ? 0 : _options$start2, _options$end2 = options.end, end = _options$end2 === void 0 ? points.length : _options$end2, _options$size2 = options.size, size = _options$size2 === void 0 ? 2 : _options$size2;
    var numPoints = (end - start2) / size;
    var numSwaps = Math.floor(numPoints / 2);
    for (var i = 0; i < numSwaps; ++i) {
      var b1 = start2 + i * size;
      var b2 = start2 + (numPoints - 1 - i) * size;
      for (var j = 0; j < size; ++j) {
        var tmp = points[b1 + j];
        points[b1 + j] = points[b2 + j];
        points[b2 + j] = tmp;
      }
    }
  }
  function modifyPolygonWindingDirectionPoints(points, direction) {
    var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var currentDirection = getPolygonWindingDirectionPoints(points, params);
    if (currentDirection !== direction) {
      points.reverse();
      return true;
    }
    return false;
  }
  function getPolygonWindingDirectionPoints(points) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Math.sign(getPolygonSignedAreaPoints(points, params));
  }
  function getPolygonSignedAreaPoints(points) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var area = 0;
    forEachSegmentInPolygonPoints(points, function(p1, p2) {
      area += areaCalcCallback(p1[0], p1[1], p2[0], p2[1]);
    }, params);
    return area / 2;
  }
  function forEachSegmentInPolygonPoints(points, visitor) {
    var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _params$start = params.start, start2 = _params$start === void 0 ? 0 : _params$start, _params$end = params.end, end = _params$end === void 0 ? points.length : _params$end, isClosed = params.isClosed;
    for (var i = start2; i < end - 1; ++i) {
      visitor(points[i], points[i + 1], i, i + 1);
    }
    var isClosedEx = isClosed || equals(points[end - 1], points[0]);
    if (!isClosedEx) {
      visitor(points[end - 1], points[0], end - 1, 0);
    }
  }
  function areaCalcCallback(p1x, p1y, p2x, p2y) {
    return (p1x + p2x) * (p1y - p2y);
  }

  // node_modules/@math.gl/polygon/dist/esm/polygon.js
  var Polygon = function() {
    function Polygon3(points) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Polygon3);
      this.points = points;
      this.isFlatArray = !isArray2(points[0]);
      this.options = {
        start: options.start || 0,
        end: options.end || points.length,
        size: options.size || 2,
        isClosed: options.isClosed
      };
      Object.freeze(this);
    }
    _createClass(Polygon3, [{
      key: "getSignedArea",
      value: function getSignedArea() {
        if (this.isFlatArray)
          return getPolygonSignedArea(this.points, this.options);
        return getPolygonSignedAreaPoints(this.points, this.options);
      }
    }, {
      key: "getArea",
      value: function getArea() {
        return Math.abs(this.getSignedArea());
      }
    }, {
      key: "getWindingDirection",
      value: function getWindingDirection() {
        return Math.sign(this.getSignedArea());
      }
    }, {
      key: "forEachSegment",
      value: function forEachSegment(visitor) {
        if (this.isFlatArray) {
          forEachSegmentInPolygon(this.points, function(x1, y1, x2, y2, i1, i2) {
            visitor([x1, y1], [x2, y2], i1, i2);
          }, this.options);
        } else {
          forEachSegmentInPolygonPoints(this.points, visitor, this.options);
        }
      }
    }, {
      key: "modifyWindingDirection",
      value: function modifyWindingDirection(direction) {
        if (this.isFlatArray) {
          return modifyPolygonWindingDirection(this.points, direction, this.options);
        }
        return modifyPolygonWindingDirectionPoints(this.points, direction, this.options);
      }
    }]);
    return Polygon3;
  }();

  // node_modules/@math.gl/polygon/dist/esm/utils.js
  function push(target, source) {
    var size = source.length;
    var startIndex = target.length;
    if (startIndex > 0) {
      var isDuplicate = true;
      for (var i = 0; i < size; i++) {
        if (target[startIndex - size + i] !== source[i]) {
          isDuplicate = false;
          break;
        }
      }
      if (isDuplicate) {
        return false;
      }
    }
    for (var _i = 0; _i < size; _i++) {
      target[startIndex + _i] = source[_i];
    }
    return true;
  }
  function copy2(target, source) {
    var size = source.length;
    for (var i = 0; i < size; i++) {
      target[i] = source[i];
    }
  }
  function getPointAtIndex(positions, index, size, offset) {
    var out = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
    var startI = offset + index * size;
    for (var i = 0; i < size; i++) {
      out[i] = positions[startI + i];
    }
    return out;
  }

  // node_modules/@math.gl/polygon/dist/esm/lineclip.js
  function intersect(a, b, edge, bbox) {
    var out = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
    var t;
    var snap;
    if (edge & 8) {
      t = (bbox[3] - a[1]) / (b[1] - a[1]);
      snap = 3;
    } else if (edge & 4) {
      t = (bbox[1] - a[1]) / (b[1] - a[1]);
      snap = 1;
    } else if (edge & 2) {
      t = (bbox[2] - a[0]) / (b[0] - a[0]);
      snap = 2;
    } else if (edge & 1) {
      t = (bbox[0] - a[0]) / (b[0] - a[0]);
      snap = 0;
    } else {
      return null;
    }
    for (var i = 0; i < a.length; i++) {
      out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
    }
    return out;
  }
  function bitCode(p, bbox) {
    var code = 0;
    if (p[0] < bbox[0])
      code |= 1;
    else if (p[0] > bbox[2])
      code |= 2;
    if (p[1] < bbox[1])
      code |= 4;
    else if (p[1] > bbox[3])
      code |= 8;
    return code;
  }

  // node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
  function cutPolylineByGrid(positions) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _options$size = options.size, size = _options$size === void 0 ? 2 : _options$size, _options$broken = options.broken, broken = _options$broken === void 0 ? false : _options$broken, _options$gridResoluti = options.gridResolution, gridResolution = _options$gridResoluti === void 0 ? 10 : _options$gridResoluti, _options$gridOffset = options.gridOffset, gridOffset = _options$gridOffset === void 0 ? [0, 0] : _options$gridOffset, _options$startIndex = options.startIndex, startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex, _options$endIndex = options.endIndex, endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex;
    var numPoints = (endIndex - startIndex) / size;
    var part = [];
    var result = [part];
    var a = getPointAtIndex(positions, 0, size, startIndex);
    var b;
    var codeB;
    var cell = getGridCell(a, gridResolution, gridOffset, []);
    var scratchPoint = [];
    push(part, a);
    for (var i = 1; i < numPoints; i++) {
      b = getPointAtIndex(positions, i, size, startIndex, b);
      codeB = bitCode(b, cell);
      while (codeB) {
        intersect(a, b, codeB, cell, scratchPoint);
        var codeAlt = bitCode(scratchPoint, cell);
        if (codeAlt) {
          intersect(a, scratchPoint, codeAlt, cell, scratchPoint);
          codeB = codeAlt;
        }
        push(part, scratchPoint);
        copy2(a, scratchPoint);
        moveToNeighborCell(cell, gridResolution, codeB);
        if (broken && part.length > size) {
          part = [];
          result.push(part);
          push(part, a);
        }
        codeB = bitCode(b, cell);
      }
      push(part, b);
      copy2(a, b);
    }
    return broken ? result : result[0];
  }
  var TYPE_INSIDE = 0;
  var TYPE_BORDER = 1;
  function concatInPlace(arr1, arr2) {
    for (var i = 0; i < arr2.length; i++) {
      arr1.push(arr2[i]);
    }
    return arr1;
  }
  function cutPolygonByGrid(positions, holeIndices) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!positions.length) {
      return [];
    }
    var _options$size2 = options.size, size = _options$size2 === void 0 ? 2 : _options$size2, _options$gridResoluti2 = options.gridResolution, gridResolution = _options$gridResoluti2 === void 0 ? 10 : _options$gridResoluti2, _options$gridOffset2 = options.gridOffset, gridOffset = _options$gridOffset2 === void 0 ? [0, 0] : _options$gridOffset2, _options$edgeTypes = options.edgeTypes, edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;
    var result = [];
    var queue = [{
      pos: positions,
      types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),
      holes: holeIndices || []
    }];
    var bbox = [[], []];
    var cell = [];
    while (queue.length) {
      var _queue$shift = queue.shift(), pos = _queue$shift.pos, types = _queue$shift.types, holes = _queue$shift.holes;
      getBoundingBox(pos, size, holes[0] || pos.length, bbox);
      cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
      var code = bitCode(bbox[1], cell);
      if (code) {
        var parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
        var polygonLow = {
          pos: parts[0].pos,
          types: parts[0].types,
          holes: []
        };
        var polygonHigh = {
          pos: parts[1].pos,
          types: parts[1].types,
          holes: []
        };
        queue.push(polygonLow, polygonHigh);
        for (var i = 0; i < holes.length; i++) {
          parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
          if (parts[0]) {
            polygonLow.holes.push(polygonLow.pos.length);
            polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
            if (edgeTypes) {
              polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
            }
          }
          if (parts[1]) {
            polygonHigh.holes.push(polygonHigh.pos.length);
            polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
            if (edgeTypes) {
              polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
            }
          }
        }
      } else {
        var polygon = {
          positions: pos
        };
        if (edgeTypes) {
          polygon.edgeTypes = types;
        }
        if (holes.length) {
          polygon.holeIndices = holes;
        }
        result.push(polygon);
      }
    }
    return result;
  }
  function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
    var numPoints = (endIndex - startIndex) / size;
    var resultLow = [];
    var resultHigh = [];
    var typesLow = [];
    var typesHigh = [];
    var scratchPoint = [];
    var p;
    var side;
    var type;
    var prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
    var prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
    var prevType = edgeTypes && edgeTypes[numPoints - 1];
    var lowPointCount = 0;
    var highPointCount = 0;
    for (var i = 0; i < numPoints; i++) {
      p = getPointAtIndex(positions, i, size, startIndex, p);
      side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
      type = edgeTypes && edgeTypes[startIndex / size + i];
      if (side && prevSide && prevSide !== side) {
        intersect(prev, p, edge, bbox, scratchPoint);
        push(resultLow, scratchPoint) && typesLow.push(prevType);
        push(resultHigh, scratchPoint) && typesHigh.push(prevType);
      }
      if (side <= 0) {
        push(resultLow, p) && typesLow.push(type);
        lowPointCount -= side;
      } else if (typesLow.length) {
        typesLow[typesLow.length - 1] = TYPE_INSIDE;
      }
      if (side >= 0) {
        push(resultHigh, p) && typesHigh.push(type);
        highPointCount += side;
      } else if (typesHigh.length) {
        typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
      }
      copy2(prev, p);
      prevSide = side;
      prevType = type;
    }
    return [lowPointCount ? {
      pos: resultLow,
      types: edgeTypes && typesLow
    } : null, highPointCount ? {
      pos: resultHigh,
      types: edgeTypes && typesHigh
    } : null];
  }
  function getGridCell(p, gridResolution, gridOffset, out) {
    var left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    var bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left;
    out[1] = bottom;
    out[2] = left + gridResolution;
    out[3] = bottom + gridResolution;
    return out;
  }
  function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
      cell[1] += gridResolution;
      cell[3] += gridResolution;
    } else if (edge & 4) {
      cell[1] -= gridResolution;
      cell[3] -= gridResolution;
    } else if (edge & 2) {
      cell[0] += gridResolution;
      cell[2] += gridResolution;
    } else if (edge & 1) {
      cell[0] -= gridResolution;
      cell[2] -= gridResolution;
    }
  }
  function getBoundingBox(positions, size, endIndex, out) {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < endIndex; i += size) {
      var x = positions[i];
      var y = positions[i + 1];
      minX = x < minX ? x : minX;
      maxX = x > maxX ? x : maxX;
      minY = y < minY ? y : minY;
      maxY = y > maxY ? y : maxY;
    }
    out[0][0] = minX;
    out[0][1] = minY;
    out[1][0] = maxX;
    out[1][1] = maxY;
    return out;
  }

  // node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
  function _createForOfIteratorHelper47(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray48(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray48(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray48(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray48(o, minLen);
  }
  function _arrayLikeToArray48(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DEFAULT_MAX_LATITUDE = 85.051129;
  function cutPolylineByMercatorBounds(positions) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _options$size = options.size, size = _options$size === void 0 ? 2 : _options$size, _options$startIndex = options.startIndex, startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex, _options$endIndex = options.endIndex, endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex, _options$normalize = options.normalize, normalize5 = _options$normalize === void 0 ? true : _options$normalize;
    var newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
    var parts = cutPolylineByGrid(newPositions, {
      size,
      broken: true,
      gridResolution: 360,
      gridOffset: [-180, -180]
    });
    if (normalize5) {
      var _iterator = _createForOfIteratorHelper47(parts), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var part = _step.value;
          shiftLongitudesIntoRange(part, size);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return parts;
  }
  function cutPolygonByMercatorBounds(positions, holeIndices) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _options$size2 = options.size, size = _options$size2 === void 0 ? 2 : _options$size2, _options$normalize2 = options.normalize, normalize5 = _options$normalize2 === void 0 ? true : _options$normalize2, _options$edgeTypes = options.edgeTypes, edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;
    holeIndices = holeIndices || [];
    var newPositions = [];
    var newHoleIndices = [];
    var srcStartIndex = 0;
    var targetIndex = 0;
    for (var ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
      var srcEndIndex = holeIndices[ringIndex] || positions.length;
      var targetStartIndex = targetIndex;
      var splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
      for (var i = splitIndex; i < srcEndIndex; i++) {
        newPositions[targetIndex++] = positions[i];
      }
      for (var _i = srcStartIndex; _i < splitIndex; _i++) {
        newPositions[targetIndex++] = positions[_i];
      }
      wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
      insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);
      srcStartIndex = srcEndIndex;
      newHoleIndices[ringIndex] = targetIndex;
    }
    newHoleIndices.pop();
    var parts = cutPolygonByGrid(newPositions, newHoleIndices, {
      size,
      gridResolution: 360,
      gridOffset: [-180, -180],
      edgeTypes
    });
    if (normalize5) {
      var _iterator2 = _createForOfIteratorHelper47(parts), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var part = _step2.value;
          shiftLongitudesIntoRange(part.positions, size);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    return parts;
  }
  function findSplitIndex(positions, size, startIndex, endIndex) {
    var maxLat = -1;
    var pointIndex = -1;
    for (var i = startIndex + 1; i < endIndex; i += size) {
      var lat = Math.abs(positions[i]);
      if (lat > maxLat) {
        maxLat = lat;
        pointIndex = i - 1;
      }
    }
    return pointIndex;
  }
  function insertPoleVertices(positions, size, startIndex, endIndex) {
    var maxLatitude = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_MAX_LATITUDE;
    var firstLng = positions[startIndex];
    var lastLng = positions[endIndex - size];
    if (Math.abs(firstLng - lastLng) > 180) {
      var p = getPointAtIndex(positions, 0, size, startIndex);
      p[0] += Math.round((lastLng - firstLng) / 360) * 360;
      push(positions, p);
      p[1] = Math.sign(p[1]) * maxLatitude;
      push(positions, p);
      p[0] = firstLng;
      push(positions, p);
    }
  }
  function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
    var prevLng = positions[0];
    var lng;
    for (var i = startIndex; i < endIndex; i += size) {
      lng = positions[i];
      var delta = lng - prevLng;
      if (delta > 180 || delta < -180) {
        lng -= Math.round(delta / 360) * 360;
      }
      positions[i] = prevLng = lng;
    }
  }
  function shiftLongitudesIntoRange(positions, size) {
    var refLng;
    var pointCount = positions.length / size;
    for (var i = 0; i < pointCount; i++) {
      refLng = positions[i * size];
      if ((refLng + 180) % 360 !== 0) {
        break;
      }
    }
    var delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
      return;
    }
    for (var _i2 = 0; _i2 < pointCount; _i2++) {
      positions[_i2 * size] += delta;
    }
  }

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path.js
  function normalizePath(path, size, gridResolution, wrapLongitude) {
    var flatPath = path;
    if (Array.isArray(path[0])) {
      var length4 = path.length * size;
      flatPath = new Array(length4);
      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < size; j++) {
          flatPath[i * size + j] = path[i][j] || 0;
        }
      }
    }
    if (gridResolution) {
      return cutPolylineByGrid(flatPath, {
        size,
        gridResolution
      });
    }
    if (wrapLongitude) {
      return cutPolylineByMercatorBounds(flatPath, {
        size
      });
    }
    return flatPath;
  }

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js
  function _createForOfIteratorHelper48(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray49(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray49(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray49(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray49(o, minLen);
  }
  function _arrayLikeToArray49(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys30(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread30(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys30(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys30(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper41(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct42();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct42() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var START_CAP = 1;
  var END_CAP = 2;
  var INVALID = 4;
  var PathTesselator = function(_Tesselator) {
    _inherits(PathTesselator2, _Tesselator);
    var _super = _createSuper41(PathTesselator2);
    function PathTesselator2(opts) {
      _classCallCheck(this, PathTesselator2);
      return _super.call(this, _objectSpread30(_objectSpread30({}, opts), {}, {
        attributes: {
          positions: {
            size: 3,
            padding: 18,
            initialize: true,
            type: opts.fp64 ? Float64Array : Float32Array
          },
          segmentTypes: {
            size: 1,
            type: Uint8ClampedArray
          }
        }
      }));
    }
    _createClass(PathTesselator2, [{
      key: "getGeometryFromBuffer",
      value: function getGeometryFromBuffer(buffer) {
        if (this.normalize) {
          return _get(_getPrototypeOf(PathTesselator2.prototype), "getGeometryFromBuffer", this).call(this, buffer);
        }
        return function() {
          return null;
        };
      }
    }, {
      key: "normalizeGeometry",
      value: function normalizeGeometry(path) {
        if (this.normalize) {
          return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
        }
        return path;
      }
    }, {
      key: "get",
      value: function get2(attributeName) {
        return this.attributes[attributeName];
      }
    }, {
      key: "getGeometrySize",
      value: function getGeometrySize(path) {
        if (Array.isArray(path[0])) {
          var size = 0;
          var _iterator = _createForOfIteratorHelper48(path), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var subPath = _step.value;
              size += this.getGeometrySize(subPath);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return size;
        }
        var numPoints = this.getPathLength(path);
        if (numPoints < 2) {
          return 0;
        }
        if (this.isClosed(path)) {
          return numPoints < 3 ? 0 : numPoints + 2;
        }
        return numPoints;
      }
    }, {
      key: "updateGeometryAttributes",
      value: function updateGeometryAttributes(path, context) {
        if (context.geometrySize === 0) {
          return;
        }
        if (path && Array.isArray(path[0])) {
          var _iterator2 = _createForOfIteratorHelper48(path), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var subPath = _step2.value;
              var geometrySize = this.getGeometrySize(subPath);
              context.geometrySize = geometrySize;
              this.updateGeometryAttributes(subPath, context);
              context.vertexStart += geometrySize;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else {
          this._updateSegmentTypes(path, context);
          this._updatePositions(path, context);
        }
      }
    }, {
      key: "_updateSegmentTypes",
      value: function _updateSegmentTypes(path, context) {
        var segmentTypes = this.attributes.segmentTypes;
        var isPathClosed = this.isClosed(path);
        var vertexStart = context.vertexStart, geometrySize = context.geometrySize;
        segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
        if (isPathClosed) {
          segmentTypes[vertexStart] = INVALID;
          segmentTypes[vertexStart + geometrySize - 2] = INVALID;
        } else {
          segmentTypes[vertexStart] += START_CAP;
          segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
        }
        segmentTypes[vertexStart + geometrySize - 1] = INVALID;
      }
    }, {
      key: "_updatePositions",
      value: function _updatePositions(path, context) {
        var positions = this.attributes.positions;
        if (!positions) {
          return;
        }
        var vertexStart = context.vertexStart, geometrySize = context.geometrySize;
        var p = new Array(3);
        for (var i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
          this.getPointOnPath(path, ptIndex, p);
          positions[i * 3] = p[0];
          positions[i * 3 + 1] = p[1];
          positions[i * 3 + 2] = p[2];
        }
      }
    }, {
      key: "getPathLength",
      value: function getPathLength(path) {
        return path.length / this.positionSize;
      }
    }, {
      key: "getPointOnPath",
      value: function getPointOnPath(path, index) {
        var target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        var positionSize = this.positionSize;
        if (index * positionSize >= path.length) {
          index += 1 - path.length / positionSize;
        }
        var i = index * positionSize;
        target[0] = path[i];
        target[1] = path[i + 1];
        target[2] = positionSize === 3 && path[i + 2] || 0;
        return target;
      }
    }, {
      key: "isClosed",
      value: function isClosed(path) {
        if (!this.normalize) {
          return this.opts.loop;
        }
        var positionSize = this.positionSize;
        var lastPointIndex = path.length - positionSize;
        return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
      }
    }]);
    return PathTesselator2;
  }(Tesselator);

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js
  var path_layer_vertex_glsl_default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * jointType * 4.0 * flipIfTrue(isStartCap), isJoint);\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition = instanceStartPositions;\n  geometry.worldPositionAlt = instanceEndPositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js
  var path_layer_fragment_glsl_default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (jointType > 0.0 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (jointType == 0.0 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js
  function _createSuper42(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct43();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct43() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_COLOR3 = [0, 0, 0, 255];
  var defaultProps7 = {
    widthUnits: "meters",
    widthScale: {
      type: "number",
      min: 0,
      value: 1
    },
    widthMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    widthMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    rounded: false,
    miterLimit: {
      type: "number",
      min: 0,
      value: 4
    },
    billboard: false,
    _pathType: null,
    getPath: {
      type: "accessor",
      value: function value7(object) {
        return object.path;
      }
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR3
    },
    getWidth: {
      type: "accessor",
      value: 1
    }
  };
  var ATTRIBUTE_TRANSITION = {
    enter: function enter(value17, chunk) {
      return chunk.length ? chunk.subarray(chunk.length - value17.length) : value17;
    }
  };
  var PathLayer = function(_Layer) {
    _inherits(PathLayer2, _Layer);
    var _super = _createSuper42(PathLayer2);
    function PathLayer2() {
      _classCallCheck(this, PathLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(PathLayer2, [{
      key: "getShaders",
      value: function getShaders() {
        return _get(_getPrototypeOf(PathLayer2.prototype), "getShaders", this).call(this, {
          vs: path_layer_vertex_glsl_default,
          fs: path_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        var _this = this;
        var noAlloc = true;
        var attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          positions: {
            size: 3,
            vertexOffset: 1,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: ATTRIBUTE_TRANSITION,
            accessor: "getPath",
            update: this.calculatePositions,
            noAlloc,
            shaderAttributes: {
              instanceLeftPositions: {
                vertexOffset: 0
              },
              instanceStartPositions: {
                vertexOffset: 1
              },
              instanceEndPositions: {
                vertexOffset: 2
              },
              instanceRightPositions: {
                vertexOffset: 3
              }
            }
          },
          instanceTypes: {
            size: 1,
            type: 5121,
            update: this.calculateSegmentTypes,
            noAlloc
          },
          instanceStrokeWidths: {
            size: 1,
            accessor: "getWidth",
            transition: ATTRIBUTE_TRANSITION,
            defaultValue: 1
          },
          instanceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            accessor: "getColor",
            transition: ATTRIBUTE_TRANSITION,
            defaultValue: DEFAULT_COLOR3
          },
          instancePickingColors: {
            size: 3,
            type: 5121,
            accessor: function accessor(object, _ref) {
              var index = _ref.index, value17 = _ref.target;
              return _this.encodePickingColor(object && object.__source ? object.__source.index : index, value17);
            }
          }
        });
        this.setState({
          pathTesselator: new PathTesselator({
            fp64: this.use64bitPositions()
          })
        });
        if (this.props.getDashArray && !this.props.extensions.length) {
          log_default.removed("getDashArray", "PathStyleExtension")();
        }
      }
    }, {
      key: "updateState",
      value: function updateState(_ref2) {
        var oldProps = _ref2.oldProps, props = _ref2.props, changeFlags = _ref2.changeFlags;
        _get(_getPrototypeOf(PathLayer2.prototype), "updateState", this).call(this, {
          props,
          oldProps,
          changeFlags
        });
        var attributeManager = this.getAttributeManager();
        var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
        if (geometryChanged) {
          var pathTesselator = this.state.pathTesselator;
          var buffers = props.data.attributes || {};
          pathTesselator.updateGeometry({
            data: props.data,
            geometryBuffer: buffers.getPath,
            buffers,
            normalize: !props._pathType,
            loop: props._pathType === "loop",
            getGeometry: props.getPath,
            positionFormat: props.positionFormat,
            wrapLongitude: props.wrapLongitude,
            resolution: this.context.viewport.resolution,
            dataChanged: changeFlags.dataChanged
          });
          this.setState({
            numInstances: pathTesselator.instanceCount,
            startIndices: pathTesselator.vertexStarts
          });
          if (!changeFlags.dataChanged) {
            attributeManager.invalidateAll();
          }
        }
        if (changeFlags.extensionsChanged) {
          var gl = this.context.gl;
          if (this.state.model) {
            this.state.model["delete"]();
          }
          this.setState({
            model: this._getModel(gl)
          });
          attributeManager.invalidateAll();
        }
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(params) {
        var info = _get(_getPrototypeOf(PathLayer2.prototype), "getPickingInfo", this).call(this, params);
        var index = info.index;
        var data = this.props.data;
        if (data[0] && data[0].__source) {
          info.object = data.find(function(d) {
            return d.__source.index === index;
          });
        }
        return info;
      }
    }, {
      key: "disablePickingIndex",
      value: function disablePickingIndex(objectIndex) {
        var data = this.props.data;
        if (data[0] && data[0].__source) {
          for (var i = 0; i < data.length; i++) {
            if (data[i].__source.index === objectIndex) {
              this._disablePickingIndex(i);
            }
          }
        } else {
          this._disablePickingIndex(objectIndex);
        }
      }
    }, {
      key: "draw",
      value: function draw(_ref3) {
        var uniforms = _ref3.uniforms;
        var viewport3 = this.context.viewport;
        var _this$props = this.props, rounded = _this$props.rounded, billboard = _this$props.billboard, miterLimit = _this$props.miterLimit, widthUnits = _this$props.widthUnits, widthScale = _this$props.widthScale, widthMinPixels = _this$props.widthMinPixels, widthMaxPixels = _this$props.widthMaxPixels;
        var widthMultiplier = widthUnits === "pixels" ? viewport3.metersPerPixel : 1;
        this.state.model.setUniforms(Object.assign({}, uniforms, {
          jointType: Number(rounded),
          billboard,
          widthScale: widthScale * widthMultiplier,
          miterLimit,
          widthMinPixels,
          widthMaxPixels
        })).draw();
      }
    }, {
      key: "_getModel",
      value: function _getModel(gl) {
        var SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
        var SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
        return new Model(gl, Object.assign({}, this.getShaders(), {
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 4,
            attributes: {
              indices: new Uint16Array(SEGMENT_INDICES),
              positions: {
                value: new Float32Array(SEGMENT_POSITIONS),
                size: 2
              }
            }
          }),
          isInstanced: true
        }));
      }
    }, {
      key: "calculatePositions",
      value: function calculatePositions(attribute) {
        var pathTesselator = this.state.pathTesselator;
        attribute.startIndices = pathTesselator.vertexStarts;
        attribute.value = pathTesselator.get("positions");
      }
    }, {
      key: "calculateSegmentTypes",
      value: function calculateSegmentTypes(attribute) {
        var pathTesselator = this.state.pathTesselator;
        attribute.startIndices = pathTesselator.vertexStarts;
        attribute.value = pathTesselator.get("segmentTypes");
      }
    }, {
      key: "wrapLongitude",
      get: function get2() {
        return false;
      }
    }]);
    return PathLayer2;
  }(Layer);
  PathLayer.layerName = "PathLayer";
  PathLayer.defaultProps = defaultProps7;

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js
  var import_earcut = __toModule(require_earcut());
  function _createForOfIteratorHelper49(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray50(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray50(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray50(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray50(o, minLen);
  }
  function _arrayLikeToArray50(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
  var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
  var windingOptions = {
    isClosed: true
  };
  function validate9(polygon) {
    polygon = polygon && polygon.positions || polygon;
    if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
      throw new Error("invalid polygon");
    }
  }
  function isSimple(polygon) {
    return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
  }
  function isNestedRingClosed(simplePolygon) {
    var p0 = simplePolygon[0];
    var p1 = simplePolygon[simplePolygon.length - 1];
    return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
  }
  function isFlatRingClosed(positions, size, startIndex, endIndex) {
    for (var i = 0; i < size; i++) {
      if (positions[startIndex + i] !== positions[endIndex - size + i]) {
        return false;
      }
    }
    return true;
  }
  function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
    var targetIndex = targetStartIndex;
    var len2 = simplePolygon.length;
    for (var i = 0; i < len2; i++) {
      for (var j = 0; j < size; j++) {
        target[targetIndex++] = simplePolygon[i][j] || 0;
      }
    }
    if (!isNestedRingClosed(simplePolygon)) {
      for (var _j = 0; _j < size; _j++) {
        target[targetIndex++] = simplePolygon[0][_j] || 0;
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target, windingDirection, windingOptions);
    return targetIndex;
  }
  function copyFlatRing(target, targetStartIndex, positions, size) {
    var srcStartIndex = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var srcEndIndex = arguments.length > 5 ? arguments[5] : void 0;
    var windingDirection = arguments.length > 6 ? arguments[6] : void 0;
    srcEndIndex = srcEndIndex || positions.length;
    var srcLength = srcEndIndex - srcStartIndex;
    if (srcLength <= 0) {
      return targetStartIndex;
    }
    var targetIndex = targetStartIndex;
    for (var i = 0; i < srcLength; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
    if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
      for (var _i = 0; _i < size; _i++) {
        target[targetIndex++] = positions[srcStartIndex + _i];
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target, windingDirection, windingOptions);
    return targetIndex;
  }
  function normalize4(polygon, positionSize) {
    validate9(polygon);
    var positions = [];
    var holeIndices = [];
    if (polygon.positions) {
      var _polygon = polygon, srcPositions = _polygon.positions, srcHoleIndices = _polygon.holeIndices;
      if (srcHoleIndices) {
        var targetIndex = 0;
        for (var i = 0; i <= srcHoleIndices.length; i++) {
          targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
          holeIndices.push(targetIndex);
        }
        holeIndices.pop();
        return {
          positions,
          holeIndices
        };
      }
      polygon = srcPositions;
    }
    if (Number.isFinite(polygon[0])) {
      copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
      return positions;
    }
    if (!isSimple(polygon)) {
      var _targetIndex = 0;
      var _iterator = _createForOfIteratorHelper49(polygon.entries()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), polygonIndex = _step$value[0], simplePolygon = _step$value[1];
          _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
          holeIndices.push(_targetIndex);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
    return positions;
  }
  function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {
    var holeIndices = null;
    if (normalizedPolygon.holeIndices) {
      holeIndices = normalizedPolygon.holeIndices.map(function(positionIndex) {
        return positionIndex / positionSize;
      });
    }
    var positions = normalizedPolygon.positions || normalizedPolygon;
    if (preproject) {
      var n = positions.length;
      positions = positions.slice();
      var p = [];
      for (var i = 0; i < n; i += positionSize) {
        p[0] = positions[i];
        p[1] = positions[i + 1];
        var xy = preproject(p);
        positions[i] = xy[0];
        positions[i + 1] = xy[1];
      }
    }
    return (0, import_earcut.default)(positions, holeIndices, positionSize);
  }

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js
  function _createForOfIteratorHelper50(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray51(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray51(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray51(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray51(o, minLen);
  }
  function _arrayLikeToArray51(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys31(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread31(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys31(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys31(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper43(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct44();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct44() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var PolygonTesselator = function(_Tesselator) {
    _inherits(PolygonTesselator2, _Tesselator);
    var _super = _createSuper43(PolygonTesselator2);
    function PolygonTesselator2(opts) {
      _classCallCheck(this, PolygonTesselator2);
      var fp642 = opts.fp64, _opts$IndexType = opts.IndexType, IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;
      return _super.call(this, _objectSpread31(_objectSpread31({}, opts), {}, {
        attributes: {
          positions: {
            size: 3,
            type: fp642 ? Float64Array : Float32Array
          },
          vertexValid: {
            type: Uint8ClampedArray,
            size: 1
          },
          indices: {
            type: IndexType,
            size: 1
          }
        }
      }));
    }
    _createClass(PolygonTesselator2, [{
      key: "get",
      value: function get2(attributeName) {
        var attributes = this.attributes;
        if (attributeName === "indices") {
          return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
        }
        return attributes[attributeName];
      }
    }, {
      key: "updateGeometry",
      value: function updateGeometry(opts) {
        _get(_getPrototypeOf(PolygonTesselator2.prototype), "updateGeometry", this).call(this, opts);
        var externalIndices = this.buffers.indices;
        if (externalIndices) {
          this.vertexCount = (externalIndices.value || externalIndices).length;
        }
      }
    }, {
      key: "normalizeGeometry",
      value: function normalizeGeometry(polygon) {
        if (this.normalize) {
          polygon = normalize4(polygon, this.positionSize);
          if (this.opts.resolution) {
            return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {
              size: this.positionSize,
              gridResolution: this.opts.resolution,
              edgeTypes: true
            });
          }
          if (this.opts.wrapLongitude) {
            return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {
              size: this.positionSize,
              maxLatitude: 86,
              edgeTypes: true
            });
          }
        }
        return polygon;
      }
    }, {
      key: "getGeometrySize",
      value: function getGeometrySize(polygon) {
        if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {
          var size = 0;
          var _iterator = _createForOfIteratorHelper50(polygon), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var subPolygon = _step.value;
              size += this.getGeometrySize(subPolygon);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return size;
        }
        return (polygon.positions || polygon).length / this.positionSize;
      }
    }, {
      key: "getGeometryFromBuffer",
      value: function getGeometryFromBuffer(buffer) {
        if (this.normalize || !this.buffers.indices) {
          return _get(_getPrototypeOf(PolygonTesselator2.prototype), "getGeometryFromBuffer", this).call(this, buffer);
        }
        return function() {
          return null;
        };
      }
    }, {
      key: "updateGeometryAttributes",
      value: function updateGeometryAttributes(polygon, context) {
        if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {
          var _iterator2 = _createForOfIteratorHelper50(polygon), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var subPolygon = _step2.value;
              var geometrySize = this.getGeometrySize(subPolygon);
              context.geometrySize = geometrySize;
              this.updateGeometryAttributes(subPolygon, context);
              context.vertexStart += geometrySize;
              context.indexStart = this.indexStarts[context.geometryIndex + 1];
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else {
          this._updateIndices(polygon, context);
          this._updatePositions(polygon, context);
          this._updateVertexValid(polygon, context);
        }
      }
    }, {
      key: "_updateIndices",
      value: function _updateIndices(polygon, _ref) {
        var geometryIndex = _ref.geometryIndex, offset = _ref.vertexStart, indexStart = _ref.indexStart;
        var attributes = this.attributes, indexStarts = this.indexStarts, typedArrayManager = this.typedArrayManager;
        var target = attributes.indices;
        if (!target) {
          return;
        }
        var i = indexStart;
        var indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);
        target = typedArrayManager.allocate(target, indexStart + indices.length, {
          copy: true
        });
        for (var j = 0; j < indices.length; j++) {
          target[i++] = indices[j] + offset;
        }
        indexStarts[geometryIndex + 1] = indexStart + indices.length;
        attributes.indices = target;
      }
    }, {
      key: "_updatePositions",
      value: function _updatePositions(polygon, _ref2) {
        var vertexStart = _ref2.vertexStart, geometrySize = _ref2.geometrySize;
        var positions = this.attributes.positions, positionSize = this.positionSize;
        if (!positions) {
          return;
        }
        var polygonPositions = polygon.positions || polygon;
        for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {
          var x = polygonPositions[j * positionSize];
          var y = polygonPositions[j * positionSize + 1];
          var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
        }
      }
    }, {
      key: "_updateVertexValid",
      value: function _updateVertexValid(polygon, _ref3) {
        var vertexStart = _ref3.vertexStart, geometrySize = _ref3.geometrySize;
        var vertexValid = this.attributes.vertexValid, positionSize = this.positionSize;
        var holeIndices = polygon && polygon.holeIndices;
        if (polygon && polygon.edgeTypes) {
          vertexValid.set(polygon.edgeTypes, vertexStart);
        } else {
          vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
        }
        if (holeIndices) {
          for (var j = 0; j < holeIndices.length; j++) {
            vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
          }
        }
        vertexValid[vertexStart + geometrySize - 1] = 0;
      }
    }]);
    return PolygonTesselator2;
  }(Tesselator);

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
  var solid_polygon_layer_vertex_main_glsl_default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
  var solid_polygon_layer_vertex_top_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
  var solid_polygon_layer_vertex_side_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
  var solid_polygon_layer_fragment_glsl_default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js
  function _createSuper44(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct45();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct45() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_COLOR4 = [0, 0, 0, 255];
  var defaultProps8 = {
    filled: true,
    extruded: false,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    getPolygon: {
      type: "accessor",
      value: function value8(f) {
        return f.polygon;
      }
    },
    getElevation: {
      type: "accessor",
      value: 1e3
    },
    getFillColor: {
      type: "accessor",
      value: DEFAULT_COLOR4
    },
    getLineColor: {
      type: "accessor",
      value: DEFAULT_COLOR4
    },
    material: true
  };
  var ATTRIBUTE_TRANSITION2 = {
    enter: function enter2(value17, chunk) {
      return chunk.length ? chunk.subarray(chunk.length - value17.length) : value17;
    }
  };
  var SolidPolygonLayer = function(_Layer) {
    _inherits(SolidPolygonLayer2, _Layer);
    var _super = _createSuper44(SolidPolygonLayer2);
    function SolidPolygonLayer2() {
      _classCallCheck(this, SolidPolygonLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(SolidPolygonLayer2, [{
      key: "getShaders",
      value: function getShaders(type) {
        return _get(_getPrototypeOf(SolidPolygonLayer2.prototype), "getShaders", this).call(this, {
          vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
          fs: solid_polygon_layer_fragment_glsl_default,
          defines: {
            RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
          },
          modules: [project32_default, gouraudLighting, picking_default]
        });
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        var _this = this;
        var _this$context = this.context, gl = _this$context.gl, viewport3 = _this$context.viewport;
        var coordinateSystem = this.props.coordinateSystem;
        if (viewport3.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
          coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
        }
        this.setState({
          numInstances: 0,
          polygonTesselator: new PolygonTesselator({
            preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport3.projectFlat,
            fp64: this.use64bitPositions(),
            IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
          })
        });
        var attributeManager = this.getAttributeManager();
        var noAlloc = true;
        attributeManager.remove(["instancePickingColors"]);
        attributeManager.add({
          indices: {
            size: 1,
            isIndexed: true,
            update: this.calculateIndices,
            noAlloc
          },
          positions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getPolygon",
            update: this.calculatePositions,
            noAlloc,
            shaderAttributes: {
              positions: {
                vertexOffset: 0,
                divisor: 0
              },
              instancePositions: {
                vertexOffset: 0,
                divisor: 1
              },
              nextPositions: {
                vertexOffset: 1,
                divisor: 1
              }
            }
          },
          vertexValid: {
            size: 1,
            divisor: 1,
            type: 5121,
            update: this.calculateVertexValid,
            noAlloc
          },
          elevations: {
            size: 1,
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getElevation",
            shaderAttributes: {
              elevations: {
                divisor: 0
              },
              instanceElevations: {
                divisor: 1
              }
            }
          },
          fillColors: {
            alias: "colors",
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getFillColor",
            defaultValue: DEFAULT_COLOR4,
            shaderAttributes: {
              fillColors: {
                divisor: 0
              },
              instanceFillColors: {
                divisor: 1
              }
            }
          },
          lineColors: {
            alias: "colors",
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getLineColor",
            defaultValue: DEFAULT_COLOR4,
            shaderAttributes: {
              lineColors: {
                divisor: 0
              },
              instanceLineColors: {
                divisor: 1
              }
            }
          },
          pickingColors: {
            size: 3,
            type: 5121,
            accessor: function accessor(object, _ref) {
              var index = _ref.index, value17 = _ref.target;
              return _this.encodePickingColor(object && object.__source ? object.__source.index : index, value17);
            },
            shaderAttributes: {
              pickingColors: {
                divisor: 0
              },
              instancePickingColors: {
                divisor: 1
              }
            }
          }
        });
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(params) {
        var info = _get(_getPrototypeOf(SolidPolygonLayer2.prototype), "getPickingInfo", this).call(this, params);
        var index = info.index;
        var data = this.props.data;
        if (data[0] && data[0].__source) {
          info.object = data.find(function(d) {
            return d.__source.index === index;
          });
        }
        return info;
      }
    }, {
      key: "disablePickingIndex",
      value: function disablePickingIndex(objectIndex) {
        var data = this.props.data;
        if (data[0] && data[0].__source) {
          for (var i = 0; i < data.length; i++) {
            if (data[i].__source.index === objectIndex) {
              this._disablePickingIndex(i);
            }
          }
        } else {
          this._disablePickingIndex(objectIndex);
        }
      }
    }, {
      key: "draw",
      value: function draw(_ref2) {
        var uniforms = _ref2.uniforms;
        var _this$props = this.props, extruded = _this$props.extruded, filled = _this$props.filled, wireframe = _this$props.wireframe, elevationScale = _this$props.elevationScale;
        var _this$state = this.state, topModel = _this$state.topModel, sideModel = _this$state.sideModel, polygonTesselator = _this$state.polygonTesselator;
        var renderUniforms = Object.assign({}, uniforms, {
          extruded: Boolean(extruded),
          elevationScale
        });
        if (sideModel) {
          sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
          sideModel.setUniforms(renderUniforms);
          if (wireframe) {
            sideModel.setDrawMode(3);
            sideModel.setUniforms({
              isWireframe: true
            }).draw();
          }
          if (filled) {
            sideModel.setDrawMode(6);
            sideModel.setUniforms({
              isWireframe: false
            }).draw();
          }
        }
        if (topModel) {
          topModel.setVertexCount(polygonTesselator.vertexCount);
          topModel.setUniforms(renderUniforms).draw();
        }
      }
    }, {
      key: "updateState",
      value: function updateState(updateParams) {
        _get(_getPrototypeOf(SolidPolygonLayer2.prototype), "updateState", this).call(this, updateParams);
        this.updateGeometry(updateParams);
        var props = updateParams.props, oldProps = updateParams.oldProps, changeFlags = updateParams.changeFlags;
        var attributeManager = this.getAttributeManager();
        var regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
        if (regenerateModels) {
          if (this.state.models) {
            this.state.models.forEach(function(model) {
              return model["delete"]();
            });
          }
          this.setState(this._getModels(this.context.gl));
          attributeManager.invalidateAll();
        }
      }
    }, {
      key: "updateGeometry",
      value: function updateGeometry(_ref3) {
        var props = _ref3.props, oldProps = _ref3.oldProps, changeFlags = _ref3.changeFlags;
        var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
        if (geometryConfigChanged) {
          var polygonTesselator = this.state.polygonTesselator;
          var buffers = props.data.attributes || {};
          polygonTesselator.updateGeometry({
            data: props.data,
            normalize: props._normalize,
            geometryBuffer: buffers.getPolygon,
            buffers,
            getGeometry: props.getPolygon,
            positionFormat: props.positionFormat,
            wrapLongitude: props.wrapLongitude,
            resolution: this.context.viewport.resolution,
            fp64: this.use64bitPositions(),
            dataChanged: changeFlags.dataChanged
          });
          this.setState({
            numInstances: polygonTesselator.instanceCount,
            startIndices: polygonTesselator.vertexStarts
          });
          if (!changeFlags.dataChanged) {
            this.getAttributeManager().invalidateAll();
          }
        }
      }
    }, {
      key: "_getModels",
      value: function _getModels(gl) {
        var _this$props2 = this.props, id = _this$props2.id, filled = _this$props2.filled, extruded = _this$props2.extruded;
        var topModel;
        var sideModel;
        if (filled) {
          var shaders = this.getShaders("top");
          shaders.defines.NON_INSTANCED_MODEL = 1;
          topModel = new Model(gl, Object.assign({}, shaders, {
            id: "".concat(id, "-top"),
            drawMode: 4,
            attributes: {
              vertexPositions: new Float32Array([0, 1])
            },
            uniforms: {
              isWireframe: false,
              isSideVertex: false
            },
            vertexCount: 0,
            isIndexed: true
          }));
        }
        if (extruded) {
          sideModel = new Model(gl, Object.assign({}, this.getShaders("side"), {
            id: "".concat(id, "-side"),
            geometry: new Geometry({
              drawMode: 1,
              vertexCount: 4,
              attributes: {
                vertexPositions: {
                  size: 2,
                  value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
                }
              }
            }),
            instanceCount: 0,
            isInstanced: 1
          }));
          sideModel.userData.excludeAttributes = {
            indices: true
          };
        }
        return {
          models: [sideModel, topModel].filter(Boolean),
          topModel,
          sideModel
        };
      }
    }, {
      key: "calculateIndices",
      value: function calculateIndices(attribute) {
        var polygonTesselator = this.state.polygonTesselator;
        attribute.startIndices = polygonTesselator.indexStarts;
        attribute.value = polygonTesselator.get("indices");
      }
    }, {
      key: "calculatePositions",
      value: function calculatePositions(attribute) {
        var polygonTesselator = this.state.polygonTesselator;
        attribute.startIndices = polygonTesselator.vertexStarts;
        attribute.value = polygonTesselator.get("positions");
      }
    }, {
      key: "calculateVertexValid",
      value: function calculateVertexValid(attribute) {
        attribute.value = this.state.polygonTesselator.get("vertexValid");
      }
    }, {
      key: "wrapLongitude",
      get: function get2() {
        return false;
      }
    }]);
    return SolidPolygonLayer2;
  }(Layer);
  SolidPolygonLayer.layerName = "SolidPolygonLayer";
  SolidPolygonLayer.defaultProps = defaultProps8;

  // node_modules/@deck.gl/layers/dist/esm/utils.js
  function replaceInRange(_ref) {
    var data = _ref.data, getIndex = _ref.getIndex, dataRange = _ref.dataRange, replace = _ref.replace;
    var _dataRange$startRow = dataRange.startRow, startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow, _dataRange$endRow = dataRange.endRow, endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
    var count3 = data.length;
    var replaceStart = count3;
    var replaceEnd = count3;
    for (var i = 0; i < count3; i++) {
      var row = getIndex(data[i]);
      if (replaceStart > i && row >= startRow) {
        replaceStart = i;
      }
      if (row >= endRow) {
        replaceEnd = i;
        break;
      }
    }
    var index = replaceStart;
    var dataLengthChanged = replaceEnd - replaceStart !== replace.length;
    var endChunk = dataLengthChanged && data.slice(replaceEnd);
    for (var _i = 0; _i < replace.length; _i++) {
      data[index++] = replace[_i];
    }
    if (dataLengthChanged) {
      for (var _i2 = 0; _i2 < endChunk.length; _i2++) {
        data[index++] = endChunk[_i2];
      }
      data.length = index;
    }
    return {
      startRow: replaceStart,
      endRow: replaceStart + replace.length
    };
  }

  // node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js
  function ownKeys32(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread32(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys32(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys32(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function binaryToFeatureForAccesor(data, index) {
    if (!data) {
      return null;
    }
    var featureIndex = "startIndices" in data ? data.startIndices[index] : index;
    var geometryIndex = data.featureIds.value[featureIndex];
    if (featureIndex !== -1) {
      return getPropertiesForIndex(data, geometryIndex, featureIndex);
    }
    return null;
  }
  function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
    var feature = {
      properties: _objectSpread32({}, data.properties[propertiesIndex])
    };
    for (var prop in data.numericProps) {
      feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
    }
    return feature;
  }
  function calculatePickingColors(geojsonBinary, encodePickingColor) {
    var pickingColors = {
      points: null,
      lines: null,
      polygons: null
    };
    for (var key in pickingColors) {
      var featureIds = geojsonBinary[key].featureIds.value;
      pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
      var pickingColor = [];
      for (var i = 0; i < featureIds.length; i++) {
        encodePickingColor(featureIds[i], pickingColor);
        pickingColors[key][i * 3 + 0] = pickingColor[0];
        pickingColors[key][i * 3 + 1] = pickingColor[1];
        pickingColors[key][i * 3 + 2] = pickingColor[2];
      }
    }
    return pickingColors;
  }

  // node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js
  function getGeojsonFeatures(geojson) {
    if (Array.isArray(geojson)) {
      return geojson;
    }
    log_default.assert(geojson.type, "GeoJSON does not have type");
    switch (geojson.type) {
      case "Feature":
        return [geojson];
      case "FeatureCollection":
        log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
        return geojson.features;
      default:
        return [{
          geometry: geojson
        }];
    }
  }
  function separateGeojsonFeatures(features, wrapFeature) {
    var dataRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var separated = {
      pointFeatures: [],
      lineFeatures: [],
      polygonFeatures: [],
      polygonOutlineFeatures: []
    };
    var _dataRange$startRow = dataRange.startRow, startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow, _dataRange$endRow = dataRange.endRow, endRow = _dataRange$endRow === void 0 ? features.length : _dataRange$endRow;
    for (var featureIndex = startRow; featureIndex < endRow; featureIndex++) {
      var feature = features[featureIndex];
      log_default.assert(feature && feature.geometry, "GeoJSON does not have geometry");
      var geometry = feature.geometry;
      if (geometry.type === "GeometryCollection") {
        log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
        var geometries = geometry.geometries;
        for (var i = 0; i < geometries.length; i++) {
          var subGeometry = geometries[i];
          separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
        }
      } else {
        separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
      }
    }
    return separated;
  }
  function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
    var type = geometry.type, coordinates = geometry.coordinates;
    var pointFeatures = separated.pointFeatures, lineFeatures = separated.lineFeatures, polygonFeatures = separated.polygonFeatures, polygonOutlineFeatures = separated.polygonOutlineFeatures;
    if (!validateGeometry(type, coordinates)) {
      log_default.warn("".concat(type, " coordinates are malformed"))();
      return;
    }
    switch (type) {
      case "Point":
        pointFeatures.push(wrapFeature({
          geometry
        }, sourceFeature, sourceFeatureIndex));
        break;
      case "MultiPoint":
        coordinates.forEach(function(point) {
          pointFeatures.push(wrapFeature({
            geometry: {
              type: "Point",
              coordinates: point
            }
          }, sourceFeature, sourceFeatureIndex));
        });
        break;
      case "LineString":
        lineFeatures.push(wrapFeature({
          geometry
        }, sourceFeature, sourceFeatureIndex));
        break;
      case "MultiLineString":
        coordinates.forEach(function(path) {
          lineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
        break;
      case "Polygon":
        polygonFeatures.push(wrapFeature({
          geometry
        }, sourceFeature, sourceFeatureIndex));
        coordinates.forEach(function(path) {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
        break;
      case "MultiPolygon":
        coordinates.forEach(function(polygon) {
          polygonFeatures.push(wrapFeature({
            geometry: {
              type: "Polygon",
              coordinates: polygon
            }
          }, sourceFeature, sourceFeatureIndex));
          polygon.forEach(function(path) {
            polygonOutlineFeatures.push(wrapFeature({
              geometry: {
                type: "LineString",
                coordinates: path
              }
            }, sourceFeature, sourceFeatureIndex));
          });
        });
        break;
      default:
    }
  }
  var COORDINATE_NEST_LEVEL = {
    Point: 1,
    MultiPoint: 2,
    LineString: 2,
    MultiLineString: 3,
    Polygon: 3,
    MultiPolygon: 4
  };
  function validateGeometry(type, coordinates) {
    var nestLevel = COORDINATE_NEST_LEVEL[type];
    log_default.assert(nestLevel, "Unknown GeoJSON type ".concat(type));
    while (coordinates && --nestLevel > 0) {
      coordinates = coordinates[0];
    }
    return coordinates && Number.isFinite(coordinates[0]);
  }

  // node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js
  function createEmptyLayerProps() {
    return {
      points: {},
      lines: {},
      polygons: {},
      polygonsOutline: {}
    };
  }
  function getCoordinates(f) {
    return f.geometry.coordinates;
  }
  function createLayerPropsFromFeatures(features, featuresDiff) {
    var layerProps = createEmptyLayerProps();
    var pointFeatures = features.pointFeatures, lineFeatures = features.lineFeatures, polygonFeatures = features.polygonFeatures, polygonOutlineFeatures = features.polygonOutlineFeatures;
    layerProps.points.data = pointFeatures;
    layerProps.points._dataDiff = featuresDiff.pointFeatures && function() {
      return featuresDiff.pointFeatures;
    };
    layerProps.points.getPosition = getCoordinates;
    layerProps.lines.data = lineFeatures;
    layerProps.lines._dataDiff = featuresDiff.lineFeatures && function() {
      return featuresDiff.lineFeatures;
    };
    layerProps.lines.getPath = getCoordinates;
    layerProps.polygons.data = polygonFeatures;
    layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && function() {
      return featuresDiff.polygonFeatures;
    };
    layerProps.polygons.getPolygon = getCoordinates;
    layerProps.polygonsOutline.data = polygonOutlineFeatures;
    layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && function() {
      return featuresDiff.polygonOutlineFeatures;
    };
    layerProps.polygonsOutline.getPath = getCoordinates;
    return layerProps;
  }
  function createLayerPropsFromBinary(geojsonBinary, uniqueIdProperty, encodePickingColor) {
    var layerProps = createEmptyLayerProps();
    var points = geojsonBinary.points, lines = geojsonBinary.lines, polygons = geojsonBinary.polygons;
    var customPickingColors = calculatePickingColors(geojsonBinary, uniqueIdProperty, encodePickingColor);
    layerProps.points.data = {
      length: points.positions.value.length / points.positions.size,
      attributes: {
        getPosition: points.positions,
        pickingColors: {
          size: 3,
          value: customPickingColors.points
        }
      },
      properties: points.properties,
      numericProps: points.numericProps,
      featureIds: points.featureIds
    };
    layerProps.lines.data = {
      length: lines.pathIndices.value.length - 1,
      startIndices: lines.pathIndices.value,
      attributes: {
        getPath: lines.positions,
        pickingColors: {
          size: 3,
          value: customPickingColors.lines
        }
      },
      properties: lines.properties,
      numericProps: lines.numericProps,
      featureIds: lines.featureIds
    };
    layerProps.lines._pathType = "open";
    layerProps.polygons.data = {
      length: polygons.primitivePolygonIndices.value.length,
      startIndices: polygons.primitivePolygonIndices.value,
      attributes: {
        getPolygon: polygons.positions,
        pickingColors: {
          size: 3,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygons._normalize = false;
    layerProps.polygonsOutline.data = {
      length: polygons.primitivePolygonIndices.value.length,
      startIndices: polygons.primitivePolygonIndices.value,
      attributes: {
        getPath: polygons.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygonsOutline._pathType = "open";
    return layerProps;
  }

  // node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js
  function ownKeys33(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread33(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys33(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys33(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper51(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray52(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray52(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray52(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray52(o, minLen);
  }
  function _arrayLikeToArray52(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper45(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct46();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct46() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var defaultLineColor = [0, 0, 0, 255];
  var defaultFillColor = [0, 0, 0, 255];
  var defaultProps9 = {
    stroked: true,
    filled: true,
    extruded: false,
    wireframe: false,
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    lineJointRounded: false,
    lineMiterLimit: 4,
    elevationScale: 1,
    pointRadiusUnits: "meters",
    pointRadiusScale: 1,
    pointRadiusMinPixels: 0,
    pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,
    getLineColor: {
      type: "accessor",
      value: defaultLineColor
    },
    getFillColor: {
      type: "accessor",
      value: defaultFillColor
    },
    getRadius: {
      type: "accessor",
      value: 1
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    getElevation: {
      type: "accessor",
      value: 1e3
    },
    material: true
  };
  var GeoJsonLayer = function(_CompositeLayer) {
    _inherits(GeoJsonLayer2, _CompositeLayer);
    var _super = _createSuper45(GeoJsonLayer2);
    function GeoJsonLayer2() {
      _classCallCheck(this, GeoJsonLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(GeoJsonLayer2, [{
      key: "initializeState",
      value: function initializeState() {
        this.state = {
          layerProps: {},
          features: {}
        };
        if (this.props.getLineDashArray) {
          log_default.removed("getLineDashArray", "PathStyleExtension")();
        }
      }
    }, {
      key: "updateState",
      value: function updateState(_ref) {
        var props = _ref.props, changeFlags = _ref.changeFlags;
        if (!changeFlags.dataChanged) {
          return;
        }
        var data = this.props.data;
        var binary = data && "points" in data && "polygons" in data && "lines" in data;
        this.setState({
          binary
        });
        if (binary) {
          this._updateStateBinary({
            props,
            changeFlags
          });
        } else {
          this._updateStateJSON({
            props,
            changeFlags
          });
        }
      }
    }, {
      key: "_updateStateBinary",
      value: function _updateStateBinary(_ref2) {
        var props = _ref2.props, changeFlags = _ref2.changeFlags;
        var layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
        this.setState({
          layerProps
        });
      }
    }, {
      key: "_updateStateJSON",
      value: function _updateStateJSON(_ref3) {
        var props = _ref3.props, changeFlags = _ref3.changeFlags;
        var features = getGeojsonFeatures(props.data);
        var wrapFeature = this.getSubLayerRow.bind(this);
        var newFeatures = {};
        var featuresDiff = {};
        if (Array.isArray(changeFlags.dataChanged)) {
          var oldFeatures = this.state.features;
          for (var key in oldFeatures) {
            newFeatures[key] = oldFeatures[key].slice();
            featuresDiff[key] = [];
          }
          var _iterator = _createForOfIteratorHelper51(changeFlags.dataChanged), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var dataRange = _step.value;
              var partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
              for (var _key in oldFeatures) {
                featuresDiff[_key].push(replaceInRange({
                  data: newFeatures[_key],
                  getIndex: function getIndex(f) {
                    return f.__source.index;
                  },
                  dataRange,
                  replace: partialFeatures[_key]
                }));
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          newFeatures = separateGeojsonFeatures(features, wrapFeature);
        }
        var layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
        this.setState({
          features: newFeatures,
          featuresDiff,
          layerProps
        });
      }
    }, {
      key: "renderLayers",
      value: function renderLayers() {
        var _this$props = this.props, stroked = _this$props.stroked, filled = _this$props.filled, extruded = _this$props.extruded, wireframe = _this$props.wireframe, material = _this$props.material, transitions = _this$props.transitions;
        var _this$props2 = this.props, lineWidthUnits = _this$props2.lineWidthUnits, lineWidthScale = _this$props2.lineWidthScale, lineWidthMinPixels = _this$props2.lineWidthMinPixels, lineWidthMaxPixels = _this$props2.lineWidthMaxPixels, lineJointRounded = _this$props2.lineJointRounded, lineMiterLimit = _this$props2.lineMiterLimit, pointRadiusUnits = _this$props2.pointRadiusUnits, pointRadiusScale = _this$props2.pointRadiusScale, pointRadiusMinPixels = _this$props2.pointRadiusMinPixels, pointRadiusMaxPixels = _this$props2.pointRadiusMaxPixels, elevationScale = _this$props2.elevationScale, lineDashJustified = _this$props2.lineDashJustified;
        var _this$props3 = this.props, getLineColor = _this$props3.getLineColor, getFillColor = _this$props3.getFillColor, getRadius = _this$props3.getRadius, getLineWidth = _this$props3.getLineWidth, getLineDashArray = _this$props3.getLineDashArray, getElevation = _this$props3.getElevation, updateTriggers = _this$props3.updateTriggers;
        var PolygonFillLayer = this.getSubLayerClass("polygons-fill", SolidPolygonLayer);
        var PolygonStrokeLayer = this.getSubLayerClass("polygons-stroke", PathLayer);
        var LineStringsLayer = this.getSubLayerClass("line-strings", PathLayer);
        var PointsLayer = this.getSubLayerClass("points", ScatterplotLayer);
        var layerProps = this.state.layerProps;
        var polygonFillLayer = this.shouldRenderSubLayer("polygons-fill", layerProps.polygons.data) && new PolygonFillLayer({
          extruded,
          elevationScale,
          filled,
          wireframe,
          material,
          getElevation: this.getSubLayerAccessor(getElevation),
          getFillColor: this.getSubLayerAccessor(getFillColor),
          getLineColor: this.getSubLayerAccessor(extruded && wireframe ? getLineColor : defaultLineColor),
          transitions: transitions && {
            getPolygon: transitions.geometry,
            getElevation: transitions.getElevation,
            getFillColor: transitions.getFillColor,
            getLineColor: transitions.getLineColor
          }
        }, this.getSubLayerProps({
          id: "polygons-fill",
          updateTriggers: {
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            lineColors: extruded && wireframe,
            getLineColor: updateTriggers.getLineColor
          }
        }), layerProps.polygons);
        var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("polygons-stroke", layerProps.polygonsOutline.data) && new PolygonStrokeLayer({
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          rounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,
          getColor: this.getSubLayerAccessor(getLineColor),
          getWidth: this.getSubLayerAccessor(getLineWidth),
          getDashArray: this.getSubLayerAccessor(getLineDashArray),
          transitions: transitions && {
            getPath: transitions.geometry,
            getColor: transitions.getLineColor,
            getWidth: transitions.getLineWidth
          }
        }, this.getSubLayerProps({
          id: "polygons-stroke",
          updateTriggers: {
            getColor: updateTriggers.getLineColor,
            getWidth: updateTriggers.getLineWidth,
            getDashArray: updateTriggers.getLineDashArray
          }
        }), layerProps.polygonsOutline);
        var pathLayer = this.shouldRenderSubLayer("line-strings", layerProps.lines.data) && new LineStringsLayer({
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          rounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,
          getColor: this.getSubLayerAccessor(getLineColor),
          getWidth: this.getSubLayerAccessor(getLineWidth),
          getDashArray: this.getSubLayerAccessor(getLineDashArray),
          transitions: transitions && {
            getPath: transitions.geometry,
            getColor: transitions.getLineColor,
            getWidth: transitions.getLineWidth
          }
        }, this.getSubLayerProps({
          id: "line-strings",
          updateTriggers: {
            getColor: updateTriggers.getLineColor,
            getWidth: updateTriggers.getLineWidth,
            getDashArray: updateTriggers.getLineDashArray
          }
        }), layerProps.lines);
        var pointLayer = this.shouldRenderSubLayer("points", layerProps.points.data) && new PointsLayer({
          stroked,
          filled,
          radiusUnits: pointRadiusUnits,
          radiusScale: pointRadiusScale,
          radiusMinPixels: pointRadiusMinPixels,
          radiusMaxPixels: pointRadiusMaxPixels,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          getFillColor: this.getSubLayerAccessor(getFillColor),
          getLineColor: this.getSubLayerAccessor(getLineColor),
          getRadius: this.getSubLayerAccessor(getRadius),
          getLineWidth: this.getSubLayerAccessor(getLineWidth),
          transitions: transitions && {
            getPosition: transitions.geometry,
            getFillColor: transitions.getFillColor,
            getLineColor: transitions.getLineColor,
            getRadius: transitions.getRadius,
            getLineWidth: transitions.getLineWidth
          }
        }, this.getSubLayerProps({
          id: "points",
          updateTriggers: {
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor,
            getRadius: updateTriggers.getRadius,
            getLineWidth: updateTriggers.getLineWidth
          }
        }), _objectSpread33(_objectSpread33({}, layerProps.points), {}, {
          highlightedObjectIndex: this._getHighlightedIndex(layerProps.points.data)
        }));
        return [!extruded && polygonFillLayer, polygonLineLayer, pathLayer, pointLayer, extruded && polygonFillLayer];
      }
    }, {
      key: "_getHighlightedIndex",
      value: function _getHighlightedIndex(data) {
        var highlightedObjectIndex = this.props.highlightedObjectIndex;
        var binary = this.state.binary;
        if (!binary) {
          return Number.isFinite(highlightedObjectIndex) ? data.findIndex(function(d) {
            return d.__source.index === highlightedObjectIndex;
          }) : null;
        }
        return highlightedObjectIndex;
      }
    }, {
      key: "getSubLayerAccessor",
      value: function getSubLayerAccessor(accessor) {
        var binary = this.state.binary;
        if (!binary || typeof accessor !== "function") {
          return _get(_getPrototypeOf(GeoJsonLayer2.prototype), "getSubLayerAccessor", this).call(this, accessor);
        }
        return function(object, info) {
          var data = info.data, index = info.index;
          var feature = binaryToFeatureForAccesor(data, index);
          return accessor(feature, info);
        };
      }
    }]);
    return GeoJsonLayer2;
  }(CompositeLayer);
  GeoJsonLayer.layerName = "GeoJsonLayer";
  GeoJsonLayer.defaultProps = defaultProps9;

  // node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
  var multi_icon_layer_fragment_glsl_default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float buffer;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform bool shouldDrawBackground;\nuniform vec3 backgroundColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    if (sdf) {\n      alpha = smoothstep(buffer - vGamma, buffer + vGamma, alpha);\n    }\n    float a = alpha * vColor.a;\n    \n    if (a < alphaCutoff) {\n      if (shouldDrawBackground) {\n        gl_FragColor = vec4(backgroundColor, vColor.a);\n      } else {\n        discard;\n      }\n    } else {\n      if (shouldDrawBackground) {\n        gl_FragColor = vec4(mix(backgroundColor, vColor.rgb, alpha), vColor.a * opacity);\n      } else {\n        gl_FragColor = vec4(vColor.rgb, a * opacity);\n      }\n      DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n    }\n  } else {\n    DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n  }\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js
  function _createSuper46(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct47();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct47() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_GAMMA = 0.2;
  var DEFAULT_BUFFER2 = 192 / 256;
  var EMPTY_ARRAY3 = [];
  var defaultProps10 = {
    backgroundColor: {
      type: "color",
      value: null,
      optional: true
    },
    getIconOffsets: {
      type: "accessor",
      value: function value9(x) {
        return x.offsets;
      }
    },
    alphaCutoff: 1e-3
  };
  var MultiIconLayer = function(_IconLayer) {
    _inherits(MultiIconLayer2, _IconLayer);
    var _super = _createSuper46(MultiIconLayer2);
    function MultiIconLayer2() {
      _classCallCheck(this, MultiIconLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(MultiIconLayer2, [{
      key: "getShaders",
      value: function getShaders() {
        return Object.assign({}, _get(_getPrototypeOf(MultiIconLayer2.prototype), "getShaders", this).call(this), {
          inject: {
            "vs:#decl": "\n  uniform float gamma;\n  varying float vGamma;\n",
            "vs:#main-end": "\n  vGamma = gamma / (sizeScale * iconSize.y);\n"
          },
          fs: multi_icon_layer_fragment_glsl_default
        });
      }
    }, {
      key: "initializeState",
      value: function initializeState() {
        var _this = this;
        _get(_getPrototypeOf(MultiIconLayer2.prototype), "initializeState", this).call(this);
        var attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instanceOffsets: {
            size: 2,
            accessor: "getIconOffsets"
          },
          instancePickingColors: {
            type: 5121,
            size: 3,
            accessor: function accessor(object, _ref) {
              var index = _ref.index, value17 = _ref.target;
              return _this.encodePickingColor(index, value17);
            }
          }
        });
      }
    }, {
      key: "updateState",
      value: function updateState(updateParams) {
        _get(_getPrototypeOf(MultiIconLayer2.prototype), "updateState", this).call(this, updateParams);
        var oldProps = updateParams.oldProps, props = updateParams.props;
        if (props.backgroundColor !== oldProps.backgroundColor) {
          var backgroundColor = Array.isArray(props.backgroundColor) ? props.backgroundColor.map(function(c) {
            return c / 255;
          }).slice(0, 3) : null;
          this.setState({
            backgroundColor
          });
        }
      }
    }, {
      key: "draw",
      value: function draw(_ref2) {
        var uniforms = _ref2.uniforms;
        var sdf = this.props.sdf;
        var backgroundColor = this.state.backgroundColor;
        var shouldDrawBackground = Array.isArray(backgroundColor);
        _get(_getPrototypeOf(MultiIconLayer2.prototype), "draw", this).call(this, {
          uniforms: Object.assign({}, uniforms, {
            buffer: DEFAULT_BUFFER2,
            gamma: DEFAULT_GAMMA,
            sdf: Boolean(sdf),
            backgroundColor: backgroundColor || [0, 0, 0],
            shouldDrawBackground
          })
        });
      }
    }, {
      key: "getInstanceOffset",
      value: function getInstanceOffset(icons) {
        var _this2 = this;
        return icons ? Array.from(icons).map(function(icon) {
          return _get(_getPrototypeOf(MultiIconLayer2.prototype), "getInstanceOffset", _this2).call(_this2, icon);
        }) : EMPTY_ARRAY3;
      }
    }, {
      key: "getInstanceColorMode",
      value: function getInstanceColorMode(icons) {
        return 1;
      }
    }, {
      key: "getInstanceIconFrame",
      value: function getInstanceIconFrame(icons) {
        var _this3 = this;
        return icons ? Array.from(icons).map(function(icon) {
          return _get(_getPrototypeOf(MultiIconLayer2.prototype), "getInstanceIconFrame", _this3).call(_this3, icon);
        }) : EMPTY_ARRAY3;
      }
    }]);
    return MultiIconLayer2;
  }(IconLayer);
  MultiIconLayer.layerName = "MultiIconLayer";
  MultiIconLayer.defaultProps = defaultProps10;

  // node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js
  var import_tiny_sdf = __toModule(require_tiny_sdf());

  // node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js
  function _createForOfIteratorHelper52(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray53(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray53(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray53(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray53(o, minLen);
  }
  function _arrayLikeToArray53(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var MISSING_CHAR_WIDTH = 32;
  var SINGLE_LINE = [];
  function nextPowOfTwo2(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function buildMapping2(_ref) {
    var characterSet = _ref.characterSet, getFontWidth = _ref.getFontWidth, fontHeight = _ref.fontHeight, buffer = _ref.buffer, maxCanvasWidth = _ref.maxCanvasWidth, _ref$mapping = _ref.mapping, mapping = _ref$mapping === void 0 ? {} : _ref$mapping, _ref$xOffset = _ref.xOffset, xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset, _ref$yOffset = _ref.yOffset, yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset;
    var row = 0;
    var x = xOffset;
    var i = 0;
    var _iterator = _createForOfIteratorHelper52(characterSet), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _char = _step.value;
        if (!mapping[_char]) {
          var width = getFontWidth(_char, i++);
          if (x + width + buffer * 2 > maxCanvasWidth) {
            x = 0;
            row++;
          }
          mapping[_char] = {
            x: x + buffer,
            y: yOffset + row * (fontHeight + buffer * 2) + buffer,
            width,
            height: fontHeight
          };
          x += width + buffer * 2;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var rowHeight = fontHeight + buffer * 2;
    return {
      mapping,
      xOffset: x,
      yOffset: yOffset + row * rowHeight,
      canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
    };
  }
  function getTextWidth(text, startIndex, endIndex, mapping) {
    var width = 0;
    for (var i = startIndex; i < endIndex; i++) {
      var character = text[i];
      var frameWidth = null;
      var frame = mapping && mapping[character];
      if (frame) {
        frameWidth = frame.width;
      }
      width += frameWidth;
    }
    return width;
  }
  function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
    var rowStartCharIndex = startIndex;
    var rowOffsetLeft = 0;
    for (var i = startIndex; i < endIndex; i++) {
      var textWidth = getTextWidth(text, i, i + 1, iconMapping);
      if (rowOffsetLeft + textWidth > maxWidth) {
        if (rowStartCharIndex < i) {
          target.push(i);
        }
        rowStartCharIndex = i;
        rowOffsetLeft = 0;
      }
      rowOffsetLeft += textWidth;
    }
    return rowOffsetLeft;
  }
  function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
    var rowStartCharIndex = startIndex;
    var groupStartCharIndex = startIndex;
    var groupEndCharIndex = startIndex;
    var rowOffsetLeft = 0;
    for (var i = startIndex; i < endIndex; i++) {
      if (text[i] === " ") {
        groupEndCharIndex = i + 1;
      } else if (text[i + 1] === " " || i + 1 === endIndex) {
        groupEndCharIndex = i + 1;
      }
      if (groupEndCharIndex > groupStartCharIndex) {
        var groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
        if (rowOffsetLeft + groupWidth > maxWidth) {
          if (rowStartCharIndex < groupStartCharIndex) {
            target.push(groupStartCharIndex);
            rowStartCharIndex = groupStartCharIndex;
            rowOffsetLeft = 0;
          }
          if (groupWidth > maxWidth) {
            groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
            rowStartCharIndex = target[target.length - 1];
          }
        }
        groupStartCharIndex = groupEndCharIndex;
        rowOffsetLeft += groupWidth;
      }
    }
    return rowOffsetLeft;
  }
  function autoWrapping(text, wordBreak, maxWidth, iconMapping) {
    var startIndex = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var endIndex = arguments.length > 5 ? arguments[5] : void 0;
    if (endIndex === void 0) {
      endIndex = text.length;
    }
    var result = [];
    if (wordBreak === "break-all") {
      breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
    } else {
      breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
    }
    return result;
  }
  function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
    var x = 0;
    var rowHeight = 0;
    for (var i = startIndex; i < endIndex; i++) {
      var character = line[i];
      var frame = iconMapping[character];
      if (frame) {
        if (!rowHeight) {
          rowHeight = frame.height;
        }
        leftOffsets[i] = x + frame.width / 2;
        x += frame.width;
      } else {
        log_default.warn("Missing character: ".concat(character, " (").concat(character.codePointAt(0), ")"))();
        leftOffsets[i] = x;
        x += MISSING_CHAR_WIDTH;
      }
    }
    rowSize[0] = x;
    rowSize[1] = rowHeight;
  }
  function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
    paragraph = Array.from(paragraph);
    var numCharacters = paragraph.length;
    var x = new Array(numCharacters);
    var y = new Array(numCharacters);
    var rowWidth = new Array(numCharacters);
    var autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
    var size = [0, 0];
    var rowSize = [];
    var rowOffsetTop = 0;
    var lineStartIndex = 0;
    var lineEndIndex = 0;
    for (var i = 0; i <= numCharacters; i++) {
      var _char2 = paragraph[i];
      if (_char2 === "\n" || i === numCharacters) {
        lineEndIndex = i;
      }
      if (lineEndIndex > lineStartIndex) {
        var rows = autoWrappingEnabled ? autoWrapping(paragraph, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
        for (var rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
          var rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
          var rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
          transformRow(paragraph, rowStart, rowEnd, iconMapping, x, rowSize);
          for (var j = rowStart; j < rowEnd; j++) {
            y[j] = rowOffsetTop + rowSize[1] / 2;
            rowWidth[j] = rowSize[0];
          }
          rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
          size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowSize[0]);
        }
        lineStartIndex = lineEndIndex;
      }
      if (_char2 === "\n") {
        x[lineStartIndex] = 0;
        y[lineStartIndex] = 0;
        rowWidth[lineStartIndex] = 0;
        lineStartIndex++;
      }
    }
    size[1] = rowOffsetTop;
    return {
      x,
      y,
      rowWidth,
      size
    };
  }
  function getTextFromBuffer(_ref2) {
    var value17 = _ref2.value, length4 = _ref2.length, stride = _ref2.stride, offset = _ref2.offset, startIndices = _ref2.startIndices;
    var bytesPerElement = value17.BYTES_PER_ELEMENT;
    var elementStride = stride ? stride / bytesPerElement : 1;
    var elementOffset = offset ? offset / bytesPerElement : 0;
    var characterCount = startIndices[length4] || Math.floor((value17.length - elementOffset - bytesPerElement) / elementStride) + 1;
    var texts = new Array(length4);
    var codes = value17;
    if (elementStride > 1 || elementOffset > 0) {
      codes = new value17.constructor(characterCount);
      for (var i = 0; i < characterCount; i++) {
        codes[i] = value17[i * elementStride + elementOffset];
      }
    }
    for (var index = 0; index < length4; index++) {
      var startIndex = startIndices[index];
      var endIndex = startIndices[index + 1] || characterCount;
      texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));
    }
    return {
      texts,
      characterCount
    };
  }

  // node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js
  var LRUCache = function() {
    function LRUCache2() {
      var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;
      _classCallCheck(this, LRUCache2);
      this.limit = limit;
      this.clear();
    }
    _createClass(LRUCache2, [{
      key: "clear",
      value: function clear2() {
        this._cache = {};
        this._order = [];
      }
    }, {
      key: "get",
      value: function get2(key) {
        var value17 = this._cache[key];
        if (value17) {
          this._deleteOrder(key);
          this._appendOrder(key);
        }
        return value17;
      }
    }, {
      key: "set",
      value: function set2(key, value17) {
        if (!this._cache[key]) {
          if (Object.keys(this._cache).length === this.limit) {
            this["delete"](this._order[0]);
          }
          this._cache[key] = value17;
          this._appendOrder(key);
        } else {
          this["delete"](key);
          this._cache[key] = value17;
          this._appendOrder(key);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        var value17 = this._cache[key];
        if (value17) {
          this._deleteCache(key);
          this._deleteOrder(key);
        }
      }
    }, {
      key: "_deleteCache",
      value: function _deleteCache(key) {
        delete this._cache[key];
      }
    }, {
      key: "_deleteOrder",
      value: function _deleteOrder(key) {
        var index = this._order.findIndex(function(o) {
          return o === key;
        });
        if (index >= 0) {
          this._order.splice(index, 1);
        }
      }
    }, {
      key: "_appendOrder",
      value: function _appendOrder(key) {
        this._order.push(key);
      }
    }]);
    return LRUCache2;
  }();

  // node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js
  function _createForOfIteratorHelper53(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray54(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray54(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray54(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray54(o, minLen);
  }
  function _arrayLikeToArray54(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function getDefaultCharacterSet() {
    var charSet = [];
    for (var i = 32; i < 128; i++) {
      charSet.push(String.fromCharCode(i));
    }
    return charSet;
  }
  var DEFAULT_CHAR_SET = getDefaultCharacterSet();
  var DEFAULT_FONT_FAMILY = "Monaco, monospace";
  var DEFAULT_FONT_WEIGHT = "normal";
  var DEFAULT_FONT_SIZE = 64;
  var DEFAULT_BUFFER3 = 2;
  var DEFAULT_CUTOFF = 0.25;
  var DEFAULT_RADIUS = 3;
  var MAX_CANVAS_WIDTH = 1024;
  var BASELINE_SCALE = 0.9;
  var HEIGHT_SCALE = 1.2;
  var CACHE_LIMIT = 3;
  var cache2 = new LRUCache(CACHE_LIMIT);
  var VALID_PROPS = ["fontFamily", "fontWeight", "characterSet", "fontSize", "sdf", "buffer", "cutoff", "radius"];
  function getNewChars(key, characterSet) {
    var cachedFontAtlas = cache2.get(key);
    if (!cachedFontAtlas) {
      return characterSet;
    }
    var newChars = [];
    var cachedMapping = cachedFontAtlas.mapping;
    var cachedCharSet = Object.keys(cachedMapping);
    cachedCharSet = new Set(cachedCharSet);
    var charSet = characterSet;
    if (charSet instanceof Array) {
      charSet = new Set(charSet);
    }
    charSet.forEach(function(_char) {
      if (!cachedCharSet.has(_char)) {
        newChars.push(_char);
      }
    });
    return newChars;
  }
  function populateAlphaChannel(alphaChannel, imageData) {
    for (var i = 0; i < alphaChannel.length; i++) {
      imageData.data[4 * i + 3] = alphaChannel[i];
    }
  }
  function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
    ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
    ctx.fillStyle = "#000";
    ctx.textBaseline = "baseline";
    ctx.textAlign = "left";
  }
  var FontAtlasManager = function() {
    function FontAtlasManager2() {
      _classCallCheck(this, FontAtlasManager2);
      this.props = {
        fontFamily: DEFAULT_FONT_FAMILY,
        fontWeight: DEFAULT_FONT_WEIGHT,
        characterSet: DEFAULT_CHAR_SET,
        fontSize: DEFAULT_FONT_SIZE,
        buffer: DEFAULT_BUFFER3,
        sdf: false,
        cutoff: DEFAULT_CUTOFF,
        radius: DEFAULT_RADIUS
      };
      this._key = null;
      this._atlas = null;
    }
    _createClass(FontAtlasManager2, [{
      key: "setProps",
      value: function setProps() {
        var _this = this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        VALID_PROPS.forEach(function(prop) {
          if (prop in props) {
            _this.props[prop] = props[prop];
          }
        });
        var oldKey = this._key;
        this._key = this._getKey();
        var charSet = getNewChars(this._key, this.props.characterSet);
        var cachedFontAtlas = cache2.get(this._key);
        if (cachedFontAtlas && charSet.length === 0) {
          if (this._key !== oldKey) {
            this._atlas = cachedFontAtlas;
          }
          return;
        }
        var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);
        this._atlas = fontAtlas;
        cache2.set(this._key, fontAtlas);
      }
    }, {
      key: "_generateFontAtlas",
      value: function _generateFontAtlas(key, characterSet, cachedFontAtlas) {
        var _this$props = this.props, fontFamily = _this$props.fontFamily, fontWeight = _this$props.fontWeight, fontSize = _this$props.fontSize, buffer = _this$props.buffer, sdf = _this$props.sdf, radius = _this$props.radius, cutoff = _this$props.cutoff;
        var canvas = cachedFontAtlas && cachedFontAtlas.data;
        if (!canvas) {
          canvas = document.createElement("canvas");
          canvas.width = MAX_CANVAS_WIDTH;
        }
        var ctx = canvas.getContext("2d");
        setTextStyle(ctx, fontFamily, fontSize, fontWeight);
        var _buildMapping = buildMapping2(Object.assign({
          getFontWidth: function getFontWidth(_char2) {
            return ctx.measureText(_char2).width;
          },
          fontHeight: fontSize * HEIGHT_SCALE,
          buffer,
          characterSet,
          maxCanvasWidth: MAX_CANVAS_WIDTH
        }, cachedFontAtlas && {
          mapping: cachedFontAtlas.mapping,
          xOffset: cachedFontAtlas.xOffset,
          yOffset: cachedFontAtlas.yOffset
        })), mapping = _buildMapping.mapping, canvasHeight = _buildMapping.canvasHeight, xOffset = _buildMapping.xOffset, yOffset = _buildMapping.yOffset;
        if (canvas.height !== canvasHeight) {
          var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          canvas.height = canvasHeight;
          ctx.putImageData(imageData, 0, 0);
        }
        setTextStyle(ctx, fontFamily, fontSize, fontWeight);
        if (sdf) {
          var tinySDF = new import_tiny_sdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
          var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);
          var _iterator = _createForOfIteratorHelper53(characterSet), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _char3 = _step.value;
              populateAlphaChannel(tinySDF.draw(_char3), _imageData);
              ctx.putImageData(_imageData, mapping[_char3].x - buffer, mapping[_char3].y - buffer);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          var _iterator2 = _createForOfIteratorHelper53(characterSet), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _char4 = _step2.value;
              ctx.fillText(_char4, mapping[_char4].x, mapping[_char4].y + fontSize * BASELINE_SCALE);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return {
          xOffset,
          yOffset,
          mapping,
          data: canvas,
          width: canvas.width,
          height: canvas.height
        };
      }
    }, {
      key: "_getKey",
      value: function _getKey() {
        var _this$props2 = this.props, fontFamily = _this$props2.fontFamily, fontWeight = _this$props2.fontWeight, fontSize = _this$props2.fontSize, buffer = _this$props2.buffer, sdf = _this$props2.sdf, radius = _this$props2.radius, cutoff = _this$props2.cutoff;
        if (sdf) {
          return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
        }
        return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
      }
    }, {
      key: "texture",
      get: function get2() {
        return this._atlas;
      }
    }, {
      key: "mapping",
      get: function get2() {
        return this._atlas && this._atlas.mapping;
      }
    }, {
      key: "scale",
      get: function get2() {
        return HEIGHT_SCALE;
      }
    }]);
    return FontAtlasManager2;
  }();

  // node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js
  function _createForOfIteratorHelper54(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray55(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray55(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray55(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray55(o, minLen);
  }
  function _arrayLikeToArray55(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys34(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread34(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys34(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys34(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _createSuper47(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct48();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct48() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var DEFAULT_FONT_SETTINGS = {
    fontSize: DEFAULT_FONT_SIZE,
    buffer: DEFAULT_BUFFER3,
    sdf: false,
    radius: DEFAULT_RADIUS,
    cutoff: DEFAULT_CUTOFF
  };
  var TEXT_ANCHOR = {
    start: 1,
    middle: 0,
    end: -1
  };
  var ALIGNMENT_BASELINE = {
    top: 1,
    center: 0,
    bottom: -1
  };
  var DEFAULT_COLOR5 = [0, 0, 0, 255];
  var DEFAULT_LINE_HEIGHT = 1;
  var FONT_SETTINGS_PROPS = ["fontSize", "buffer", "sdf", "radius", "cutoff"];
  var defaultProps11 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    backgroundColor: {
      type: "color",
      value: null,
      optional: true
    },
    characterSet: DEFAULT_CHAR_SET,
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: DEFAULT_FONT_WEIGHT,
    lineHeight: DEFAULT_LINE_HEIGHT,
    fontSettings: {},
    wordBreak: "break-word",
    maxWidth: {
      type: "number",
      value: -1
    },
    getText: {
      type: "accessor",
      value: function value10(x) {
        return x.text;
      }
    },
    getPosition: {
      type: "accessor",
      value: function value11(x) {
        return x.position;
      }
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR5
    },
    getSize: {
      type: "accessor",
      value: 32
    },
    getAngle: {
      type: "accessor",
      value: 0
    },
    getTextAnchor: {
      type: "accessor",
      value: "middle"
    },
    getAlignmentBaseline: {
      type: "accessor",
      value: "center"
    },
    getPixelOffset: {
      type: "accessor",
      value: [0, 0]
    }
  };
  var TextLayer = function(_CompositeLayer) {
    _inherits(TextLayer2, _CompositeLayer);
    var _super = _createSuper47(TextLayer2);
    function TextLayer2() {
      _classCallCheck(this, TextLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(TextLayer2, [{
      key: "initializeState",
      value: function initializeState() {
        this.state = {
          styleVersion: 0,
          fontAtlasManager: new FontAtlasManager()
        };
      }
    }, {
      key: "updateState",
      value: function updateState(_ref) {
        var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
        var fontChanged = this._fontChanged(oldProps, props);
        if (fontChanged) {
          this._updateFontAtlas(oldProps, props);
        }
        var styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
        var textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
        if (textChanged) {
          this._updateText();
        }
        if (styleChanged) {
          this.setState({
            styleVersion: this.state.styleVersion + 1
          });
        }
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(_ref2) {
        var info = _ref2.info;
        return Object.assign(info, {
          object: info.index >= 0 ? this.props.data[info.index] : null
        });
      }
    }, {
      key: "_updateFontAtlas",
      value: function _updateFontAtlas(oldProps, props) {
        var characterSet = props.characterSet, fontSettings = props.fontSettings, fontFamily = props.fontFamily, fontWeight = props.fontWeight;
        var fontAtlasManager = this.state.fontAtlasManager;
        fontAtlasManager.setProps(Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {
          characterSet,
          fontFamily,
          fontWeight
        }));
        this.setNeedsRedraw(true);
      }
    }, {
      key: "_fontChanged",
      value: function _fontChanged(oldProps, props) {
        if (oldProps.fontFamily !== props.fontFamily || oldProps.characterSet !== props.characterSet || oldProps.fontWeight !== props.fontWeight) {
          return true;
        }
        if (oldProps.fontSettings === props.fontSettings) {
          return false;
        }
        var oldFontSettings = oldProps.fontSettings || {};
        var fontSettings = props.fontSettings || {};
        return FONT_SETTINGS_PROPS.some(function(prop) {
          return oldFontSettings[prop] !== fontSettings[prop];
        });
      }
    }, {
      key: "_updateText",
      value: function _updateText() {
        var data = this.props.data;
        var textBuffer = data.attributes && data.attributes.getText;
        var getText = this.props.getText;
        var startIndices = data.startIndices;
        var numInstances;
        if (textBuffer && startIndices) {
          var _getTextFromBuffer = getTextFromBuffer(_objectSpread34(_objectSpread34({}, ArrayBuffer.isView(textBuffer) ? {
            value: textBuffer
          } : textBuffer), {}, {
            length: data.length,
            startIndices
          })), texts = _getTextFromBuffer.texts, characterCount = _getTextFromBuffer.characterCount;
          numInstances = characterCount;
          getText = function getText2(_, _ref3) {
            var index = _ref3.index;
            return texts[index];
          };
        } else {
          var _createIterable = createIterable(data), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
          startIndices = [0];
          numInstances = 0;
          var _iterator = _createForOfIteratorHelper54(iterable), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var object = _step.value;
              objectInfo.index++;
              var text = getText(object, objectInfo) || "";
              numInstances += Array.from(text).length;
              startIndices.push(numInstances);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        this.setState({
          getText,
          startIndices,
          numInstances
        });
      }
    }, {
      key: "getIconOffsets",
      value: function getIconOffsets(object, objectInfo) {
        var iconMapping = this.state.fontAtlasManager.mapping;
        var getText = this.state.getText;
        var _this$props = this.props, wordBreak = _this$props.wordBreak, maxWidth = _this$props.maxWidth, lineHeight = _this$props.lineHeight, getTextAnchor = _this$props.getTextAnchor, getAlignmentBaseline = _this$props.getAlignmentBaseline;
        var paragraph = getText(object, objectInfo) || "";
        var _transformParagraph = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping), x = _transformParagraph.x, y = _transformParagraph.y, rowWidth = _transformParagraph.rowWidth, _transformParagraph$s = _slicedToArray(_transformParagraph.size, 2), width = _transformParagraph$s[0], height = _transformParagraph$s[1];
        var anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
        var anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
        var numCharacters = x.length;
        var offsets = new Array(numCharacters * 2);
        var index = 0;
        for (var i = 0; i < numCharacters; i++) {
          var rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
          offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];
          offsets[index++] = (anchorY - 1) * height / 2 + y[i];
        }
        return offsets;
      }
    }, {
      key: "renderLayers",
      value: function renderLayers() {
        var _this$state = this.state, startIndices = _this$state.startIndices, numInstances = _this$state.numInstances, getText = _this$state.getText, _this$state$fontAtlas = _this$state.fontAtlasManager, scale5 = _this$state$fontAtlas.scale, texture = _this$state$fontAtlas.texture, mapping = _this$state$fontAtlas.mapping, styleVersion = _this$state.styleVersion;
        var _this$props2 = this.props, data = _this$props2.data, _dataDiff = _this$props2._dataDiff, backgroundColor = _this$props2.backgroundColor, getPosition2 = _this$props2.getPosition, getColor2 = _this$props2.getColor, getSize = _this$props2.getSize, getAngle = _this$props2.getAngle, getPixelOffset = _this$props2.getPixelOffset, billboard = _this$props2.billboard, fontSettings = _this$props2.fontSettings, sizeScale = _this$props2.sizeScale, sizeUnits = _this$props2.sizeUnits, sizeMinPixels = _this$props2.sizeMinPixels, sizeMaxPixels = _this$props2.sizeMaxPixels, transitions = _this$props2.transitions, updateTriggers = _this$props2.updateTriggers;
        var getIconOffsets = this.getIconOffsets.bind(this);
        var SubLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
        return new SubLayerClass({
          sdf: fontSettings.sdf,
          iconAtlas: texture,
          iconMapping: mapping,
          backgroundColor,
          getPosition: getPosition2,
          getColor: getColor2,
          getSize,
          getAngle,
          getPixelOffset,
          billboard,
          sizeScale: sizeScale * scale5,
          sizeUnits,
          sizeMinPixels: sizeMinPixels * scale5,
          sizeMaxPixels: sizeMaxPixels * scale5,
          transitions: transitions && {
            getPosition: transitions.getPosition,
            getAngle: transitions.getAngle,
            getColor: transitions.getColor,
            getSize: transitions.getSize,
            getPixelOffset: transitions.getPixelOffset
          }
        }, this.getSubLayerProps({
          id: "characters",
          updateTriggers: {
            getIcon: updateTriggers.getText,
            getPosition: updateTriggers.getPosition,
            getAngle: updateTriggers.getAngle,
            getColor: updateTriggers.getColor,
            getSize: updateTriggers.getSize,
            getPixelOffset: updateTriggers.getPixelOffset,
            getIconOffsets: {
              getText: updateTriggers.getText,
              getTextAnchor: updateTriggers.getTextAnchor,
              getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
              styleVersion
            }
          }
        }), {
          data,
          _dataDiff,
          startIndices,
          numInstances,
          getIconOffsets,
          getIcon: getText
        });
      }
    }]);
    return TextLayer2;
  }(CompositeLayer);
  TextLayer.layerName = "TextLayer";
  TextLayer.defaultProps = defaultProps11;

  // node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-2d-header.js
  var import_regenerator26 = __toModule(require_regenerator());
  var Tile2DHeader = function() {
    function Tile2DHeader2(_ref) {
      var x = _ref.x, y = _ref.y, z = _ref.z, onTileLoad = _ref.onTileLoad, onTileError = _ref.onTileError;
      _classCallCheck(this, Tile2DHeader2);
      this.x = x;
      this.y = y;
      this.z = z;
      this.isVisible = false;
      this.isSelected = false;
      this.parent = null;
      this.children = [];
      this.content = null;
      this._isLoaded = false;
      this._isCancelled = false;
      this.onTileLoad = onTileLoad;
      this.onTileError = onTileError;
    }
    _createClass(Tile2DHeader2, [{
      key: "_loadData",
      value: function() {
        var _loadData2 = _asyncToGenerator(import_regenerator26.default.mark(function _callee(getTileData, requestScheduler) {
          var x, y, z, bbox, signal, requestToken, tileData, error2;
          return import_regenerator26.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  x = this.x, y = this.y, z = this.z, bbox = this.bbox;
                  this._abortController = new AbortController();
                  signal = this._abortController.signal;
                  _context.next = 5;
                  return requestScheduler.scheduleRequest(this, function(tile) {
                    return tile.isSelected ? 1 : -1;
                  });
                case 5:
                  requestToken = _context.sent;
                  if (requestToken) {
                    _context.next = 9;
                    break;
                  }
                  this._isCancelled = true;
                  return _context.abrupt("return");
                case 9:
                  if (!this._isCancelled) {
                    _context.next = 12;
                    break;
                  }
                  requestToken.done();
                  return _context.abrupt("return");
                case 12:
                  _context.prev = 12;
                  _context.next = 15;
                  return getTileData({
                    x,
                    y,
                    z,
                    bbox,
                    signal
                  });
                case 15:
                  tileData = _context.sent;
                  _context.next = 21;
                  break;
                case 18:
                  _context.prev = 18;
                  _context.t0 = _context["catch"](12);
                  error2 = _context.t0 || true;
                case 21:
                  _context.prev = 21;
                  requestToken.done();
                  if (this._isCancelled && !tileData) {
                    this._isLoaded = false;
                  } else {
                    this._isLoaded = true;
                    this._isCancelled = false;
                  }
                  return _context.finish(21);
                case 25:
                  if (this._isLoaded) {
                    _context.next = 27;
                    break;
                  }
                  return _context.abrupt("return");
                case 27:
                  if (error2) {
                    this.onTileError(error2, this);
                  } else {
                    this.content = tileData;
                    this.onTileLoad(this);
                  }
                case 28:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[12, 18, 21, 25]]);
        }));
        function _loadData(_x, _x2) {
          return _loadData2.apply(this, arguments);
        }
        return _loadData;
      }()
    }, {
      key: "loadData",
      value: function loadData(getTileData, requestScheduler) {
        var _this = this;
        if (!getTileData) {
          return;
        }
        this._isCancelled = false;
        this._loader = this._loadData(getTileData, requestScheduler);
        this._loader["finally"](function() {
          _this._loader = void 0;
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        if (this.isLoaded) {
          return;
        }
        this._isCancelled = true;
        this._abortController.abort();
      }
    }, {
      key: "data",
      get: function get2() {
        return this._isLoaded ? this.content : this._loader;
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        return this._isLoaded;
      }
    }, {
      key: "isLoading",
      get: function get2() {
        return Boolean(this._loader);
      }
    }, {
      key: "isCancelled",
      get: function get2() {
        return this._isCancelled;
      }
    }, {
      key: "byteLength",
      get: function get2() {
        var result = this.content ? this.content.byteLength : 0;
        if (!Number.isFinite(result)) {
          log_default.error("byteLength not defined in tile data")();
        }
        return result;
      }
    }]);
    return Tile2DHeader2;
  }();

  // node_modules/@math.gl/culling/dist/esm/constants.js
  var INTERSECTION = Object.freeze({
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1
  });

  // node_modules/@math.gl/culling/dist/esm/lib/axis-aligned-bounding-box.js
  var scratchVector2 = new Vector3();
  var scratchNormal = new Vector3();
  var AxisAlignedBoundingBox = function() {
    function AxisAlignedBoundingBox2() {
      var minimum = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0];
      var maximum = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
      var center = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      _classCallCheck(this, AxisAlignedBoundingBox2);
      center = center || scratchVector2.copy(minimum).add(maximum).scale(0.5);
      this.center = new Vector3(center);
      this.halfDiagonal = new Vector3(maximum).subtract(this.center);
      this.minimum = new Vector3(minimum);
      this.maximum = new Vector3(maximum);
    }
    _createClass(AxisAlignedBoundingBox2, [{
      key: "clone",
      value: function clone3() {
        return new AxisAlignedBoundingBox2(this.minimum, this.maximum, this.center);
      }
    }, {
      key: "equals",
      value: function equals5(right) {
        return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
      }
    }, {
      key: "intersectPlane",
      value: function intersectPlane(plane) {
        var halfDiagonal = this.halfDiagonal;
        var normal = scratchNormal.from(plane.normal);
        var e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
        var s = this.center.dot(normal) + plane.distance;
        if (s - e > 0) {
          return INTERSECTION.INSIDE;
        }
        if (s + e < 0) {
          return INTERSECTION.OUTSIDE;
        }
        return INTERSECTION.INTERSECTING;
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
      }
    }, {
      key: "distanceSquaredTo",
      value: function distanceSquaredTo(point) {
        var offset = scratchVector2.from(point).subtract(this.center);
        var halfDiagonal = this.halfDiagonal;
        var distanceSquared = 0;
        var d;
        d = Math.abs(offset.x) - halfDiagonal.x;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.y) - halfDiagonal.y;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.z) - halfDiagonal.z;
        if (d > 0) {
          distanceSquared += d * d;
        }
        return distanceSquared;
      }
    }]);
    return AxisAlignedBoundingBox2;
  }();

  // node_modules/@math.gl/culling/dist/esm/lib/bounding-sphere.js
  var scratchVector3 = new Vector3();
  var scratchVector22 = new Vector3();
  var BoundingSphere = function() {
    function BoundingSphere2() {
      var center = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0];
      var radius = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      _classCallCheck(this, BoundingSphere2);
      this.radius = -0;
      this.center = new Vector3();
      this.fromCenterRadius(center, radius);
    }
    _createClass(BoundingSphere2, [{
      key: "fromCenterRadius",
      value: function fromCenterRadius(center, radius) {
        this.center.from(center);
        this.radius = radius;
        return this;
      }
    }, {
      key: "fromCornerPoints",
      value: function fromCornerPoints(corner, oppositeCorner) {
        oppositeCorner = scratchVector3.from(oppositeCorner);
        this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
        this.radius = this.center.distance(oppositeCorner);
        return this;
      }
    }, {
      key: "equals",
      value: function equals5(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
      }
    }, {
      key: "clone",
      value: function clone3() {
        return new BoundingSphere2(this.center, this.radius);
      }
    }, {
      key: "union",
      value: function union(boundingSphere) {
        var leftCenter = this.center;
        var leftRadius = this.radius;
        var rightCenter = boundingSphere.center;
        var rightRadius = boundingSphere.radius;
        var toRightCenter = scratchVector3.copy(rightCenter).subtract(leftCenter);
        var centerSeparation = toRightCenter.magnitude();
        if (leftRadius >= centerSeparation + rightRadius) {
          return this.clone();
        }
        if (rightRadius >= centerSeparation + leftRadius) {
          return boundingSphere.clone();
        }
        var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
        scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
        this.center.copy(scratchVector22);
        this.radius = halfDistanceBetweenTangentPoints;
        return this;
      }
    }, {
      key: "expand",
      value: function expand(point) {
        point = scratchVector3.from(point);
        var radius = point.subtract(this.center).magnitude();
        if (radius > this.radius) {
          this.radius = radius;
        }
        return this;
      }
    }, {
      key: "intersectPlane",
      value: function intersectPlane(plane) {
        var center = this.center;
        var radius = this.radius;
        var normal = plane.normal;
        var distanceToPlane = normal.dot(center) + plane.distance;
        if (distanceToPlane < -radius) {
          return INTERSECTION.OUTSIDE;
        }
        if (distanceToPlane < radius) {
          return INTERSECTION.INTERSECTING;
        }
        return INTERSECTION.INSIDE;
      }
    }, {
      key: "transform",
      value: function transform4(_transform) {
        this.center.transform(_transform);
        var scale5 = getScaling(scratchVector3, _transform);
        this.radius = Math.max(scale5[0], Math.max(scale5[1], scale5[2])) * this.radius;
        return this;
      }
    }, {
      key: "distanceSquaredTo",
      value: function distanceSquaredTo(point) {
        point = scratchVector3.from(point);
        var delta = point.subtract(this.center);
        return delta.lengthSquared() - this.radius * this.radius;
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
      }
    }]);
    return BoundingSphere2;
  }();

  // node_modules/@math.gl/culling/dist/esm/lib/oriented-bounding-box.js
  var scratchVector4 = new Vector3();
  var scratchOffset = new Vector3();
  var scratchVectorU = new Vector3();
  var scratchVectorV = new Vector3();
  var scratchVectorW = new Vector3();
  var scratchCorner = new Vector3();
  var scratchToCenter = new Vector3();
  var fromOrientedBoundingBoxScratchU = new Vector3();
  var fromOrientedBoundingBoxScratchV = new Vector3();
  var fromOrientedBoundingBoxScratchW = new Vector3();
  var MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
  };
  var OrientedBoundingBox = function() {
    function OrientedBoundingBox2() {
      var center = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0];
      var halfAxes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
      _classCallCheck(this, OrientedBoundingBox2);
      this.center = new Vector3().from(center);
      this.halfAxes = new Matrix3(halfAxes);
    }
    _createClass(OrientedBoundingBox2, [{
      key: "fromCenterHalfSizeQuaternion",
      value: function fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {
        var quaternionObject = new Quaternion(quaternion);
        var directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
        directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
        directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
        directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
        directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
        directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
        directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
        directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
        directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
        directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
        this.center = new Vector3().from(center);
        this.halfAxes = directionsMatrix;
        return this;
      }
    }, {
      key: "clone",
      value: function clone3() {
        return new OrientedBoundingBox2(this.center, this.halfAxes);
      }
    }, {
      key: "equals",
      value: function equals5(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
      }
    }, {
      key: "getBoundingSphere",
      value: function getBoundingSphere() {
        var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new BoundingSphere();
        var halfAxes = this.halfAxes;
        var u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);
        var v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);
        var w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);
        var cornerVector = scratchVector4.copy(u).add(v).add(w);
        result.center.copy(this.center);
        result.radius = cornerVector.magnitude();
        return result;
      }
    }, {
      key: "intersectPlane",
      value: function intersectPlane(plane) {
        var center = this.center;
        var normal = plane.normal;
        var halfAxes = this.halfAxes;
        var normalX = normal.x;
        var normalY = normal.y;
        var normalZ = normal.z;
        var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
        var distanceToPlane = normal.dot(center) + plane.distance;
        if (distanceToPlane <= -radEffective) {
          return INTERSECTION.OUTSIDE;
        } else if (distanceToPlane >= radEffective) {
          return INTERSECTION.INSIDE;
        }
        return INTERSECTION.INTERSECTING;
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
      }
    }, {
      key: "distanceSquaredTo",
      value: function distanceSquaredTo(point) {
        var offset = scratchOffset.from(point).subtract(this.center);
        var halfAxes = this.halfAxes;
        var u = halfAxes.getColumn(0, scratchVectorU);
        var v = halfAxes.getColumn(1, scratchVectorV);
        var w = halfAxes.getColumn(2, scratchVectorW);
        var uHalf = u.magnitude();
        var vHalf = v.magnitude();
        var wHalf = w.magnitude();
        u.normalize();
        v.normalize();
        w.normalize();
        var distanceSquared = 0;
        var d;
        d = Math.abs(offset.dot(u)) - uHalf;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(v)) - vHalf;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(w)) - wHalf;
        if (d > 0) {
          distanceSquared += d * d;
        }
        return distanceSquared;
      }
    }, {
      key: "computePlaneDistances",
      value: function computePlaneDistances(position, direction) {
        var result = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [-0, -0];
        var minDist = Number.POSITIVE_INFINITY;
        var maxDist = Number.NEGATIVE_INFINITY;
        var center = this.center;
        var halfAxes = this.halfAxes;
        var u = halfAxes.getColumn(0, scratchVectorU);
        var v = halfAxes.getColumn(1, scratchVectorV);
        var w = halfAxes.getColumn(2, scratchVectorW);
        var corner = scratchCorner.copy(u).add(v).add(w).add(center);
        var toCenter = scratchToCenter.copy(corner).subtract(position);
        var mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        corner.copy(center).add(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        corner.copy(center).add(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        corner.copy(center).add(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).add(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        result[0] = minDist;
        result[1] = maxDist;
        return result;
      }
    }, {
      key: "getTransform",
      value: function getTransform3() {
      }
    }, {
      key: "halfSize",
      get: function get2() {
        var xAxis = this.halfAxes.getColumn(0);
        var yAxis = this.halfAxes.getColumn(1);
        var zAxis = this.halfAxes.getColumn(2);
        return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
      }
    }, {
      key: "quaternion",
      get: function get2() {
        var xAxis = this.halfAxes.getColumn(0);
        var yAxis = this.halfAxes.getColumn(1);
        var zAxis = this.halfAxes.getColumn(2);
        var normXAxis = new Vector3(xAxis).normalize();
        var normYAxis = new Vector3(yAxis).normalize();
        var normZAxis = new Vector3(zAxis).normalize();
        return new Quaternion().fromMatrix3(new Matrix3([].concat(_toConsumableArray(normXAxis), _toConsumableArray(normYAxis), _toConsumableArray(normZAxis))));
      }
    }]);
    return OrientedBoundingBox2;
  }();

  // node_modules/@math.gl/culling/dist/esm/lib/plane.js
  var scratchPosition = new Vector3();
  var scratchNormal2 = new Vector3();
  var Plane = function() {
    function Plane2() {
      var normal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 1];
      var distance2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      _classCallCheck(this, Plane2);
      this.normal = new Vector3();
      this.distance = -0;
      this.fromNormalDistance(normal, distance2);
    }
    _createClass(Plane2, [{
      key: "fromNormalDistance",
      value: function fromNormalDistance(normal, distance2) {
        assert7(Number.isFinite(distance2));
        this.normal.from(normal).normalize();
        this.distance = distance2;
        return this;
      }
    }, {
      key: "fromPointNormal",
      value: function fromPointNormal(point, normal) {
        point = scratchPosition.from(point);
        this.normal.from(normal).normalize();
        var distance2 = -this.normal.dot(point);
        this.distance = distance2;
        return this;
      }
    }, {
      key: "fromCoefficients",
      value: function fromCoefficients(a, b, c, d) {
        this.normal.set(a, b, c);
        assert7(equals(this.normal.len(), 1));
        this.distance = d;
        return this;
      }
    }, {
      key: "clone",
      value: function clone3(plane) {
        return new Plane2(this.normal, this.distance);
      }
    }, {
      key: "equals",
      value: function equals5(right) {
        return equals(this.distance, right.distance) && equals(this.normal, right.normal);
      }
    }, {
      key: "getPointDistance",
      value: function getPointDistance(point) {
        return this.normal.dot(point) + this.distance;
      }
    }, {
      key: "transform",
      value: function transform4(matrix4) {
        var normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
        var point = this.normal.scale(-this.distance).transform(matrix4);
        return this.fromPointNormal(point, normal);
      }
    }, {
      key: "projectPointOntoPlane",
      value: function projectPointOntoPlane(point) {
        var result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
        point = scratchPosition.from(point);
        var pointDistance = this.getPointDistance(point);
        var scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
        return point.subtract(scaledNormal).to(result);
      }
    }]);
    return Plane2;
  }();

  // node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js
  function _createForOfIteratorHelper55(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray56(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray56(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray56(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray56(o, minLen);
  }
  function _arrayLikeToArray56(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
  var scratchPlaneCenter = new Vector3();
  var scratchPlaneNormal = new Vector3();
  var scratchPlane = new Plane(new Vector3(1, 0, 0), 0);
  var CullingVolume = function() {
    _createClass(CullingVolume2, null, [{
      key: "MASK_OUTSIDE",
      get: function get2() {
        return 4294967295;
      }
    }, {
      key: "MASK_INSIDE",
      get: function get2() {
        return 0;
      }
    }, {
      key: "MASK_INDETERMINATE",
      get: function get2() {
        return 2147483647;
      }
    }]);
    function CullingVolume2() {
      var planes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      _classCallCheck(this, CullingVolume2);
      this.planes = planes;
      assert7(this.planes.every(function(plane) {
        return plane instanceof Plane;
      }));
    }
    _createClass(CullingVolume2, [{
      key: "fromBoundingSphere",
      value: function fromBoundingSphere(boundingSphere) {
        this.planes.length = 2 * faces.length;
        var center = boundingSphere.center;
        var radius = boundingSphere.radius;
        var planeIndex = 0;
        var _iterator = _createForOfIteratorHelper55(faces), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var faceNormal = _step.value;
            var plane0 = this.planes[planeIndex];
            var plane1 = this.planes[planeIndex + 1];
            if (!plane0) {
              plane0 = this.planes[planeIndex] = new Plane();
            }
            if (!plane1) {
              plane1 = this.planes[planeIndex + 1] = new Plane();
            }
            var plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
            var plane0Distance = -faceNormal.dot(plane0Center);
            plane0.fromPointNormal(plane0Center, faceNormal);
            var plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
            var negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
            var plane1Distance = -negatedFaceNormal.dot(plane1Center);
            plane1.fromPointNormal(plane1Center, negatedFaceNormal);
            planeIndex += 2;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return this;
      }
    }, {
      key: "computeVisibility",
      value: function computeVisibility(boundingVolume) {
        assert7(boundingVolume);
        var intersect2 = INTERSECTION.INSIDE;
        var _iterator2 = _createForOfIteratorHelper55(this.planes), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var plane = _step2.value;
            var result = boundingVolume.intersectPlane(plane);
            switch (result) {
              case INTERSECTION.OUTSIDE:
                return INTERSECTION.OUTSIDE;
              case INTERSECTION.INTERSECTING:
                intersect2 = INTERSECTION.INTERSECTING;
                break;
              default:
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return intersect2;
      }
    }, {
      key: "computeVisibilityWithPlaneMask",
      value: function computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
        assert7(boundingVolume, "boundingVolume is required.");
        assert7(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
        if (parentPlaneMask === CullingVolume2.MASK_OUTSIDE || parentPlaneMask === CullingVolume2.MASK_INSIDE) {
          return parentPlaneMask;
        }
        var mask = CullingVolume2.MASK_INSIDE;
        var planes = this.planes;
        for (var k = 0; k < this.planes.length; ++k) {
          var flag = k < 31 ? 1 << k : 0;
          if (k < 31 && (parentPlaneMask & flag) === 0) {
            continue;
          }
          var plane = planes[k];
          var result = boundingVolume.intersectPlane(plane);
          if (result === INTERSECTION.OUTSIDE) {
            return CullingVolume2.MASK_OUTSIDE;
          } else if (result === INTERSECTION.INTERSECTING) {
            mask |= flag;
          }
        }
        return mask;
      }
    }]);
    return CullingVolume2;
  }();

  // node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js
  function ownKeys35(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread35(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys35(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys35(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var scratchPlaneUpVector = new Vector3();
  var scratchPlaneRightVector = new Vector3();
  var scratchPlaneNearCenter = new Vector3();
  var scratchPlaneFarCenter = new Vector3();
  var scratchPlaneNormal2 = new Vector3();
  var PerspectiveOffCenterFrustum = function() {
    function PerspectiveOffCenterFrustum2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, PerspectiveOffCenterFrustum2);
      options = _objectSpread35({
        near: 1,
        far: 5e8
      }, options);
      this.left = options.left;
      this._left = void 0;
      this.right = options.right;
      this._right = void 0;
      this.top = options.top;
      this._top = void 0;
      this.bottom = options.bottom;
      this._bottom = void 0;
      this.near = options.near;
      this._near = this.near;
      this.far = options.far;
      this._far = this.far;
      this._cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);
      this._perspectiveMatrix = new Matrix4();
      this._infinitePerspective = new Matrix4();
    }
    _createClass(PerspectiveOffCenterFrustum2, [{
      key: "clone",
      value: function clone3() {
        return new PerspectiveOffCenterFrustum2({
          right: this.right,
          left: this.left,
          top: this.top,
          bottom: this.bottom,
          near: this.near,
          far: this.far
        });
      }
    }, {
      key: "equals",
      value: function equals5(other) {
        return other && other instanceof PerspectiveOffCenterFrustum2 && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
      }
    }, {
      key: "computeCullingVolume",
      value: function computeCullingVolume(position, direction, up) {
        assert7(position, "position is required.");
        assert7(direction, "direction is required.");
        assert7(up, "up is required.");
        var planes = this._cullingVolume.planes;
        up = scratchPlaneUpVector.copy(up).normalize();
        var right = scratchPlaneRightVector.copy(direction).cross(up).normalize();
        var nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
        var farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
        var normal = scratchPlaneNormal2;
        normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);
        planes[0].fromPointNormal(position, normal);
        normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();
        planes[1].fromPointNormal(position, normal);
        normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();
        planes[2].fromPointNormal(position, normal);
        normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);
        planes[3].fromPointNormal(position, normal);
        normal = new Vector3().copy(direction);
        planes[4].fromPointNormal(nearCenter, normal);
        normal.negate();
        planes[5].fromPointNormal(farCenter, normal);
        return this._cullingVolume;
      }
    }, {
      key: "getPixelDimensions",
      value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance2, result) {
        update(this);
        assert7(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
        assert7(drawingBufferWidth > 0);
        assert7(drawingBufferHeight > 0);
        assert7(distance2 > 0);
        assert7(result);
        var inverseNear = 1 / this.near;
        var tanTheta = this.top * inverseNear;
        var pixelHeight = 2 * distance2 * tanTheta / drawingBufferHeight;
        tanTheta = this.right * inverseNear;
        var pixelWidth = 2 * distance2 * tanTheta / drawingBufferWidth;
        result.x = pixelWidth;
        result.y = pixelHeight;
        return result;
      }
    }, {
      key: "projectionMatrix",
      get: function get2() {
        update(this);
        return this._perspectiveMatrix;
      }
    }, {
      key: "infiniteProjectionMatrix",
      get: function get2() {
        update(this);
        return this._infinitePerspective;
      }
    }]);
    return PerspectiveOffCenterFrustum2;
  }();
  function update(frustum2) {
    assert7(Number.isFinite(frustum2.right) && Number.isFinite(frustum2.left) && Number.isFinite(frustum2.top) && Number.isFinite(frustum2.bottom) && Number.isFinite(frustum2.near) && Number.isFinite(frustum2.far));
    var top = frustum2.top, bottom = frustum2.bottom, right = frustum2.right, left = frustum2.left, near = frustum2.near, far = frustum2.far;
    if (top !== frustum2._top || bottom !== frustum2._bottom || left !== frustum2._left || right !== frustum2._right || near !== frustum2._near || far !== frustum2._far) {
      assert7(frustum2.near > 0 && frustum2.near < frustum2.far, "near must be greater than zero and less than far.");
      frustum2._left = left;
      frustum2._right = right;
      frustum2._top = top;
      frustum2._bottom = bottom;
      frustum2._near = near;
      frustum2._far = far;
      frustum2._perspectiveMatrix = new Matrix4().frustum({
        left,
        right,
        bottom,
        top,
        near,
        far
      });
      frustum2._infinitePerspective = new Matrix4().frustum({
        left,
        right,
        bottom,
        top,
        near,
        far: Infinity
      });
    }
  }

  // node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js
  function ownKeys36(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread36(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys36(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys36(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var defined = function defined2(val) {
    return val !== null && typeof val !== "undefined";
  };
  var PerspectiveFrustum = function() {
    function PerspectiveFrustum2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, PerspectiveFrustum2);
      options = _objectSpread36({
        near: 1,
        far: 5e8,
        xOffset: 0,
        yOffset: 0
      }, options);
      this._offCenterFrustum = new PerspectiveOffCenterFrustum();
      this.fov = options.fov;
      this._fov = void 0;
      this._fovy = void 0;
      this._sseDenominator = void 0;
      this.aspectRatio = options.aspectRatio;
      this._aspectRatio = void 0;
      this.near = options.near;
      this._near = this.near;
      this.far = options.far;
      this._far = this.far;
      this.xOffset = options.xOffset;
      this._xOffset = this.xOffset;
      this.yOffset = options.yOffset;
      this._yOffset = this.yOffset;
    }
    _createClass(PerspectiveFrustum2, [{
      key: "clone",
      value: function clone3() {
        return new PerspectiveFrustum2({
          aspectRatio: this.aspectRatio,
          fov: this.fov,
          near: this.near,
          far: this.far
        });
      }
    }, {
      key: "equals",
      value: function equals5(other) {
        if (!defined(other) || !(other instanceof PerspectiveFrustum2)) {
          return false;
        }
        update2(this);
        update2(other);
        return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
      }
    }, {
      key: "computeCullingVolume",
      value: function computeCullingVolume(position, direction, up) {
        update2(this);
        return this._offCenterFrustum.computeCullingVolume(position, direction, up);
      }
    }, {
      key: "getPixelDimensions",
      value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance2, result) {
        update2(this);
        return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance2, result);
      }
    }, {
      key: "projectionMatrix",
      get: function get2() {
        update2(this);
        return this._offCenterFrustum.projectionMatrix;
      }
    }, {
      key: "infiniteProjectionMatrix",
      get: function get2() {
        update2(this);
        return this._offCenterFrustum.infiniteProjectionMatrix;
      }
    }, {
      key: "fovy",
      get: function get2() {
        update2(this);
        return this._fovy;
      }
    }, {
      key: "sseDenominator",
      get: function get2() {
        update2(this);
        return this._sseDenominator;
      }
    }]);
    return PerspectiveFrustum2;
  }();
  function update2(frustum2) {
    assert7(Number.isFinite(frustum2.fov) && Number.isFinite(frustum2.aspectRatio) && Number.isFinite(frustum2.near) && Number.isFinite(frustum2.far));
    var f = frustum2._offCenterFrustum;
    if (frustum2.fov !== frustum2._fov || frustum2.aspectRatio !== frustum2._aspectRatio || frustum2.near !== frustum2._near || frustum2.far !== frustum2._far || frustum2.xOffset !== frustum2._xOffset || frustum2.yOffset !== frustum2._yOffset) {
      assert7(frustum2.fov >= 0 && frustum2.fov < Math.PI);
      assert7(frustum2.aspectRatio > 0);
      assert7(frustum2.near >= 0 && frustum2.near < frustum2.far);
      frustum2._aspectRatio = frustum2.aspectRatio;
      frustum2._fov = frustum2.fov;
      frustum2._fovy = frustum2.aspectRatio <= 1 ? frustum2.fov : Math.atan(Math.tan(frustum2.fov * 0.5) / frustum2.aspectRatio) * 2;
      frustum2._near = frustum2.near;
      frustum2._far = frustum2.far;
      frustum2._sseDenominator = 2 * Math.tan(0.5 * frustum2._fovy);
      frustum2._xOffset = frustum2.xOffset;
      frustum2._yOffset = frustum2.yOffset;
      f.top = frustum2.near * Math.tan(0.5 * frustum2._fovy);
      f.bottom = -f.top;
      f.right = frustum2.aspectRatio * f.top;
      f.left = -f.right;
      f.near = frustum2.near;
      f.far = frustum2.far;
      f.right += frustum2.xOffset;
      f.left += frustum2.xOffset;
      f.top += frustum2.yOffset;
      f.bottom += frustum2.yOffset;
    }
  }

  // node_modules/@math.gl/culling/dist/esm/algorithms/bounding-sphere-from-points.js
  var fromPointsXMin = new Vector3();
  var fromPointsYMin = new Vector3();
  var fromPointsZMin = new Vector3();
  var fromPointsXMax = new Vector3();
  var fromPointsYMax = new Vector3();
  var fromPointsZMax = new Vector3();
  var fromPointsCurrentPos = new Vector3();
  var fromPointsScratch = new Vector3();
  var fromPointsRitterCenter = new Vector3();
  var fromPointsMinBoxPt = new Vector3();
  var fromPointsMaxBoxPt = new Vector3();
  var fromPointsNaiveCenterScratch = new Vector3();
  var volumeConstant = 4 / 3 * Math.PI;

  // node_modules/@math.gl/culling/dist/esm/algorithms/compute-eigen-decomposition.js
  var scratchMatrix = new Matrix3();
  var scratchUnitary = new Matrix3();
  var scratchDiagonal = new Matrix3();
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();

  // node_modules/@math.gl/culling/dist/esm/algorithms/bounding-box-from-points.js
  var scratchVector23 = new Vector3();
  var scratchVector32 = new Vector3();
  var scratchVector42 = new Vector3();
  var scratchVector5 = new Vector3();
  var scratchVector6 = new Vector3();
  var scratchCovarianceResult = new Matrix3();
  var scratchEigenResult = {
    diagonal: new Matrix3(),
    unitary: new Matrix3()
  };

  // node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-2d-traversal.js
  function _createForOfIteratorHelper56(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray57(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray57(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray57(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray57(o, minLen);
  }
  function _arrayLikeToArray57(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var TILE_SIZE2 = 512;
  var MAX_MAPS = 3;
  var OSMNode = function() {
    function OSMNode2(x, y, z) {
      _classCallCheck(this, OSMNode2);
      this.x = x;
      this.y = y;
      this.z = z;
    }
    _createClass(OSMNode2, [{
      key: "update",
      value: function update3(params) {
        var viewport3 = params.viewport, cullingVolume = params.cullingVolume, elevationBounds = params.elevationBounds, minZ = params.minZ, maxZ = params.maxZ, offset = params.offset, project2 = params.project;
        var boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
        var isInside = cullingVolume.computeVisibility(boundingVolume);
        if (isInside < 0) {
          return false;
        }
        if (!this.childVisible) {
          var z = this.z;
          if (z < maxZ && z >= minZ) {
            var distance2 = boundingVolume.distanceTo(viewport3.cameraPosition) * viewport3.scale / viewport3.height;
            z += Math.floor(Math.log2(distance2));
          }
          if (z >= maxZ) {
            this.selected = true;
            return true;
          }
        }
        this.selected = false;
        this.childVisible = true;
        var _iterator = _createForOfIteratorHelper56(this.children), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var child = _step.value;
            child.update(params);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return true;
      }
    }, {
      key: "getSelected",
      value: function getSelected() {
        var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (this.selected) {
          result.push(this);
        }
        if (this._children) {
          var _iterator2 = _createForOfIteratorHelper56(this._children), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var node2 = _step2.value;
              node2.getSelected(result);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return result;
      }
    }, {
      key: "getBoundingVolume",
      value: function getBoundingVolume(zRange, worldOffset, project2) {
        if (project2) {
          var corner0 = osmTile2lngLat(this.x, this.y, this.z);
          var corner1 = osmTile2lngLat(this.x + 1, this.y + 1, this.z);
          var center = osmTile2lngLat(this.x + 0.5, this.y + 0.5, this.z);
          corner0.z = zRange[1];
          corner1.z = zRange[1];
          center.z = zRange[0];
          var cornerPos0 = project2(corner0);
          var cornerPos1 = project2(corner1);
          var centerPos = new Vector3(project2(center));
          var R = Math.max(centerPos.distance(cornerPos0), centerPos.distance(cornerPos1));
          return new BoundingSphere(centerPos, R);
        }
        var scale5 = Math.pow(2, this.z);
        var extent = TILE_SIZE2 / scale5;
        var originX = this.x * extent + worldOffset * TILE_SIZE2;
        var originY = TILE_SIZE2 - (this.y + 1) * extent;
        return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
      }
    }, {
      key: "children",
      get: function get2() {
        if (!this._children) {
          var x = this.x * 2;
          var y = this.y * 2;
          var z = this.z + 1;
          this._children = [new OSMNode2(x, y, z), new OSMNode2(x, y + 1, z), new OSMNode2(x + 1, y, z), new OSMNode2(x + 1, y + 1, z)];
        }
        return this._children;
      }
    }]);
    return OSMNode2;
  }();
  function getOSMTileIndices(viewport3, maxZ, zRange) {
    var project2 = viewport3.resolution ? viewport3.projectPosition : null;
    var planes = Object.values(viewport3.getFrustumPlanes()).map(function(_ref) {
      var normal = _ref.normal, distance2 = _ref.distance;
      return new Plane(normal.clone().negate(), distance2);
    });
    var cullingVolume = new CullingVolume(planes);
    var unitsPerMeter = viewport3.distanceScales.unitsPerMeter[2];
    var elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
    var elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
    var minZ = viewport3.pitch <= 60 ? maxZ : 0;
    var root = new OSMNode(0, 0, 0);
    var traversalParams = {
      viewport: viewport3,
      project: project2,
      cullingVolume,
      elevationBounds: [elevationMin, elevationMax],
      minZ,
      maxZ,
      offset: 0
    };
    root.update(traversalParams);
    if (viewport3.subViewports && viewport3.subViewports.length > 1) {
      traversalParams.offset = -1;
      while (root.update(traversalParams)) {
        if (--traversalParams.offset < -MAX_MAPS) {
          break;
        }
      }
      traversalParams.offset = 1;
      while (root.update(traversalParams)) {
        if (++traversalParams.offset > MAX_MAPS) {
          break;
        }
      }
    }
    return root.getSelected();
  }

  // node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/utils.js
  var TILE_SIZE3 = 512;
  var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
  var urlType = {
    type: "url",
    value: "",
    validate: function validate10(value17) {
      return typeof value17 === "string" || Array.isArray(value17) && value17.every(function(url) {
        return typeof url === "string";
      });
    },
    equals: function equals4(value1, value22) {
      if (value1 === value22) {
        return true;
      }
      if (!Array.isArray(value1) || !Array.isArray(value22)) {
        return false;
      }
      var len2 = value1.length;
      if (len2 !== value22.length) {
        return false;
      }
      for (var i = 0; i < len2; i++) {
        if (value1[i] !== value22[i]) {
          return false;
        }
      }
      return true;
    }
  };
  function transformBox(bbox, modelMatrix) {
    var transformedCoords = [modelMatrix.transformPoint([bbox[0], bbox[1]]), modelMatrix.transformPoint([bbox[2], bbox[1]]), modelMatrix.transformPoint([bbox[0], bbox[3]]), modelMatrix.transformPoint([bbox[2], bbox[3]])];
    var transformedBox = [Math.min.apply(Math, _toConsumableArray(transformedCoords.map(function(i) {
      return i[0];
    }))), Math.min.apply(Math, _toConsumableArray(transformedCoords.map(function(i) {
      return i[1];
    }))), Math.max.apply(Math, _toConsumableArray(transformedCoords.map(function(i) {
      return i[0];
    }))), Math.max.apply(Math, _toConsumableArray(transformedCoords.map(function(i) {
      return i[1];
    })))];
    return transformedBox;
  }
  function getURLFromTemplate(template, properties) {
    if (!template || !template.length) {
      return null;
    }
    if (Array.isArray(template)) {
      var index = Math.abs(properties.x + properties.y) % template.length;
      template = template[index];
    }
    var x = properties.x, y = properties.y, z = properties.z;
    return template.replace("{x}", x).replace("{y}", y).replace("{z}", z).replace("{-y}", Math.pow(2, z) - y - 1);
  }
  function getBoundingBox2(viewport3, zRange, extent) {
    var bounds;
    if (zRange && zRange.length === 2) {
      var _zRange = _slicedToArray(zRange, 2), minZ = _zRange[0], maxZ = _zRange[1];
      var bounds0 = viewport3.getBounds({
        z: minZ
      });
      var bounds1 = viewport3.getBounds({
        z: maxZ
      });
      bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
    } else {
      bounds = viewport3.getBounds();
    }
    if (!viewport3.isGeospatial) {
      return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];
    }
    return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];
  }
  function getIndexingCoords(bbox, scale5, modelMatrixInverse) {
    if (modelMatrixInverse) {
      var transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(function(i) {
        return i * scale5 / TILE_SIZE3;
      });
      return transformedTileIndex;
    }
    return bbox.map(function(i) {
      return i * scale5 / TILE_SIZE3;
    });
  }
  function getScale(z) {
    return Math.pow(2, z);
  }
  function osmTile2lngLat(x, y, z) {
    var scale5 = getScale(z);
    var lng = x / scale5 * 360 - 180;
    var n = Math.PI - 2 * Math.PI * y / scale5;
    var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    return [lng, lat];
  }
  function tile2XY(x, y, z) {
    var scale5 = getScale(z);
    return [x / scale5 * TILE_SIZE3, y / scale5 * TILE_SIZE3];
  }
  function tileToBoundingBox(viewport3, x, y, z) {
    if (viewport3.isGeospatial) {
      var _osmTile2lngLat = osmTile2lngLat(x, y, z), _osmTile2lngLat2 = _slicedToArray(_osmTile2lngLat, 2), west = _osmTile2lngLat2[0], north = _osmTile2lngLat2[1];
      var _osmTile2lngLat3 = osmTile2lngLat(x + 1, y + 1, z), _osmTile2lngLat4 = _slicedToArray(_osmTile2lngLat3, 2), east = _osmTile2lngLat4[0], south = _osmTile2lngLat4[1];
      return {
        west,
        north,
        east,
        south
      };
    }
    var _tile2XY = tile2XY(x, y, z), _tile2XY2 = _slicedToArray(_tile2XY, 2), left = _tile2XY2[0], top = _tile2XY2[1];
    var _tile2XY3 = tile2XY(x + 1, y + 1, z), _tile2XY4 = _slicedToArray(_tile2XY3, 2), right = _tile2XY4[0], bottom = _tile2XY4[1];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  function getIdentityTileIndices(viewport3, z, extent, modelMatrixInverse) {
    var bbox = getBoundingBox2(viewport3, null, extent);
    var scale5 = getScale(z);
    var _getIndexingCoords = getIndexingCoords(bbox, scale5, modelMatrixInverse), _getIndexingCoords2 = _slicedToArray(_getIndexingCoords, 4), minX = _getIndexingCoords2[0], minY = _getIndexingCoords2[1], maxX = _getIndexingCoords2[2], maxY = _getIndexingCoords2[3];
    var indices = [];
    for (var x = Math.floor(minX); x < maxX; x++) {
      for (var y = Math.floor(minY); y < maxY; y++) {
        indices.push({
          x,
          y,
          z
        });
      }
    }
    return indices;
  }
  function getTileIndices(_ref) {
    var viewport3 = _ref.viewport, maxZoom = _ref.maxZoom, minZoom = _ref.minZoom, zRange = _ref.zRange, extent = _ref.extent, _ref$tileSize = _ref.tileSize, tileSize = _ref$tileSize === void 0 ? TILE_SIZE3 : _ref$tileSize, modelMatrix = _ref.modelMatrix, modelMatrixInverse = _ref.modelMatrixInverse;
    var z = Math.round(viewport3.zoom + Math.log2(TILE_SIZE3 / tileSize));
    if (Number.isFinite(minZoom) && z < minZoom) {
      if (!extent) {
        return [];
      }
      z = minZoom;
    }
    if (Number.isFinite(maxZoom) && z > maxZoom) {
      z = maxZoom;
    }
    var transformedExtent = extent;
    if (modelMatrix && modelMatrixInverse && extent && !viewport3.isGeospatial) {
      transformedExtent = transformBox(extent, modelMatrix);
    }
    return viewport3.isGeospatial ? getOSMTileIndices(viewport3, z, zRange, extent || DEFAULT_EXTENT) : getIdentityTileIndices(viewport3, z, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
  }

  // node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tileset-2d.js
  function _createForOfIteratorHelper57(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray58(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray58(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray58(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray58(o, minLen);
  }
  function _arrayLikeToArray58(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var TILE_STATE_UNKNOWN = 0;
  var TILE_STATE_VISIBLE = 1;
  var TILE_STATE_PLACEHOLDER = 3;
  var TILE_STATE_HIDDEN = 4;
  var TILE_STATE_SELECTED = 5;
  var STRATEGY_NEVER = "never";
  var STRATEGY_DEFAULT = "best-available";
  var DEFAULT_CACHE_SCALE = 5;
  var Tileset2D = function() {
    function Tileset2D2(opts) {
      var _this = this;
      _classCallCheck(this, Tileset2D2);
      this.opts = opts;
      this._getTileData = opts.getTileData;
      this.onTileError = opts.onTileError;
      this.onTileLoad = function(tile) {
        opts.onTileLoad(tile);
        if (_this.opts.maxCacheByteSize) {
          _this._cacheByteSize += tile.byteLength;
          _this._resizeCache();
        }
      };
      this.onTileUnload = opts.onTileUnload;
      this._requestScheduler = new RequestScheduler({
        maxRequests: opts.maxRequests,
        throttleRequests: opts.maxRequests > 0
      });
      this._cache = new Map();
      this._tiles = [];
      this._dirty = false;
      this._cacheByteSize = 0;
      this._viewport = null;
      this._selectedTiles = null;
      this._frameNumber = 0;
      this.setOptions(opts);
    }
    _createClass(Tileset2D2, [{
      key: "setOptions",
      value: function setOptions(opts) {
        Object.assign(this.opts, opts);
        if (Number.isFinite(opts.maxZoom)) {
          this._maxZoom = Math.floor(opts.maxZoom);
        }
        if (Number.isFinite(opts.minZoom)) {
          this._minZoom = Math.ceil(opts.minZoom);
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        var _iterator = _createForOfIteratorHelper57(this._cache.values()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var tile = _step.value;
            if (tile.isLoading) {
              tile.abort();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "update",
      value: function update3(viewport3) {
        var _this2 = this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, zRange = _ref.zRange, modelMatrix = _ref.modelMatrix;
        var modelMatrixAsMatrix4 = new Matrix4(modelMatrix);
        var isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
        if (!viewport3.equals(this._viewport) || isModelMatrixNew) {
          if (isModelMatrixNew) {
            this._modelMatrixInverse = modelMatrix && modelMatrixAsMatrix4.clone().invert();
            this._modelMatrix = modelMatrix && modelMatrixAsMatrix4;
          }
          this._viewport = viewport3;
          var tileIndices = this.getTileIndices({
            viewport: viewport3,
            maxZoom: this._maxZoom,
            minZoom: this._minZoom,
            zRange,
            modelMatrix: this._modelMatrix,
            modelMatrixInverse: this._modelMatrixInverse
          });
          this._selectedTiles = tileIndices.map(function(index) {
            return _this2._getTile(index, true);
          });
          if (this._dirty) {
            this._rebuildTree();
          }
        }
        var changed = this.updateTileStates();
        if (this._dirty) {
          this._resizeCache();
        }
        if (changed) {
          this._frameNumber++;
        }
        return this._frameNumber;
      }
    }, {
      key: "getTileIndices",
      value: function getTileIndices2(_ref2) {
        var viewport3 = _ref2.viewport, maxZoom = _ref2.maxZoom, minZoom = _ref2.minZoom, zRange = _ref2.zRange, modelMatrix = _ref2.modelMatrix, modelMatrixInverse = _ref2.modelMatrixInverse;
        var _this$opts = this.opts, tileSize = _this$opts.tileSize, extent = _this$opts.extent;
        return getTileIndices({
          viewport: viewport3,
          maxZoom,
          minZoom,
          zRange,
          tileSize,
          extent,
          modelMatrix,
          modelMatrixInverse
        });
      }
    }, {
      key: "getTileMetadata",
      value: function getTileMetadata(_ref3) {
        var x = _ref3.x, y = _ref3.y, z = _ref3.z;
        return {
          bbox: tileToBoundingBox(this._viewport, x, y, z)
        };
      }
    }, {
      key: "getParentIndex",
      value: function getParentIndex(tileIndex) {
        tileIndex.x = Math.floor(tileIndex.x / 2);
        tileIndex.y = Math.floor(tileIndex.y / 2);
        tileIndex.z -= 1;
        return tileIndex;
      }
    }, {
      key: "updateTileStates",
      value: function updateTileStates() {
        this._updateTileStates(this.selectedTiles);
        var maxRequests = this.opts.maxRequests;
        var abortCandidates = [];
        var ongoingRequestCount = 0;
        var changed = false;
        var _iterator2 = _createForOfIteratorHelper57(this._cache.values()), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _tile = _step2.value;
            var isVisible = Boolean(_tile.state & TILE_STATE_VISIBLE);
            if (_tile.isVisible !== isVisible) {
              changed = true;
              _tile.isVisible = isVisible;
            }
            _tile.isSelected = _tile.state === TILE_STATE_SELECTED;
            if (_tile.isLoading) {
              ongoingRequestCount++;
              if (!_tile.isSelected) {
                abortCandidates.push(_tile);
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (maxRequests > 0) {
          while (ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
            var tile = abortCandidates.shift();
            tile.abort();
            ongoingRequestCount--;
          }
        }
        return changed;
      }
    }, {
      key: "_rebuildTree",
      value: function _rebuildTree() {
        var _cache = this._cache;
        var _iterator3 = _createForOfIteratorHelper57(_cache.values()), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var tile = _step3.value;
            tile.parent = null;
            tile.children.length = 0;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        var _iterator4 = _createForOfIteratorHelper57(_cache.values()), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _tile2 = _step4.value;
            var parent = this._getNearestAncestor(_tile2.x, _tile2.y, _tile2.z);
            _tile2.parent = parent;
            if (parent) {
              parent.children.push(_tile2);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }, {
      key: "_updateTileStates",
      value: function _updateTileStates(selectedTiles) {
        var _cache = this._cache;
        var refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
        var _iterator5 = _createForOfIteratorHelper57(_cache.values()), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var tile = _step5.value;
            tile.state = TILE_STATE_UNKNOWN;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        var _iterator6 = _createForOfIteratorHelper57(selectedTiles), _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
            var _tile3 = _step6.value;
            _tile3.state = TILE_STATE_SELECTED;
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        if (refinementStrategy === STRATEGY_NEVER) {
          return;
        }
        var _iterator7 = _createForOfIteratorHelper57(selectedTiles), _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
            var _tile4 = _step7.value;
            getPlaceholderInAncestors(_tile4, refinementStrategy);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        var _iterator8 = _createForOfIteratorHelper57(selectedTiles), _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
            var _tile5 = _step8.value;
            if (needsPlaceholder(_tile5)) {
              getPlaceholderInChildren(_tile5);
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }
    }, {
      key: "_resizeCache",
      value: function _resizeCache() {
        var _cache = this._cache, opts = this.opts;
        var maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
        var maxCacheByteSize = opts.maxCacheByteSize || Infinity;
        var overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
        if (overflown) {
          var _iterator9 = _createForOfIteratorHelper57(_cache), _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
              var _step9$value = _slicedToArray(_step9.value, 2), tileId = _step9$value[0], tile = _step9$value[1];
              if (!tile.isVisible) {
                this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
                _cache["delete"](tileId);
                this.onTileUnload(tile);
              }
              if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
                break;
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
          this._rebuildTree();
          this._dirty = true;
        }
        if (this._dirty) {
          this._tiles = Array.from(this._cache.values()).sort(function(t1, t2) {
            return t1.z - t2.z;
          });
          this._dirty = false;
        }
      }
    }, {
      key: "_getTile",
      value: function _getTile(_ref4, create6) {
        var x = _ref4.x, y = _ref4.y, z = _ref4.z;
        var tileId = "".concat(x, ",").concat(y, ",").concat(z);
        var tile = this._cache.get(tileId);
        if (!tile && create6) {
          tile = new Tile2DHeader({
            x,
            y,
            z,
            onTileLoad: this.onTileLoad,
            onTileError: this.onTileError
          });
          Object.assign(tile, this.getTileMetadata(tile));
          tile.loadData(this._getTileData, this._requestScheduler);
          this._cache.set(tileId, tile);
          this._dirty = true;
        } else if (tile && tile.isCancelled && !tile.isLoading) {
          tile.loadData(this._getTileData, this._requestScheduler);
        }
        return tile;
      }
    }, {
      key: "_getNearestAncestor",
      value: function _getNearestAncestor(x, y, z) {
        var _this$_minZoom = this._minZoom, _minZoom = _this$_minZoom === void 0 ? 0 : _this$_minZoom;
        var index = {
          x,
          y,
          z
        };
        while (index.z > _minZoom) {
          index = this.getParentIndex(index);
          var parent = this._getTile(index);
          if (parent) {
            return parent;
          }
        }
        return null;
      }
    }, {
      key: "tiles",
      get: function get2() {
        return this._tiles;
      }
    }, {
      key: "selectedTiles",
      get: function get2() {
        return this._selectedTiles;
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        return this._selectedTiles.every(function(tile) {
          return tile.isLoaded;
        });
      }
    }]);
    return Tileset2D2;
  }();
  function needsPlaceholder(tile) {
    var t = tile;
    while (t) {
      if (t.state & TILE_STATE_VISIBLE === 0) {
        return true;
      }
      if (t.isLoaded) {
        return false;
      }
      t = t.parent;
    }
    return true;
  }
  function getPlaceholderInAncestors(tile, refinementStrategy) {
    var parent;
    var state = TILE_STATE_PLACEHOLDER;
    while (parent = tile.parent) {
      if (tile.isLoaded) {
        state = TILE_STATE_HIDDEN;
        if (refinementStrategy === STRATEGY_DEFAULT) {
          return;
        }
      }
      parent.state = Math.max(parent.state, state);
      tile = parent;
    }
  }
  function getPlaceholderInChildren(tile) {
    var _iterator10 = _createForOfIteratorHelper57(tile.children), _step10;
    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
        var child = _step10.value;
        child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);
        if (!child.isLoaded) {
          getPlaceholderInChildren(child);
        }
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
  }

  // node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js
  function _createSuper48(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct49();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct49() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function ownKeys37(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread37(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys37(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys37(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var defaultProps12 = {
    data: [],
    dataComparator: urlType.equals,
    renderSubLayers: {
      type: "function",
      value: function value12(props) {
        return new GeoJsonLayer(props);
      },
      compare: false
    },
    getTileData: {
      type: "function",
      optional: true,
      value: null,
      compare: false
    },
    onViewportLoad: {
      type: "function",
      optional: true,
      value: null,
      compare: false
    },
    onTileLoad: {
      type: "function",
      value: function value13(tile) {
      },
      compare: false
    },
    onTileUnload: {
      type: "function",
      value: function value14(tile) {
      },
      compare: false
    },
    onTileError: {
      type: "function",
      value: function value15(err) {
        return console.error(err);
      },
      compare: false
    },
    extent: {
      type: "array",
      optional: true,
      value: null,
      compare: true
    },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: STRATEGY_DEFAULT,
    zRange: null,
    fetch: {
      type: "function",
      value: function value16(url, _ref) {
        var layer = _ref.layer, signal = _ref.signal;
        var loadOptions = _objectSpread37({}, layer.getLoadOptions());
        loadOptions.fetch = _objectSpread37(_objectSpread37({}, loadOptions.fetch), {}, {
          signal
        });
        return load(url, loadOptions);
      },
      compare: false
    },
    maxRequests: 6
  };
  var TileLayer = function(_CompositeLayer) {
    _inherits(TileLayer2, _CompositeLayer);
    var _super = _createSuper48(TileLayer2);
    function TileLayer2() {
      _classCallCheck(this, TileLayer2);
      return _super.apply(this, arguments);
    }
    _createClass(TileLayer2, [{
      key: "initializeState",
      value: function initializeState() {
        this.state = {
          tileset: null,
          isLoaded: false
        };
      }
    }, {
      key: "finalizeState",
      value: function finalizeState() {
        var tileset = this.state.tileset;
        if (tileset) {
          tileset.finalize();
        }
      }
    }, {
      key: "shouldUpdateState",
      value: function shouldUpdateState(_ref2) {
        var changeFlags = _ref2.changeFlags;
        return changeFlags.somethingChanged;
      }
    }, {
      key: "updateState",
      value: function updateState(_ref3) {
        var props = _ref3.props, changeFlags = _ref3.changeFlags;
        var tileset = this.state.tileset;
        var createTileCache = !tileset || changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
        if (createTileCache) {
          if (tileset) {
            tileset.finalize();
          }
          tileset = new Tileset2D(_objectSpread37(_objectSpread37({}, this._getTilesetOptions(props)), {}, {
            getTileData: this.getTileData.bind(this),
            onTileLoad: this._onTileLoad.bind(this),
            onTileError: this._onTileError.bind(this),
            onTileUnload: this._onTileUnload.bind(this)
          }));
          this.setState({
            tileset
          });
        } else if (changeFlags.propsChanged || changeFlags.updateTriggersChanged) {
          tileset.setOptions(this._getTilesetOptions(props));
          this.state.tileset.tiles.forEach(function(tile) {
            tile.layers = null;
          });
        }
        this._updateTileset();
      }
    }, {
      key: "_getTilesetOptions",
      value: function _getTilesetOptions(props) {
        var maxZoom = Number.isFinite(this.state.maxZoom) ? this.state.maxZoom : props.maxZoom;
        var minZoom = Number.isFinite(this.state.minZoom) ? this.state.minZoom : props.minZoom;
        var tileSize = props.tileSize, maxCacheSize = props.maxCacheSize, maxCacheByteSize = props.maxCacheByteSize, refinementStrategy = props.refinementStrategy, extent = props.extent, maxRequests = props.maxRequests;
        return {
          maxCacheSize,
          maxCacheByteSize,
          maxZoom,
          minZoom,
          tileSize,
          refinementStrategy,
          extent,
          maxRequests
        };
      }
    }, {
      key: "_updateTileset",
      value: function _updateTileset() {
        var tileset = this.state.tileset;
        var _this$props = this.props, zRange = _this$props.zRange, modelMatrix = _this$props.modelMatrix;
        var frameNumber = tileset.update(this.context.viewport, {
          zRange,
          modelMatrix
        });
        var isLoaded = tileset.isLoaded;
        var loadingStateChanged = this.state.isLoaded !== isLoaded;
        var tilesetChanged = this.state.frameNumber !== frameNumber;
        if (isLoaded && (loadingStateChanged || tilesetChanged)) {
          this._onViewportLoad();
        }
        if (tilesetChanged) {
          this.setState({
            frameNumber
          });
        }
        this.state.isLoaded = isLoaded;
      }
    }, {
      key: "_onViewportLoad",
      value: function _onViewportLoad() {
        var tileset = this.state.tileset;
        var onViewportLoad = this.props.onViewportLoad;
        if (onViewportLoad) {
          onViewportLoad(tileset.selectedTiles);
        }
      }
    }, {
      key: "_onTileLoad",
      value: function _onTileLoad(tile) {
        var layer = this.getCurrentLayer();
        layer.props.onTileLoad(tile);
        if (tile.isVisible) {
          this.setNeedsUpdate();
        }
      }
    }, {
      key: "_onTileError",
      value: function _onTileError(error2, tile) {
        var layer = this.getCurrentLayer();
        layer.props.onTileError(error2);
        layer._updateTileset();
        if (tile.isVisible) {
          this.setNeedsUpdate();
        }
      }
    }, {
      key: "_onTileUnload",
      value: function _onTileUnload(tile) {
        var layer = this.getCurrentLayer();
        layer.props.onTileUnload(tile);
      }
    }, {
      key: "getTileData",
      value: function getTileData(tile) {
        var data = this.props.data;
        var _this$getCurrentLayer = this.getCurrentLayer().props, getTileData2 = _this$getCurrentLayer.getTileData, fetch2 = _this$getCurrentLayer.fetch;
        var signal = tile.signal;
        tile.url = getURLFromTemplate(data, tile);
        if (getTileData2) {
          return getTileData2(tile);
        }
        if (tile.url) {
          return fetch2(tile.url, {
            layer: this,
            signal
          });
        }
        return null;
      }
    }, {
      key: "renderSubLayers",
      value: function renderSubLayers(props) {
        return this.props.renderSubLayers(props);
      }
    }, {
      key: "getHighlightedObjectIndex",
      value: function getHighlightedObjectIndex() {
        return -1;
      }
    }, {
      key: "getPickingInfo",
      value: function getPickingInfo(_ref4) {
        var info = _ref4.info, sourceLayer = _ref4.sourceLayer;
        info.sourceLayer = sourceLayer;
        info.tile = sourceLayer.props.tile;
        return info;
      }
    }, {
      key: "renderLayers",
      value: function renderLayers() {
        var _this = this;
        var visible = this.props.visible;
        return this.state.tileset.tiles.map(function(tile) {
          var isVisible = visible && tile.isVisible;
          var highlightedObjectIndex = _this.getHighlightedObjectIndex(tile);
          if (!tile.isLoaded) {
          } else if (!tile.layers) {
            var layers = _this.renderSubLayers(Object.assign({}, _this.props, {
              id: "".concat(_this.id, "-").concat(tile.x, "-").concat(tile.y, "-").concat(tile.z),
              data: tile.data,
              visible: isVisible,
              _offset: 0,
              tile,
              highlightedObjectIndex
            }));
            tile.layers = flatten(layers, Boolean);
          } else if (tile.layers[0] && (tile.layers[0].props.visible !== isVisible || tile.layers[0].props.highlightedObjectIndex !== highlightedObjectIndex)) {
            tile.layers = tile.layers.map(function(layer) {
              return layer.clone({
                visible: isVisible,
                highlightedObjectIndex
              });
            });
          }
          return tile.layers;
        });
      }
    }, {
      key: "isLoaded",
      get: function get2() {
        var tileset = this.state.tileset;
        return tileset.selectedTiles.every(function(tile) {
          return tile.layers && tile.layers.every(function(layer) {
            return layer.isLoaded;
          });
        });
      }
    }]);
    return TileLayer2;
  }(CompositeLayer);
  TileLayer.layerName = "TileLayer";
  TileLayer.defaultProps = defaultProps12;

  // node_modules/@luma.gl/constants/dist/esm/index.js
  var esm_default2 = {
    DEPTH_BUFFER_BIT: 256,
    STENCIL_BUFFER_BIT: 1024,
    COLOR_BUFFER_BIT: 16384,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 768,
    ONE_MINUS_SRC_COLOR: 769,
    SRC_ALPHA: 770,
    ONE_MINUS_SRC_ALPHA: 771,
    DST_ALPHA: 772,
    ONE_MINUS_DST_ALPHA: 773,
    DST_COLOR: 774,
    ONE_MINUS_DST_COLOR: 775,
    SRC_ALPHA_SATURATE: 776,
    CONSTANT_COLOR: 32769,
    ONE_MINUS_CONSTANT_COLOR: 32770,
    CONSTANT_ALPHA: 32771,
    ONE_MINUS_CONSTANT_ALPHA: 32772,
    FUNC_ADD: 32774,
    FUNC_SUBTRACT: 32778,
    FUNC_REVERSE_SUBTRACT: 32779,
    BLEND_EQUATION: 32777,
    BLEND_EQUATION_RGB: 32777,
    BLEND_EQUATION_ALPHA: 34877,
    BLEND_DST_RGB: 32968,
    BLEND_SRC_RGB: 32969,
    BLEND_DST_ALPHA: 32970,
    BLEND_SRC_ALPHA: 32971,
    BLEND_COLOR: 32773,
    ARRAY_BUFFER_BINDING: 34964,
    ELEMENT_ARRAY_BUFFER_BINDING: 34965,
    LINE_WIDTH: 2849,
    ALIASED_POINT_SIZE_RANGE: 33901,
    ALIASED_LINE_WIDTH_RANGE: 33902,
    CULL_FACE_MODE: 2885,
    FRONT_FACE: 2886,
    DEPTH_RANGE: 2928,
    DEPTH_WRITEMASK: 2930,
    DEPTH_CLEAR_VALUE: 2931,
    DEPTH_FUNC: 2932,
    STENCIL_CLEAR_VALUE: 2961,
    STENCIL_FUNC: 2962,
    STENCIL_FAIL: 2964,
    STENCIL_PASS_DEPTH_FAIL: 2965,
    STENCIL_PASS_DEPTH_PASS: 2966,
    STENCIL_REF: 2967,
    STENCIL_VALUE_MASK: 2963,
    STENCIL_WRITEMASK: 2968,
    STENCIL_BACK_FUNC: 34816,
    STENCIL_BACK_FAIL: 34817,
    STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
    STENCIL_BACK_PASS_DEPTH_PASS: 34819,
    STENCIL_BACK_REF: 36003,
    STENCIL_BACK_VALUE_MASK: 36004,
    STENCIL_BACK_WRITEMASK: 36005,
    VIEWPORT: 2978,
    SCISSOR_BOX: 3088,
    COLOR_CLEAR_VALUE: 3106,
    COLOR_WRITEMASK: 3107,
    UNPACK_ALIGNMENT: 3317,
    PACK_ALIGNMENT: 3333,
    MAX_TEXTURE_SIZE: 3379,
    MAX_VIEWPORT_DIMS: 3386,
    SUBPIXEL_BITS: 3408,
    RED_BITS: 3410,
    GREEN_BITS: 3411,
    BLUE_BITS: 3412,
    ALPHA_BITS: 3413,
    DEPTH_BITS: 3414,
    STENCIL_BITS: 3415,
    POLYGON_OFFSET_UNITS: 10752,
    POLYGON_OFFSET_FACTOR: 32824,
    TEXTURE_BINDING_2D: 32873,
    SAMPLE_BUFFERS: 32936,
    SAMPLES: 32937,
    SAMPLE_COVERAGE_VALUE: 32938,
    SAMPLE_COVERAGE_INVERT: 32939,
    COMPRESSED_TEXTURE_FORMATS: 34467,
    VENDOR: 7936,
    RENDERER: 7937,
    VERSION: 7938,
    IMPLEMENTATION_COLOR_READ_TYPE: 35738,
    IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
    BROWSER_DEFAULT_WEBGL: 37444,
    STATIC_DRAW: 35044,
    STREAM_DRAW: 35040,
    DYNAMIC_DRAW: 35048,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    BUFFER_SIZE: 34660,
    BUFFER_USAGE: 34661,
    CURRENT_VERTEX_ATTRIB: 34342,
    VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
    VERTEX_ATTRIB_ARRAY_SIZE: 34339,
    VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
    VERTEX_ATTRIB_ARRAY_TYPE: 34341,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
    VERTEX_ATTRIB_ARRAY_POINTER: 34373,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
    CULL_FACE: 2884,
    FRONT: 1028,
    BACK: 1029,
    FRONT_AND_BACK: 1032,
    BLEND: 3042,
    DEPTH_TEST: 2929,
    DITHER: 3024,
    POLYGON_OFFSET_FILL: 32823,
    SAMPLE_ALPHA_TO_COVERAGE: 32926,
    SAMPLE_COVERAGE: 32928,
    SCISSOR_TEST: 3089,
    STENCIL_TEST: 2960,
    NO_ERROR: 0,
    INVALID_ENUM: 1280,
    INVALID_VALUE: 1281,
    INVALID_OPERATION: 1282,
    OUT_OF_MEMORY: 1285,
    CONTEXT_LOST_WEBGL: 37442,
    CW: 2304,
    CCW: 2305,
    DONT_CARE: 4352,
    FASTEST: 4353,
    NICEST: 4354,
    GENERATE_MIPMAP_HINT: 33170,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130,
    DEPTH_COMPONENT: 6402,
    ALPHA: 6406,
    RGB: 6407,
    RGBA: 6408,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    UNSIGNED_SHORT_5_6_5: 33635,
    FRAGMENT_SHADER: 35632,
    VERTEX_SHADER: 35633,
    COMPILE_STATUS: 35713,
    DELETE_STATUS: 35712,
    LINK_STATUS: 35714,
    VALIDATE_STATUS: 35715,
    ATTACHED_SHADERS: 35717,
    ACTIVE_ATTRIBUTES: 35721,
    ACTIVE_UNIFORMS: 35718,
    MAX_VERTEX_ATTRIBS: 34921,
    MAX_VERTEX_UNIFORM_VECTORS: 36347,
    MAX_VARYING_VECTORS: 36348,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
    MAX_TEXTURE_IMAGE_UNITS: 34930,
    MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
    SHADER_TYPE: 35663,
    SHADING_LANGUAGE_VERSION: 35724,
    CURRENT_PROGRAM: 35725,
    NEVER: 512,
    ALWAYS: 519,
    LESS: 513,
    EQUAL: 514,
    LEQUAL: 515,
    GREATER: 516,
    GEQUAL: 518,
    NOTEQUAL: 517,
    KEEP: 7680,
    REPLACE: 7681,
    INCR: 7682,
    DECR: 7683,
    INVERT: 5386,
    INCR_WRAP: 34055,
    DECR_WRAP: 34056,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    TEXTURE_2D: 3553,
    TEXTURE: 5890,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_BINDING_CUBE_MAP: 34068,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
    MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
    TEXTURE0: 33984,
    ACTIVE_TEXTURE: 34016,
    REPEAT: 10497,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    TEXTURE_WIDTH: 4096,
    TEXTURE_HEIGHT: 4097,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    INT_VEC2: 35667,
    INT_VEC3: 35668,
    INT_VEC4: 35669,
    BOOL: 35670,
    BOOL_VEC2: 35671,
    BOOL_VEC3: 35672,
    BOOL_VEC4: 35673,
    FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    SAMPLER_2D: 35678,
    SAMPLER_CUBE: 35680,
    LOW_FLOAT: 36336,
    MEDIUM_FLOAT: 36337,
    HIGH_FLOAT: 36338,
    LOW_INT: 36339,
    MEDIUM_INT: 36340,
    HIGH_INT: 36341,
    FRAMEBUFFER: 36160,
    RENDERBUFFER: 36161,
    RGBA4: 32854,
    RGB5_A1: 32855,
    RGB565: 36194,
    DEPTH_COMPONENT16: 33189,
    STENCIL_INDEX: 6401,
    STENCIL_INDEX8: 36168,
    DEPTH_STENCIL: 34041,
    RENDERBUFFER_WIDTH: 36162,
    RENDERBUFFER_HEIGHT: 36163,
    RENDERBUFFER_INTERNAL_FORMAT: 36164,
    RENDERBUFFER_RED_SIZE: 36176,
    RENDERBUFFER_GREEN_SIZE: 36177,
    RENDERBUFFER_BLUE_SIZE: 36178,
    RENDERBUFFER_ALPHA_SIZE: 36179,
    RENDERBUFFER_DEPTH_SIZE: 36180,
    RENDERBUFFER_STENCIL_SIZE: 36181,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
    COLOR_ATTACHMENT0: 36064,
    DEPTH_ATTACHMENT: 36096,
    STENCIL_ATTACHMENT: 36128,
    DEPTH_STENCIL_ATTACHMENT: 33306,
    NONE: 0,
    FRAMEBUFFER_COMPLETE: 36053,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
    FRAMEBUFFER_UNSUPPORTED: 36061,
    FRAMEBUFFER_BINDING: 36006,
    RENDERBUFFER_BINDING: 36007,
    READ_FRAMEBUFFER: 36008,
    DRAW_FRAMEBUFFER: 36009,
    MAX_RENDERBUFFER_SIZE: 34024,
    INVALID_FRAMEBUFFER_OPERATION: 1286,
    UNPACK_FLIP_Y_WEBGL: 37440,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
    READ_BUFFER: 3074,
    UNPACK_ROW_LENGTH: 3314,
    UNPACK_SKIP_ROWS: 3315,
    UNPACK_SKIP_PIXELS: 3316,
    PACK_ROW_LENGTH: 3330,
    PACK_SKIP_ROWS: 3331,
    PACK_SKIP_PIXELS: 3332,
    TEXTURE_BINDING_3D: 32874,
    UNPACK_SKIP_IMAGES: 32877,
    UNPACK_IMAGE_HEIGHT: 32878,
    MAX_3D_TEXTURE_SIZE: 32883,
    MAX_ELEMENTS_VERTICES: 33e3,
    MAX_ELEMENTS_INDICES: 33001,
    MAX_TEXTURE_LOD_BIAS: 34045,
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
    MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
    MAX_ARRAY_TEXTURE_LAYERS: 35071,
    MIN_PROGRAM_TEXEL_OFFSET: 35076,
    MAX_PROGRAM_TEXEL_OFFSET: 35077,
    MAX_VARYING_COMPONENTS: 35659,
    FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
    RASTERIZER_DISCARD: 35977,
    VERTEX_ARRAY_BINDING: 34229,
    MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
    MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
    MAX_SERVER_WAIT_TIMEOUT: 37137,
    MAX_ELEMENT_INDEX: 36203,
    RED: 6403,
    RGB8: 32849,
    RGBA8: 32856,
    RGB10_A2: 32857,
    TEXTURE_3D: 32879,
    TEXTURE_WRAP_R: 32882,
    TEXTURE_MIN_LOD: 33082,
    TEXTURE_MAX_LOD: 33083,
    TEXTURE_BASE_LEVEL: 33084,
    TEXTURE_MAX_LEVEL: 33085,
    TEXTURE_COMPARE_MODE: 34892,
    TEXTURE_COMPARE_FUNC: 34893,
    SRGB: 35904,
    SRGB8: 35905,
    SRGB8_ALPHA8: 35907,
    COMPARE_REF_TO_TEXTURE: 34894,
    RGBA32F: 34836,
    RGB32F: 34837,
    RGBA16F: 34842,
    RGB16F: 34843,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_BINDING_2D_ARRAY: 35869,
    R11F_G11F_B10F: 35898,
    RGB9_E5: 35901,
    RGBA32UI: 36208,
    RGB32UI: 36209,
    RGBA16UI: 36214,
    RGB16UI: 36215,
    RGBA8UI: 36220,
    RGB8UI: 36221,
    RGBA32I: 36226,
    RGB32I: 36227,
    RGBA16I: 36232,
    RGB16I: 36233,
    RGBA8I: 36238,
    RGB8I: 36239,
    RED_INTEGER: 36244,
    RGB_INTEGER: 36248,
    RGBA_INTEGER: 36249,
    R8: 33321,
    RG8: 33323,
    R16F: 33325,
    R32F: 33326,
    RG16F: 33327,
    RG32F: 33328,
    R8I: 33329,
    R8UI: 33330,
    R16I: 33331,
    R16UI: 33332,
    R32I: 33333,
    R32UI: 33334,
    RG8I: 33335,
    RG8UI: 33336,
    RG16I: 33337,
    RG16UI: 33338,
    RG32I: 33339,
    RG32UI: 33340,
    R8_SNORM: 36756,
    RG8_SNORM: 36757,
    RGB8_SNORM: 36758,
    RGBA8_SNORM: 36759,
    RGB10_A2UI: 36975,
    TEXTURE_IMMUTABLE_FORMAT: 37167,
    TEXTURE_IMMUTABLE_LEVELS: 33503,
    UNSIGNED_INT_2_10_10_10_REV: 33640,
    UNSIGNED_INT_10F_11F_11F_REV: 35899,
    UNSIGNED_INT_5_9_9_9_REV: 35902,
    FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
    UNSIGNED_INT_24_8: 34042,
    HALF_FLOAT: 5131,
    RG: 33319,
    RG_INTEGER: 33320,
    INT_2_10_10_10_REV: 36255,
    CURRENT_QUERY: 34917,
    QUERY_RESULT: 34918,
    QUERY_RESULT_AVAILABLE: 34919,
    ANY_SAMPLES_PASSED: 35887,
    ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
    MAX_DRAW_BUFFERS: 34852,
    DRAW_BUFFER0: 34853,
    DRAW_BUFFER1: 34854,
    DRAW_BUFFER2: 34855,
    DRAW_BUFFER3: 34856,
    DRAW_BUFFER4: 34857,
    DRAW_BUFFER5: 34858,
    DRAW_BUFFER6: 34859,
    DRAW_BUFFER7: 34860,
    DRAW_BUFFER8: 34861,
    DRAW_BUFFER9: 34862,
    DRAW_BUFFER10: 34863,
    DRAW_BUFFER11: 34864,
    DRAW_BUFFER12: 34865,
    DRAW_BUFFER13: 34866,
    DRAW_BUFFER14: 34867,
    DRAW_BUFFER15: 34868,
    MAX_COLOR_ATTACHMENTS: 36063,
    COLOR_ATTACHMENT1: 36065,
    COLOR_ATTACHMENT2: 36066,
    COLOR_ATTACHMENT3: 36067,
    COLOR_ATTACHMENT4: 36068,
    COLOR_ATTACHMENT5: 36069,
    COLOR_ATTACHMENT6: 36070,
    COLOR_ATTACHMENT7: 36071,
    COLOR_ATTACHMENT8: 36072,
    COLOR_ATTACHMENT9: 36073,
    COLOR_ATTACHMENT10: 36074,
    COLOR_ATTACHMENT11: 36075,
    COLOR_ATTACHMENT12: 36076,
    COLOR_ATTACHMENT13: 36077,
    COLOR_ATTACHMENT14: 36078,
    COLOR_ATTACHMENT15: 36079,
    SAMPLER_3D: 35679,
    SAMPLER_2D_SHADOW: 35682,
    SAMPLER_2D_ARRAY: 36289,
    SAMPLER_2D_ARRAY_SHADOW: 36292,
    SAMPLER_CUBE_SHADOW: 36293,
    INT_SAMPLER_2D: 36298,
    INT_SAMPLER_3D: 36299,
    INT_SAMPLER_CUBE: 36300,
    INT_SAMPLER_2D_ARRAY: 36303,
    UNSIGNED_INT_SAMPLER_2D: 36306,
    UNSIGNED_INT_SAMPLER_3D: 36307,
    UNSIGNED_INT_SAMPLER_CUBE: 36308,
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
    MAX_SAMPLES: 36183,
    SAMPLER_BINDING: 35097,
    PIXEL_PACK_BUFFER: 35051,
    PIXEL_UNPACK_BUFFER: 35052,
    PIXEL_PACK_BUFFER_BINDING: 35053,
    PIXEL_UNPACK_BUFFER_BINDING: 35055,
    COPY_READ_BUFFER: 36662,
    COPY_WRITE_BUFFER: 36663,
    COPY_READ_BUFFER_BINDING: 36662,
    COPY_WRITE_BUFFER_BINDING: 36663,
    FLOAT_MAT2x3: 35685,
    FLOAT_MAT2x4: 35686,
    FLOAT_MAT3x2: 35687,
    FLOAT_MAT3x4: 35688,
    FLOAT_MAT4x2: 35689,
    FLOAT_MAT4x3: 35690,
    UNSIGNED_INT_VEC2: 36294,
    UNSIGNED_INT_VEC3: 36295,
    UNSIGNED_INT_VEC4: 36296,
    UNSIGNED_NORMALIZED: 35863,
    SIGNED_NORMALIZED: 36764,
    VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
    VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
    TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
    TRANSFORM_FEEDBACK_VARYINGS: 35971,
    TRANSFORM_FEEDBACK_BUFFER_START: 35972,
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
    INTERLEAVED_ATTRIBS: 35980,
    SEPARATE_ATTRIBS: 35981,
    TRANSFORM_FEEDBACK_BUFFER: 35982,
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
    TRANSFORM_FEEDBACK: 36386,
    TRANSFORM_FEEDBACK_PAUSED: 36387,
    TRANSFORM_FEEDBACK_ACTIVE: 36388,
    TRANSFORM_FEEDBACK_BINDING: 36389,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
    FRAMEBUFFER_DEFAULT: 33304,
    DEPTH24_STENCIL8: 35056,
    DRAW_FRAMEBUFFER_BINDING: 36006,
    READ_FRAMEBUFFER_BINDING: 36010,
    RENDERBUFFER_SAMPLES: 36011,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
    UNIFORM_BUFFER: 35345,
    UNIFORM_BUFFER_BINDING: 35368,
    UNIFORM_BUFFER_START: 35369,
    UNIFORM_BUFFER_SIZE: 35370,
    MAX_VERTEX_UNIFORM_BLOCKS: 35371,
    MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
    MAX_COMBINED_UNIFORM_BLOCKS: 35374,
    MAX_UNIFORM_BUFFER_BINDINGS: 35375,
    MAX_UNIFORM_BLOCK_SIZE: 35376,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
    ACTIVE_UNIFORM_BLOCKS: 35382,
    UNIFORM_TYPE: 35383,
    UNIFORM_SIZE: 35384,
    UNIFORM_BLOCK_INDEX: 35386,
    UNIFORM_OFFSET: 35387,
    UNIFORM_ARRAY_STRIDE: 35388,
    UNIFORM_MATRIX_STRIDE: 35389,
    UNIFORM_IS_ROW_MAJOR: 35390,
    UNIFORM_BLOCK_BINDING: 35391,
    UNIFORM_BLOCK_DATA_SIZE: 35392,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
    OBJECT_TYPE: 37138,
    SYNC_CONDITION: 37139,
    SYNC_STATUS: 37140,
    SYNC_FLAGS: 37141,
    SYNC_FENCE: 37142,
    SYNC_GPU_COMMANDS_COMPLETE: 37143,
    UNSIGNALED: 37144,
    SIGNALED: 37145,
    ALREADY_SIGNALED: 37146,
    TIMEOUT_EXPIRED: 37147,
    CONDITION_SATISFIED: 37148,
    WAIT_FAILED: 37149,
    SYNC_FLUSH_COMMANDS_BIT: 1,
    COLOR: 6144,
    DEPTH: 6145,
    STENCIL: 6146,
    MIN: 32775,
    MAX: 32776,
    DEPTH_COMPONENT24: 33190,
    STREAM_READ: 35041,
    STREAM_COPY: 35042,
    STATIC_READ: 35045,
    STATIC_COPY: 35046,
    DYNAMIC_READ: 35049,
    DYNAMIC_COPY: 35050,
    DEPTH_COMPONENT32F: 36012,
    DEPTH32F_STENCIL8: 36013,
    INVALID_INDEX: 4294967295,
    TIMEOUT_IGNORED: -1,
    MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
    UNMASKED_VENDOR_WEBGL: 37445,
    UNMASKED_RENDERER_WEBGL: 37446,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
    TEXTURE_MAX_ANISOTROPY_EXT: 34046,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    UNSIGNED_INT_24_8_WEBGL: 34042,
    HALF_FLOAT_OES: 36193,
    RGBA32F_EXT: 34836,
    RGB32F_EXT: 34837,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297,
    UNSIGNED_NORMALIZED_EXT: 35863,
    MIN_EXT: 32775,
    MAX_EXT: 32776,
    SRGB_EXT: 35904,
    SRGB_ALPHA_EXT: 35906,
    SRGB8_ALPHA8_EXT: 35907,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296,
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723,
    COLOR_ATTACHMENT0_WEBGL: 36064,
    COLOR_ATTACHMENT1_WEBGL: 36065,
    COLOR_ATTACHMENT2_WEBGL: 36066,
    COLOR_ATTACHMENT3_WEBGL: 36067,
    COLOR_ATTACHMENT4_WEBGL: 36068,
    COLOR_ATTACHMENT5_WEBGL: 36069,
    COLOR_ATTACHMENT6_WEBGL: 36070,
    COLOR_ATTACHMENT7_WEBGL: 36071,
    COLOR_ATTACHMENT8_WEBGL: 36072,
    COLOR_ATTACHMENT9_WEBGL: 36073,
    COLOR_ATTACHMENT10_WEBGL: 36074,
    COLOR_ATTACHMENT11_WEBGL: 36075,
    COLOR_ATTACHMENT12_WEBGL: 36076,
    COLOR_ATTACHMENT13_WEBGL: 36077,
    COLOR_ATTACHMENT14_WEBGL: 36078,
    COLOR_ATTACHMENT15_WEBGL: 36079,
    DRAW_BUFFER0_WEBGL: 34853,
    DRAW_BUFFER1_WEBGL: 34854,
    DRAW_BUFFER2_WEBGL: 34855,
    DRAW_BUFFER3_WEBGL: 34856,
    DRAW_BUFFER4_WEBGL: 34857,
    DRAW_BUFFER5_WEBGL: 34858,
    DRAW_BUFFER6_WEBGL: 34859,
    DRAW_BUFFER7_WEBGL: 34860,
    DRAW_BUFFER8_WEBGL: 34861,
    DRAW_BUFFER9_WEBGL: 34862,
    DRAW_BUFFER10_WEBGL: 34863,
    DRAW_BUFFER11_WEBGL: 34864,
    DRAW_BUFFER12_WEBGL: 34865,
    DRAW_BUFFER13_WEBGL: 34866,
    DRAW_BUFFER14_WEBGL: 34867,
    DRAW_BUFFER15_WEBGL: 34868,
    MAX_COLOR_ATTACHMENTS_WEBGL: 36063,
    MAX_DRAW_BUFFERS_WEBGL: 34852,
    VERTEX_ARRAY_BINDING_OES: 34229,
    QUERY_COUNTER_BITS_EXT: 34916,
    CURRENT_QUERY_EXT: 34917,
    QUERY_RESULT_EXT: 34918,
    QUERY_RESULT_AVAILABLE_EXT: 34919,
    TIME_ELAPSED_EXT: 35007,
    TIMESTAMP_EXT: 36392,
    GPU_DISJOINT_EXT: 36795
  };

  // src/wxtilelayer.ts
  var WxTile = class extends BitmapLayer {
    constructor(...a) {
      super(...a);
    }
    updateState(a) {
      super.updateState(a);
      this.state.model.setUniforms({
        clutTextureUniform: this.props.clutTextureUniform,
        zoom: this.props.zoom,
        dataMin: this.props.dataMin,
        dataDif: this.props.dataDif,
        clutMin: this.props.clutMin,
        clutDif: this.props.clutDif
      });
    }
    getShaders() {
      return {vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default]};
    }
  };
  WxTile.layerName = "WxTile";
  var WxTilesLayer = class extends TileLayer {
    constructor(...a) {
      super(...a);
    }
    initializeState(params) {
      super.initializeState(param);
      this.loadAssets(this.context.gl);
    }
    onClick(...a) {
      console.log("WxTilesLayer onClick:", a[0].bitmap.pixel);
    }
    renderSubLayers(props) {
      const tile = props.tile;
      const {west, south, east, north} = tile.bbox;
      const tileLayer = new WxTile(props, {
        id: props.id + "BM-layer",
        data: null,
        image: props.data,
        clutTextureUniform: this.state.clutTextureUniform,
        zoom: tile.z,
        dataMin: 0,
        dataDif: 1,
        clutMin: 0,
        clutDif: 1,
        _imageCoordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
        bounds: [west, south, east, north]
      });
      const subLayers = [
        tileLayer,
        new TextLayer({
          id: props.id + "tile",
          data: [{}],
          getPosition: (d) => [west + 2, north - 2],
          getText: (d) => props.id,
          getColor: (d) => [0, 0, 255],
          minZoom: 0,
          maxZoom: 40,
          billboard: false,
          getSize: 10,
          getTextAnchor: "start"
        }),
        new PathLayer({
          id: props.id + "border",
          visible: props.visible,
          data: [
            [
              [west, north],
              [west, south],
              [east, south],
              [east, north],
              [west, north]
            ]
          ],
          getPath: (d) => d,
          getColor: [255, 0, 0, 120],
          widthMinPixels: 1
        })
      ];
      return subLayers;
    }
    loadAssets(gl) {
      function loadTexture(gl2, url) {
        return loadImage(url).then((data) => new Texture2D(gl2, {
          data,
          parameters: {
            [esm_default2.TEXTURE_WRAP_S]: esm_default2.CLAMP_TO_EDGE,
            [esm_default2.TEXTURE_WRAP_T]: esm_default2.CLAMP_TO_EDGE,
            [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.NEAREST,
            [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.NEAREST
          },
          mipmaps: false
        }));
      }
      loadTexture(gl, "./clut.png").then((clutTextureUniform) => {
        this.setState({clutTextureUniform});
      });
    }
  };
  WxTilesLayer.layerName = "WxTilesLayer";

  // src/wxtools.ts
  var __units_default_preset = {
    comment1: ["degC: ['K', 1, 273.15] -> degC = K * 1 + 273.15", 0],
    comment2: ["hPa: ['Pa', 100]' -> hPa = Pa * 100 + 0 (0 - could be ommited)", 0],
    K: ["K", 1],
    F: ["K", 0.5555555555, 255.372222222],
    C: ["K", 1, 273.15],
    degC: ["K", 1, 273.15],
    "kg/m^2/s": ["kg/m^2/s", 1],
    "Kg m**-2 s**-1": ["kg/m^2/s", 1],
    "W/m^2": ["W/m^2", 1],
    "W m**2": ["W/m^2", 1],
    "m/s": ["m/s", 1],
    "m s**-1": ["m/s", 1],
    knot: ["m/s", 0.514444],
    knots: ["m/s", 0.514444],
    "km/h": ["m/s", 0.27777777777],
    s: ["s", 1],
    sec: ["s", 1],
    h: ["s", 3600],
    min: ["s", 60],
    m: ["m", 1],
    cm: ["m", 0.01],
    inch: ["m", 0.0254],
    Pa: ["Pa", 1],
    hPa: ["Pa", 100]
  };
  var __colorSchemes_default_preset = {
    none: ["#00000000", "#00000000"],
    rainbow: ["#f00", "#ff0", "#0f0", "#0ff", "#00f", "#f0f"],
    rainbow2: ["#f00", "#ff0", "#0f0", "#0ff", "#00f", "#f0f", "#f00"],
    rainbowzerro: ["#ff000000", "#f00", "#ff0", "#0f0", "#0ff", "#00f", "#f0f"],
    bluebird: ["#00f", "#f0f", "#0ff", "#80f", "#88f"],
    bluebirdzerro: ["#0000ff00", "#00f", "#f0f", "#0ff", "#80f", "#88f"],
    bw: ["#000", "#fff"],
    wb: ["#fff", "#000"],
    redish: ["#f0f", "#f00", "#ff0"],
    greenish: ["#ff0", "#0f0", "#0ff"],
    blueish: ["#f0f", "#00f", "#0ff"],
    hspastel: ["#AC6EA4FF", "#8E92BDFF", "#ACD4DEFF", "#E9DC8EFF", "#E7A97DFF", "#E59074FF", "#BE7E68FF", "#A88F86FF"]
  };
  var __colorStyles_default_preset = {
    base: {
      parent: void 0,
      name: "base",
      fill: "gradient",
      isolineColor: "inverted",
      isolineText: true,
      vectorType: "arrows",
      vectorColor: "inverted",
      streamLineColor: "#777",
      streamLineSpeedFactor: 1,
      streamLineStatic: false,
      showBelowMin: true,
      showAboveMax: true,
      colorScheme: "rainbow",
      colors: void 0,
      colorMap: void 0,
      levels: void 0,
      blurRadius: 0,
      addDegrees: 0,
      units: "",
      extraUnits: void 0
    },
    custom: {
      parent: void 0,
      name: "custom",
      fill: "gradient",
      isolineColor: "inverted",
      isolineText: true,
      vectorType: "arrows",
      vectorColor: "inverted",
      streamLineColor: "#777",
      streamLineSpeedFactor: 1,
      streamLineStatic: false,
      showBelowMin: true,
      showAboveMax: true,
      colorScheme: "rainbow",
      colors: void 0,
      colorMap: void 0,
      levels: void 0,
      blurRadius: 0,
      addDegrees: 0,
      units: "",
      extraUnits: void 0
    }
  };
  var _units;
  var _colorSchemes;
  var _colorStylesUnrolled;
  function WxTileLibSetup({colorStyles = {}, units = {}, colorSchemes = {}} = {}) {
    if (window.wxlogging) {
      console.log("WxTile lib setup: start");
    }
    _units = Object.assign({}, __units_default_preset, units);
    _colorSchemes = Object.assign({}, colorSchemes, __colorSchemes_default_preset);
    _colorStylesUnrolled = unrollStylesParent(colorStyles);
    if (window.wxlogging) {
      console.log("WxTile lib setup: styles unrolled");
    }
    document.fonts.load("32px barbs");
    document.fonts.load("32px arrows");
    if (window.wxlogging) {
      console.log("WxTile lib setup is done" + JSON.stringify({colorStyles, units, colorSchemes}));
    }
  }
  function WxGetColorStyles() {
    return _colorStylesUnrolled;
  }
  function unrollStylesParent(stylesArrInc) {
    const stylesInc = Object.assign({}, __colorStyles_default_preset);
    for (const name in stylesArrInc) {
      const styleA = stylesArrInc[name];
      if (Array.isArray(styleA)) {
        for (let i = 0; i < styleA.length; ++i) {
          stylesInc[name + "[" + i + "]"] = Object.assign({}, styleA[i]);
        }
      } else {
        stylesInc[name] = Object.assign({}, styleA);
      }
    }
    const inherit = (stylesInc2, name) => {
      if (name === "base")
        return __colorStyles_default_preset.base;
      const style = stylesInc2[name];
      if (!style.parent || !(style.parent in stylesInc2))
        style.parent = "base";
      const parent = inherit(stylesInc2, style.parent);
      return Object.assign(style, Object.assign({}, parent, style, {parent: "base"}));
    };
    const styles = {};
    for (const name in stylesInc) {
      styles[name] = inherit(stylesInc, name);
    }
    return styles;
  }

  // src/index.ts
  async function fetchJson(url) {
    console.log(url);
    const req = await fetch(url, {mode: "cors"});
    const jso = await req.json();
    return jso;
  }
  async function getURI() {
    const dataServer = "https://tiles.metoceanapi.com/data/";
    const dataSet = "ecwmf.global/";
    const variable = "air.temperature.at-2m/";
    const instances = await fetchJson(dataServer + dataSet + "instances.json");
    const instance = instances.reverse()[0] + "/";
    const meta = await fetchJson(dataServer + dataSet + instance + "meta.json");
    const {times} = meta;
    const time = times.find((t) => new Date(t).getTime() >= Date.now()) || times[times.length - 1];
    const URI = dataServer + dataSet + instance + variable + time + "/{z}/{x}/{y}.png";
    const URITime = dataServer + dataSet + instance + variable + "{time}/{z}/{x}/{y}.png";
    return {URI, URITime, meta};
  }
  async function start() {
    const wxlibCustomSettings = {};
    try {
      wxlibCustomSettings.colorStyles = await fetchJson("styles/styles.json");
    } catch (e) {
      console.log(e);
    }
    try {
      wxlibCustomSettings.units = await fetchJson("styles/uconv.json");
    } catch (e) {
      console.log(e);
    }
    try {
      wxlibCustomSettings.colorSchemes = await fetchJson("styles/colorschemes.json");
    } catch (e) {
      console.log(e);
    }
    WxTileLibSetup(wxlibCustomSettings);
    await document.fonts.ready;
    const styles = WxGetColorStyles();
    const style = styles["Sea.surface.temperature"];
    const {URI, URITime, meta} = await getURI();
    const layers = [
      new TextLayer({
        data: [{}],
        getText: () => "Text",
        getPosition: () => [0, 0],
        getColor: () => [0, 0, 255]
      }),
      new WxTilesLayer({
        style,
        data: URI,
        maxZoom: meta.maxZoom,
        pickable: true,
        tileSize: 256
      })
    ];
    const deckgl = new Deck({
      initialViewState: {latitude: -41, longitude: 175, zoom: 1},
      controller: true,
      views: new GlobeView({id: "globe", controller: true}),
      layers
    });
  }
  return src_exports;
})();
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
//# sourceMappingURL=wxtiledeckgl.js.map
